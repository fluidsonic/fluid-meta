// ------------------------------------------------------------------------------------------------------
// Example output for all elements for Kotlin's Standard Library 1.8.22
// ------------------------------------------------------------------------------------------------------

module `kotlin-stdlib` {

	package kotlin {

		/* multipart */ class ExceptionsKt {

			/* part */ class ExceptionsKt__ExceptionsKt
		}

		/* multipart */ class LazyKt {

			/* part */ class LazyKt__LazyJVMKt
			/* part */ class LazyKt__LazyKt
		}

		/* multipart */ class NumbersKt {

			/* part */ class NumbersKt__BigDecimalsKt
			/* part */ class NumbersKt__BigIntegersKt
			/* part */ class NumbersKt__FloorDivModKt
			/* part */ class NumbersKt__NumbersJVMKt
			/* part */ class NumbersKt__NumbersKt
		}

		/* multipart */ class PreconditionsKt {

			/* part */ class PreconditionsKt__AssertionsJVMKt
			/* part */ class PreconditionsKt__PreconditionsKt
		}

		/* multipart */ class StandardKt {

			/* part */ class StandardKt__StandardKt
			/* part */ class StandardKt__SynchronizedKt
		}
	}

	package kotlin.collections {

		/* multipart */ class ArraysKt {

			/* part */ class ArraysKt__ArraysJVMKt
			/* part */ class ArraysKt__ArraysKt
			/* part */ class ArraysKt___ArraysJvmKt
			/* part */ class ArraysKt___ArraysKt
		}

		/* multipart */ class CollectionsKt {

			/* part */ class CollectionsKt__CollectionsJVMKt
			/* part */ class CollectionsKt__CollectionsKt
			/* part */ class CollectionsKt__IterablesKt
			/* part */ class CollectionsKt__IteratorsJVMKt
			/* part */ class CollectionsKt__IteratorsKt
			/* part */ class CollectionsKt__MutableCollectionsJVMKt
			/* part */ class CollectionsKt__MutableCollectionsKt
			/* part */ class CollectionsKt__ReversedViewsKt
			/* part */ class CollectionsKt___CollectionsJvmKt
			/* part */ class CollectionsKt___CollectionsKt
		}

		/* multipart */ class GroupingKt {

			/* part */ class GroupingKt__GroupingJVMKt
			/* part */ class GroupingKt__GroupingKt
		}

		/* multipart */ class MapsKt {

			/* part */ class MapsKt__MapWithDefaultKt
			/* part */ class MapsKt__MapsJVMKt
			/* part */ class MapsKt__MapsKt
			/* part */ class MapsKt___MapsJvmKt
			/* part */ class MapsKt___MapsKt
		}

		/* multipart */ class SetsKt {

			/* part */ class SetsKt__SetsJVMKt
			/* part */ class SetsKt__SetsKt
			/* part */ class SetsKt___SetsKt
		}

		/* multipart */ class UCollectionsKt {

			/* part */ class UCollectionsKt___UCollectionsKt
		}

		/* multipart */ class kotlin.collections.unsigned.UArraysKt {

			/* part */ class kotlin.collections.unsigned.UArraysKt___UArraysJvmKt
			/* part */ class kotlin.collections.unsigned.UArraysKt___UArraysKt
		}
	}

	package kotlin.collections.builders

	package kotlin.comparisons {

		/* multipart */ class ComparisonsKt {

			/* part */ class ComparisonsKt__ComparisonsKt
			/* part */ class ComparisonsKt___ComparisonsJvmKt
			/* part */ class ComparisonsKt___ComparisonsKt
		}

		/* multipart */ class UComparisonsKt {

			/* part */ class UComparisonsKt___UComparisonsKt
		}
	}

	package kotlin.concurrent

	package kotlin.contracts

	package kotlin.coroutines

	package kotlin.coroutines.cancellation

	package kotlin.coroutines.intrinsics {

		/* multipart */ class kotlin.coroutines.intrinsics.IntrinsicsKt {

			/* part */ class kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt
			/* part */ class kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsKt
		}
	}

	package kotlin.coroutines.jvm.internal

	package kotlin.enums

	package kotlin.experimental

	package kotlin.internal

	package kotlin.io {

		/* multipart */ class FilesKt {

			/* part */ class FilesKt__FilePathComponentsKt
			/* part */ class FilesKt__FileReadWriteKt
			/* part */ class FilesKt__FileTreeWalkKt
			/* part */ class FilesKt__UtilsKt
		}
	}

	package kotlin.io.encoding {

		/* multipart */ class kotlin.io.encoding.StreamEncodingKt {

			/* part */ class kotlin.io.encoding.StreamEncodingKt__Base64IOStreamKt
		}
	}

	package kotlin.jvm

	package kotlin.jvm.internal

	package kotlin.jvm.internal.unsafe

	package kotlin.math {

		/* multipart */ class kotlin.math.MathKt {

			/* part */ class kotlin.math.MathKt__MathHKt
			/* part */ class kotlin.math.MathKt__MathJVMKt
		}
	}

	package kotlin.random

	package kotlin.ranges {

		/* multipart */ class RangesKt {

			/* part */ class RangesKt__RangesKt
			/* part */ class RangesKt___RangesKt
		}

		/* multipart */ class URangesKt {

			/* part */ class URangesKt___URangesKt
		}
	}

	package kotlin.reflect

	package kotlin.sequences {

		/* multipart */ class SequencesKt {

			/* part */ class SequencesKt__SequenceBuilderKt
			/* part */ class SequencesKt__SequencesJVMKt
			/* part */ class SequencesKt__SequencesKt
			/* part */ class SequencesKt___SequencesJvmKt
			/* part */ class SequencesKt___SequencesKt
		}

		/* multipart */ class USequencesKt {

			/* part */ class USequencesKt___USequencesKt
		}
	}

	package kotlin.system

	package kotlin.text {

		/* multipart */ class CharsKt {

			/* part */ class CharsKt__CharJVMKt
			/* part */ class CharsKt__CharKt
		}

		/* multipart */ class StringsKt {

			/* part */ class StringsKt__AppendableKt
			/* part */ class StringsKt__IndentKt
			/* part */ class StringsKt__RegexExtensionsJVMKt
			/* part */ class StringsKt__RegexExtensionsKt
			/* part */ class StringsKt__StringBuilderJVMKt
			/* part */ class StringsKt__StringBuilderKt
			/* part */ class StringsKt__StringNumberConversionsJVMKt
			/* part */ class StringsKt__StringNumberConversionsKt
			/* part */ class StringsKt__StringsJVMKt
			/* part */ class StringsKt__StringsKt
			/* part */ class StringsKt___StringsJvmKt
			/* part */ class StringsKt___StringsKt
		}
	}

	package kotlin.time {

		/* multipart */ class kotlin.time.DurationUnitKt {

			/* part */ class kotlin.time.DurationUnitKt__DurationUnitJvmKt
			/* part */ class kotlin.time.DurationUnitKt__DurationUnitKt
		}
	}
}

// ------------------------------------------------------------------------------------------------------

module `kotlin-stdlib-jdk7` {

	package kotlin

	package kotlin.io.path {

		/* multipart */ class kotlin.io.path.PathsKt {

			/* part */ class kotlin.io.path.PathsKt__PathReadWriteKt
			/* part */ class kotlin.io.path.PathsKt__PathRecursiveFunctionsKt
			/* part */ class kotlin.io.path.PathsKt__PathUtilsKt
		}
	}
}

// ------------------------------------------------------------------------------------------------------

module `kotlin-stdlib-jdk8` {

	package kotlin.collections

	package kotlin.jvm

	package kotlin.jvm.optionals

	package kotlin.streams

	package kotlin.text

	package kotlin.time
}

// ------------------------------------------------------------------------------------------------------

class kotlin.DeepRecursiveFunction<T, R> {

	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM field = block:Lkotlin/jvm/functions/Function3;
	internal val block: suspend DeepRecursiveScope<T, R>.(T) -> R


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = <init>(Lkotlin/jvm/functions/Function3;)V
	constructor(block: suspend DeepRecursiveScope<T, R>.(T) -> R)
}

// ------------------------------------------------------------------------------------------------------

abstract sealed class kotlin.DeepRecursiveScope<T, R> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	protected constructor()


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = callRecursive(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	abstract suspend fun callRecursive(value: T): R

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = callRecursive(Lkotlin/DeepRecursiveFunction;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	abstract suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S

	// JVM method = invoke(Lkotlin/DeepRecursiveFunction;Ljava/lang/Object;)Ljava/lang/Void;
	operator fun DeepRecursiveFunction<*, *>.invoke(value: Any?): Nothing
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: kotlin.coroutines.ContinuationKt$Continuation$1
/* local */ class kotlin.coroutines.ContinuationKt$Continuation$1 : kotlin.coroutines.Continuation<T#0> {

	// *** PROPERTIES ***

	open val context: kotlin.coroutines.CoroutineContext
		// JVM method = getContext()Lkotlin/coroutines/CoroutineContext;
		get() = /* non-default */


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = resumeWith(Ljava/lang/Object;)V
	open fun resumeWith(result: Result<T#0>)
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.DeepRecursiveScopeImpl<T, R> : DeepRecursiveScope<T, R>, kotlin.coroutines.Continuation<R> {

	// *** PROPERTIES ***

	// JVM field = cont:Lkotlin/coroutines/Continuation;
	private var cont: kotlin.coroutines.Continuation<Any?>?

	open val context: kotlin.coroutines.CoroutineContext
		// JVM method = getContext()Lkotlin/coroutines/CoroutineContext;
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM field = function:Lkotlin/jvm/functions/Function3;
	private var function: suspend DeepRecursiveScope<*, *>.(Any?) -> Any?

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = result:Ljava/lang/Object;
	private var result: Result<Any?>

	// JVM field = value:Ljava/lang/Object;
	private var value: Any?


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = <init>(Lkotlin/jvm/functions/Function3;Ljava/lang/Object;)V
	constructor(block: suspend DeepRecursiveScope<T, R>.(T) -> R, value: T)


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = callRecursive(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	open suspend fun callRecursive(value: T): R

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = crossFunctionCompletion(Lkotlin/jvm/functions/Function3;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation;
	private fun crossFunctionCompletion(currentFunction: suspend DeepRecursiveScope<*, *>.(Any?) -> Any?, cont: kotlin.coroutines.Continuation<Any?>): kotlin.coroutines.Continuation<Any?>

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = resumeWith(Ljava/lang/Object;)V
	open fun resumeWith(result: Result<R>)

	// JVM method = runCallLoop()Ljava/lang/Object;
	fun runCallLoop(): R

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = callRecursive(Lkotlin/DeepRecursiveFunction;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	open suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.InitializedLazyImpl<out T> : Lazy<out T>, Serializable /* = java.io.Serializable */ {

	// *** PROPERTIES ***

	// JVM field = value:Ljava/lang/Object;
	open val value: out T


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/Object;)V
	constructor(value: out T)


	// *** FUNCTIONS ***

	// JVM method = isInitialized()Z
	open fun isInitialized(): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.KotlinNothingValueException : RuntimeException /* = java.lang.RuntimeException */ {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	/* secondary */ constructor()

	// JVM method = <init>(Ljava/lang/String;)V
	/* secondary */ constructor(message: String?)

	// JVM method = <init>(Ljava/lang/String;Ljava/lang/Throwable;)V
	/* secondary */ constructor(message: String?, cause: Throwable?)

	// JVM method = <init>(Ljava/lang/Throwable;)V
	/* secondary */ constructor(cause: Throwable?)
}

// ------------------------------------------------------------------------------------------------------

open class kotlin.KotlinNullPointerException : NullPointerException /* = java.lang.NullPointerException */ {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	/* secondary */ constructor()

	// JVM method = <init>(Ljava/lang/String;)V
	/* secondary */ constructor(message: String?)
}

// ------------------------------------------------------------------------------------------------------

class kotlin.KotlinVersion : Comparable<KotlinVersion> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = major:I
	val major: Int

	// JVM field = minor:I
	val minor: Int

	// JVM field = patch:I
	val patch: Int

	// JVM field = version:I
	private val version: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(II)V
	/* secondary */ constructor(major: Int, minor: Int)

	// JVM method = <init>(III)V
	constructor(major: Int, minor: Int, patch: Int)


	// *** FUNCTIONS ***

	// JVM method = compareTo(Lkotlin/KotlinVersion;)I
	open operator fun compareTo(other: KotlinVersion): Int

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isAtLeast(II)Z
	fun isAtLeast(major: Int, minor: Int): Boolean

	// JVM method = isAtLeast(III)Z
	fun isAtLeast(major: Int, minor: Int, patch: Int): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String

	// JVM method = versionOf(III)I
	private fun versionOf(major: Int, minor: Int, patch: Int): Int
}

// ------------------------------------------------------------------------------------------------------

open class kotlin.NoWhenBranchMatchedException : RuntimeException /* = java.lang.RuntimeException */ {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	/* secondary */ constructor()

	// JVM method = <init>(Ljava/lang/String;)V
	/* secondary */ constructor(message: String?)

	// JVM method = <init>(Ljava/lang/String;Ljava/lang/Throwable;)V
	/* secondary */ constructor(message: String?, cause: Throwable?)

	// JVM method = <init>(Ljava/lang/Throwable;)V
	/* secondary */ constructor(cause: Throwable?)
}

// ------------------------------------------------------------------------------------------------------

class kotlin.NotImplementedError : Error /* = java.lang.Error */ {

	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;)V
	constructor(message: String /* = default */)
}

// ------------------------------------------------------------------------------------------------------

data class kotlin.Pair<out A, out B> : Serializable /* = java.io.Serializable */ {

	// *** PROPERTIES ***

	// JVM field = first:Ljava/lang/Object;
	val first: out A

	// JVM field = second:Ljava/lang/Object;
	val second: out B


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/Object;Ljava/lang/Object;)V
	constructor(first: out A, second: out B)


	// *** FUNCTIONS ***

	// JVM method = component1()Ljava/lang/Object;
	/* synthesized */ operator fun component1(): out A

	// JVM method = component2()Ljava/lang/Object;
	/* synthesized */ operator fun component2(): out B

	// JVM method = copy(Ljava/lang/Object;Ljava/lang/Object;)Lkotlin/Pair;
	/* synthesized */ fun copy(first: out A /* = default */, second: out B /* = default */): Pair<out A, out B>

	// JVM method = equals(Ljava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.Result.Failure : Serializable /* = java.io.Serializable */ {

	// *** PROPERTIES ***

	// JVM field = exception:Ljava/lang/Throwable;
	val exception: Throwable


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/Throwable;)V
	constructor(exception: Throwable)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
value class kotlin.Result<out T> : Serializable /* = java.io.Serializable */ {

	// *** NESTED TYPES ***

	companion object
	class Failure


	// *** PROPERTIES ***

	val isFailure: Boolean
		// JVM method = isFailure-impl(Ljava/lang/Object;)Z
		get() = /* non-default */

	val isSuccess: Boolean
		// JVM method = isSuccess-impl(Ljava/lang/Object;)Z
		get() = /* non-default */

	// JVM field = value:Ljava/lang/Object;
	// JVM annotation-holding method = getValue$annotations()V
	internal val value: Any?


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl(Ljava/lang/Object;)Ljava/lang/Object;
	internal constructor(value: Any?)


	// *** FUNCTIONS ***

	// JVM method = equals-impl(Ljava/lang/Object;Ljava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// JVM method = exceptionOrNull-impl(Ljava/lang/Object;)Ljava/lang/Throwable;
	fun exceptionOrNull(): Throwable?

	// JVM method = getOrNull-impl(Ljava/lang/Object;)Ljava/lang/Object;
	inline fun getOrNull(): out T?

	// JVM method = hashCode-impl(Ljava/lang/Object;)I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = toString-impl(Ljava/lang/Object;)Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.SafePublicationLazyImpl<out T> : Lazy<out T>, Serializable /* = java.io.Serializable */ {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = _value:Ljava/lang/Object;
	private var _value: Any?

	// JVM field = final:Ljava/lang/Object;
	private val final: Any

	// JVM field = initializer:Lkotlin/jvm/functions/Function0;
	private /* to this */ var initializer: (() -> out T)?

	open val value: out T
		// JVM method = getValue()Ljava/lang/Object;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/jvm/functions/Function0;)V
	constructor(initializer: () -> out T)


	// *** FUNCTIONS ***

	// JVM method = isInitialized()Z
	open fun isInitialized(): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String

	// JVM method = writeReplace()Ljava/lang/Object;
	private fun writeReplace(): Any
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.SynchronizedLazyImpl<out T> : Lazy<out T>, Serializable /* = java.io.Serializable */ {

	// *** PROPERTIES ***

	// JVM field = _value:Ljava/lang/Object;
	private var _value: Any?

	// JVM field = initializer:Lkotlin/jvm/functions/Function0;
	private /* to this */ var initializer: (() -> out T)?

	// JVM field = lock:Ljava/lang/Object;
	private val lock: Any

	open val value: out T
		// JVM method = getValue()Ljava/lang/Object;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/jvm/functions/Function0;Ljava/lang/Object;)V
	constructor(initializer: () -> out T, lock: Any? /* = default */)


	// *** FUNCTIONS ***

	// JVM method = isInitialized()Z
	open fun isInitialized(): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String

	// JVM method = writeReplace()Ljava/lang/Object;
	private fun writeReplace(): Any
}

// ------------------------------------------------------------------------------------------------------

data class kotlin.Triple<out A, out B, out C> : Serializable /* = java.io.Serializable */ {

	// *** PROPERTIES ***

	// JVM field = first:Ljava/lang/Object;
	val first: out A

	// JVM field = second:Ljava/lang/Object;
	val second: out B

	// JVM field = third:Ljava/lang/Object;
	val third: out C


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
	constructor(first: out A, second: out B, third: out C)


	// *** FUNCTIONS ***

	// JVM method = component1()Ljava/lang/Object;
	/* synthesized */ operator fun component1(): out A

	// JVM method = component2()Ljava/lang/Object;
	/* synthesized */ operator fun component2(): out B

	// JVM method = component3()Ljava/lang/Object;
	/* synthesized */ operator fun component3(): out C

	// JVM method = copy(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lkotlin/Triple;
	/* synthesized */ fun copy(first: out A /* = default */, second: out B /* = default */, third: out C /* = default */): Triple<out A, out B, out C>

	// JVM method = equals(Ljava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

open class kotlin.TypeCastException : ClassCastException /* = java.lang.ClassCastException */ {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	/* secondary */ constructor()

	// JVM method = <init>(Ljava/lang/String;)V
	/* secondary */ constructor(message: String?)
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
value class kotlin.UByte : Comparable<UByte> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = data:B
	// JVM annotation-holding method = getData$annotations()V
	internal val data: Byte


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl(B)B
	internal constructor(data: Byte)


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = and-7apg3OU(BB)B
	inline infix fun and(other: UByte): UByte

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-7apg3OU(BB)I
	open inline operator fun compareTo(other: UByte): Int

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-WZ4Q5Ns(BI)I
	inline operator fun compareTo(other: UInt): Int

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-VKZWuLQ(BJ)I
	inline operator fun compareTo(other: ULong): Int

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-xj2QHRw(BS)I
	inline operator fun compareTo(other: UShort): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = dec-w2LRezQ(B)B
	inline operator fun dec(): UByte

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-7apg3OU(BB)I
	inline operator fun div(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-WZ4Q5Ns(BI)I
	inline operator fun div(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-VKZWuLQ(BJ)J
	inline operator fun div(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-xj2QHRw(BS)I
	inline operator fun div(other: UShort): UInt

	// JVM method = equals-impl(BLjava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-7apg3OU(BB)I
	inline fun floorDiv(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-WZ4Q5Ns(BI)I
	inline fun floorDiv(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-VKZWuLQ(BJ)J
	inline fun floorDiv(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-xj2QHRw(BS)I
	inline fun floorDiv(other: UShort): UInt

	// JVM method = hashCode-impl(B)I
	/* synthesized */ open fun hashCode(): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = inc-w2LRezQ(B)B
	inline operator fun inc(): UByte

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = inv-w2LRezQ(B)B
	inline fun inv(): UByte

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-7apg3OU(BB)I
	inline operator fun minus(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-WZ4Q5Ns(BI)I
	inline operator fun minus(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-VKZWuLQ(BJ)J
	inline operator fun minus(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-xj2QHRw(BS)I
	inline operator fun minus(other: UShort): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-7apg3OU(BB)B
	inline fun mod(other: UByte): UByte

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-WZ4Q5Ns(BI)I
	inline fun mod(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-VKZWuLQ(BJ)J
	inline fun mod(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-xj2QHRw(BS)S
	inline fun mod(other: UShort): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = or-7apg3OU(BB)B
	inline infix fun or(other: UByte): UByte

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-7apg3OU(BB)I
	inline operator fun plus(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-WZ4Q5Ns(BI)I
	inline operator fun plus(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-VKZWuLQ(BJ)J
	inline operator fun plus(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-xj2QHRw(BS)I
	inline operator fun plus(other: UShort): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rangeTo-7apg3OU(BB)Lkotlin/ranges/UIntRange;
	inline operator fun rangeTo(other: UByte): UIntRange

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rangeUntil-7apg3OU(BB)Lkotlin/ranges/UIntRange;
	inline operator fun rangeUntil(other: UByte): UIntRange

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-7apg3OU(BB)I
	inline operator fun rem(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-WZ4Q5Ns(BI)I
	inline operator fun rem(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-VKZWuLQ(BJ)J
	inline operator fun rem(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-xj2QHRw(BS)I
	inline operator fun rem(other: UShort): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-7apg3OU(BB)I
	inline operator fun times(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-WZ4Q5Ns(BI)I
	inline operator fun times(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-VKZWuLQ(BJ)J
	inline operator fun times(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-xj2QHRw(BS)I
	inline operator fun times(other: UShort): UInt

	// JVM method = toByte-impl(B)B
	inline fun toByte(): Byte

	// JVM method = toDouble-impl(B)D
	inline fun toDouble(): Double

	// JVM method = toFloat-impl(B)F
	inline fun toFloat(): Float

	// JVM method = toInt-impl(B)I
	inline fun toInt(): Int

	// JVM method = toLong-impl(B)J
	inline fun toLong(): Long

	// JVM method = toShort-impl(B)S
	inline fun toShort(): Short

	// JVM method = toString-impl(B)Ljava/lang/String;
	open fun toString(): String

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toUByte-w2LRezQ(B)B
	inline fun toUByte(): UByte

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toUInt-pVg5ArA(B)I
	inline fun toUInt(): UInt

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toULong-s-VKNKU(B)J
	inline fun toULong(): ULong

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toUShort-Mh2AYeg(B)S
	inline fun toUShort(): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = xor-7apg3OU(BB)B
	inline infix fun xor(other: UByte): UByte
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
private class kotlin.UByteArray.Iterator : Iterator<UByte> {

	// *** PROPERTIES ***

	// JVM field = array:[B
	private val array: ByteArray

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([B)V
	constructor(array: ByteArray)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = next-w2LRezQ()B
	open operator fun next(): UByte
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
value class kotlin.UByteArray : Collection<UByte> {

	// *** NESTED TYPES ***

	class Iterator


	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize-impl([B)I
		get() = /* non-default */

	// JVM field = storage:[B
	// JVM annotation-holding method = getStorage$annotations()V
	internal val storage: ByteArray


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl(I)[B
	/* secondary */ constructor(size: Int)

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl([B)[B
	internal constructor(storage: ByteArray)


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = contains-7apg3OU([BB)Z
	open operator fun contains(element: UByte): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = containsAll-impl([BLjava/util/Collection;)Z
	open fun containsAll(elements: Collection<UByte>): Boolean

	// JVM method = equals-impl([BLjava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = get-w2LRezQ([BI)B
	operator fun get(index: Int): UByte

	// JVM method = hashCode-impl([B)I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = isEmpty-impl([B)Z
	open fun isEmpty(): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = iterator-impl([B)Ljava/util/Iterator;
	open operator fun iterator(): Iterator<UByte>

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = set-VurrAj0([BIB)V
	operator fun set(index: Int, value: UByte)

	// JVM method = toString-impl([B)Ljava/lang/String;
	/* synthesized */ open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
value class kotlin.UInt : Comparable<UInt> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = data:I
	// JVM annotation-holding method = getData$annotations()V
	internal val data: Int


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl(I)I
	internal constructor(data: Int)


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = and-WZ4Q5Ns(II)I
	inline infix fun and(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-7apg3OU(IB)I
	inline operator fun compareTo(other: UByte): Int

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-WZ4Q5Ns(II)I
	open inline operator fun compareTo(other: UInt): Int

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-VKZWuLQ(IJ)I
	inline operator fun compareTo(other: ULong): Int

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-xj2QHRw(IS)I
	inline operator fun compareTo(other: UShort): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = dec-pVg5ArA(I)I
	inline operator fun dec(): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-7apg3OU(IB)I
	inline operator fun div(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-WZ4Q5Ns(II)I
	inline operator fun div(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-VKZWuLQ(IJ)J
	inline operator fun div(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-xj2QHRw(IS)I
	inline operator fun div(other: UShort): UInt

	// JVM method = equals-impl(ILjava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-7apg3OU(IB)I
	inline fun floorDiv(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-WZ4Q5Ns(II)I
	inline fun floorDiv(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-VKZWuLQ(IJ)J
	inline fun floorDiv(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-xj2QHRw(IS)I
	inline fun floorDiv(other: UShort): UInt

	// JVM method = hashCode-impl(I)I
	/* synthesized */ open fun hashCode(): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = inc-pVg5ArA(I)I
	inline operator fun inc(): UInt

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = inv-pVg5ArA(I)I
	inline fun inv(): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-7apg3OU(IB)I
	inline operator fun minus(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-WZ4Q5Ns(II)I
	inline operator fun minus(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-VKZWuLQ(IJ)J
	inline operator fun minus(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-xj2QHRw(IS)I
	inline operator fun minus(other: UShort): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-7apg3OU(IB)B
	inline fun mod(other: UByte): UByte

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-WZ4Q5Ns(II)I
	inline fun mod(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-VKZWuLQ(IJ)J
	inline fun mod(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-xj2QHRw(IS)S
	inline fun mod(other: UShort): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = or-WZ4Q5Ns(II)I
	inline infix fun or(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-7apg3OU(IB)I
	inline operator fun plus(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-WZ4Q5Ns(II)I
	inline operator fun plus(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-VKZWuLQ(IJ)J
	inline operator fun plus(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-xj2QHRw(IS)I
	inline operator fun plus(other: UShort): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rangeTo-WZ4Q5Ns(II)Lkotlin/ranges/UIntRange;
	inline operator fun rangeTo(other: UInt): UIntRange

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rangeUntil-WZ4Q5Ns(II)Lkotlin/ranges/UIntRange;
	inline operator fun rangeUntil(other: UInt): UIntRange

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-7apg3OU(IB)I
	inline operator fun rem(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-WZ4Q5Ns(II)I
	inline operator fun rem(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-VKZWuLQ(IJ)J
	inline operator fun rem(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-xj2QHRw(IS)I
	inline operator fun rem(other: UShort): UInt

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = shl-pVg5ArA(II)I
	inline infix fun shl(bitCount: Int): UInt

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = shr-pVg5ArA(II)I
	inline infix fun shr(bitCount: Int): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-7apg3OU(IB)I
	inline operator fun times(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-WZ4Q5Ns(II)I
	inline operator fun times(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-VKZWuLQ(IJ)J
	inline operator fun times(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-xj2QHRw(IS)I
	inline operator fun times(other: UShort): UInt

	// JVM method = toByte-impl(I)B
	inline fun toByte(): Byte

	// JVM method = toDouble-impl(I)D
	inline fun toDouble(): Double

	// JVM method = toFloat-impl(I)F
	inline fun toFloat(): Float

	// JVM method = toInt-impl(I)I
	inline fun toInt(): Int

	// JVM method = toLong-impl(I)J
	inline fun toLong(): Long

	// JVM method = toShort-impl(I)S
	inline fun toShort(): Short

	// JVM method = toString-impl(I)Ljava/lang/String;
	open fun toString(): String

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toUByte-w2LRezQ(I)B
	inline fun toUByte(): UByte

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toUInt-pVg5ArA(I)I
	inline fun toUInt(): UInt

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toULong-s-VKNKU(I)J
	inline fun toULong(): ULong

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toUShort-Mh2AYeg(I)S
	inline fun toUShort(): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = xor-WZ4Q5Ns(II)I
	inline infix fun xor(other: UInt): UInt
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
private class kotlin.UIntArray.Iterator : Iterator<UInt> {

	// *** PROPERTIES ***

	// JVM field = array:[I
	private val array: IntArray

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([I)V
	constructor(array: IntArray)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = next-pVg5ArA()I
	open operator fun next(): UInt
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
value class kotlin.UIntArray : Collection<UInt> {

	// *** NESTED TYPES ***

	class Iterator


	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize-impl([I)I
		get() = /* non-default */

	// JVM field = storage:[I
	// JVM annotation-holding method = getStorage$annotations()V
	internal val storage: IntArray


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl(I)[I
	/* secondary */ constructor(size: Int)

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl([I)[I
	internal constructor(storage: IntArray)


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = contains-WZ4Q5Ns([II)Z
	open operator fun contains(element: UInt): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = containsAll-impl([ILjava/util/Collection;)Z
	open fun containsAll(elements: Collection<UInt>): Boolean

	// JVM method = equals-impl([ILjava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = get-pVg5ArA([II)I
	operator fun get(index: Int): UInt

	// JVM method = hashCode-impl([I)I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = isEmpty-impl([I)Z
	open fun isEmpty(): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = iterator-impl([I)Ljava/util/Iterator;
	open operator fun iterator(): Iterator<UInt>

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = set-VXSXFK8([III)V
	operator fun set(index: Int, value: UInt)

	// JVM method = toString-impl([I)Ljava/lang/String;
	/* synthesized */ open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
value class kotlin.ULong : Comparable<ULong> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = data:J
	// JVM annotation-holding method = getData$annotations()V
	internal val data: Long


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl(J)J
	internal constructor(data: Long)


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = and-VKZWuLQ(JJ)J
	inline infix fun and(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-7apg3OU(JB)I
	inline operator fun compareTo(other: UByte): Int

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-WZ4Q5Ns(JI)I
	inline operator fun compareTo(other: UInt): Int

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-VKZWuLQ(JJ)I
	open inline operator fun compareTo(other: ULong): Int

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-xj2QHRw(JS)I
	inline operator fun compareTo(other: UShort): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = dec-s-VKNKU(J)J
	inline operator fun dec(): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-7apg3OU(JB)J
	inline operator fun div(other: UByte): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-WZ4Q5Ns(JI)J
	inline operator fun div(other: UInt): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-VKZWuLQ(JJ)J
	inline operator fun div(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-xj2QHRw(JS)J
	inline operator fun div(other: UShort): ULong

	// JVM method = equals-impl(JLjava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-7apg3OU(JB)J
	inline fun floorDiv(other: UByte): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-WZ4Q5Ns(JI)J
	inline fun floorDiv(other: UInt): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-VKZWuLQ(JJ)J
	inline fun floorDiv(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-xj2QHRw(JS)J
	inline fun floorDiv(other: UShort): ULong

	// JVM method = hashCode-impl(J)I
	/* synthesized */ open fun hashCode(): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = inc-s-VKNKU(J)J
	inline operator fun inc(): ULong

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = inv-s-VKNKU(J)J
	inline fun inv(): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-7apg3OU(JB)J
	inline operator fun minus(other: UByte): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-WZ4Q5Ns(JI)J
	inline operator fun minus(other: UInt): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-VKZWuLQ(JJ)J
	inline operator fun minus(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-xj2QHRw(JS)J
	inline operator fun minus(other: UShort): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-7apg3OU(JB)B
	inline fun mod(other: UByte): UByte

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-WZ4Q5Ns(JI)I
	inline fun mod(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-VKZWuLQ(JJ)J
	inline fun mod(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-xj2QHRw(JS)S
	inline fun mod(other: UShort): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = or-VKZWuLQ(JJ)J
	inline infix fun or(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-7apg3OU(JB)J
	inline operator fun plus(other: UByte): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-WZ4Q5Ns(JI)J
	inline operator fun plus(other: UInt): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-VKZWuLQ(JJ)J
	inline operator fun plus(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-xj2QHRw(JS)J
	inline operator fun plus(other: UShort): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rangeTo-VKZWuLQ(JJ)Lkotlin/ranges/ULongRange;
	inline operator fun rangeTo(other: ULong): ULongRange

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rangeUntil-VKZWuLQ(JJ)Lkotlin/ranges/ULongRange;
	inline operator fun rangeUntil(other: ULong): ULongRange

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-7apg3OU(JB)J
	inline operator fun rem(other: UByte): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-WZ4Q5Ns(JI)J
	inline operator fun rem(other: UInt): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-VKZWuLQ(JJ)J
	inline operator fun rem(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-xj2QHRw(JS)J
	inline operator fun rem(other: UShort): ULong

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = shl-s-VKNKU(JI)J
	inline infix fun shl(bitCount: Int): ULong

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = shr-s-VKNKU(JI)J
	inline infix fun shr(bitCount: Int): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-7apg3OU(JB)J
	inline operator fun times(other: UByte): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-WZ4Q5Ns(JI)J
	inline operator fun times(other: UInt): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-VKZWuLQ(JJ)J
	inline operator fun times(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-xj2QHRw(JS)J
	inline operator fun times(other: UShort): ULong

	// JVM method = toByte-impl(J)B
	inline fun toByte(): Byte

	// JVM method = toDouble-impl(J)D
	inline fun toDouble(): Double

	// JVM method = toFloat-impl(J)F
	inline fun toFloat(): Float

	// JVM method = toInt-impl(J)I
	inline fun toInt(): Int

	// JVM method = toLong-impl(J)J
	inline fun toLong(): Long

	// JVM method = toShort-impl(J)S
	inline fun toShort(): Short

	// JVM method = toString-impl(J)Ljava/lang/String;
	open fun toString(): String

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toUByte-w2LRezQ(J)B
	inline fun toUByte(): UByte

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toUInt-pVg5ArA(J)I
	inline fun toUInt(): UInt

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toULong-s-VKNKU(J)J
	inline fun toULong(): ULong

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toUShort-Mh2AYeg(J)S
	inline fun toUShort(): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = xor-VKZWuLQ(JJ)J
	inline infix fun xor(other: ULong): ULong
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
private class kotlin.ULongArray.Iterator : Iterator<ULong> {

	// *** PROPERTIES ***

	// JVM field = array:[J
	private val array: LongArray

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([J)V
	constructor(array: LongArray)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = next-s-VKNKU()J
	open operator fun next(): ULong
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
value class kotlin.ULongArray : Collection<ULong> {

	// *** NESTED TYPES ***

	class Iterator


	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize-impl([J)I
		get() = /* non-default */

	// JVM field = storage:[J
	// JVM annotation-holding method = getStorage$annotations()V
	internal val storage: LongArray


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl(I)[J
	/* secondary */ constructor(size: Int)

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl([J)[J
	internal constructor(storage: LongArray)


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = contains-VKZWuLQ([JJ)Z
	open operator fun contains(element: ULong): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = containsAll-impl([JLjava/util/Collection;)Z
	open fun containsAll(elements: Collection<ULong>): Boolean

	// JVM method = equals-impl([JLjava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = get-s-VKNKU([JI)J
	operator fun get(index: Int): ULong

	// JVM method = hashCode-impl([J)I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = isEmpty-impl([J)Z
	open fun isEmpty(): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = iterator-impl([J)Ljava/util/Iterator;
	open operator fun iterator(): Iterator<ULong>

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = set-k8EXiF4([JIJ)V
	operator fun set(index: Int, value: ULong)

	// JVM method = toString-impl([J)Ljava/lang/String;
	/* synthesized */ open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
value class kotlin.UShort : Comparable<UShort> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = data:S
	// JVM annotation-holding method = getData$annotations()V
	internal val data: Short


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl(S)S
	internal constructor(data: Short)


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = and-xj2QHRw(SS)S
	inline infix fun and(other: UShort): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-7apg3OU(SB)I
	inline operator fun compareTo(other: UByte): Int

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-WZ4Q5Ns(SI)I
	inline operator fun compareTo(other: UInt): Int

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-VKZWuLQ(SJ)I
	inline operator fun compareTo(other: ULong): Int

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-xj2QHRw(SS)I
	open inline operator fun compareTo(other: UShort): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = dec-Mh2AYeg(S)S
	inline operator fun dec(): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-7apg3OU(SB)I
	inline operator fun div(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-WZ4Q5Ns(SI)I
	inline operator fun div(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-VKZWuLQ(SJ)J
	inline operator fun div(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-xj2QHRw(SS)I
	inline operator fun div(other: UShort): UInt

	// JVM method = equals-impl(SLjava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-7apg3OU(SB)I
	inline fun floorDiv(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-WZ4Q5Ns(SI)I
	inline fun floorDiv(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-VKZWuLQ(SJ)J
	inline fun floorDiv(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = floorDiv-xj2QHRw(SS)I
	inline fun floorDiv(other: UShort): UInt

	// JVM method = hashCode-impl(S)I
	/* synthesized */ open fun hashCode(): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = inc-Mh2AYeg(S)S
	inline operator fun inc(): UShort

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = inv-Mh2AYeg(S)S
	inline fun inv(): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-7apg3OU(SB)I
	inline operator fun minus(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-WZ4Q5Ns(SI)I
	inline operator fun minus(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-VKZWuLQ(SJ)J
	inline operator fun minus(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-xj2QHRw(SS)I
	inline operator fun minus(other: UShort): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-7apg3OU(SB)B
	inline fun mod(other: UByte): UByte

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-WZ4Q5Ns(SI)I
	inline fun mod(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-VKZWuLQ(SJ)J
	inline fun mod(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = mod-xj2QHRw(SS)S
	inline fun mod(other: UShort): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = or-xj2QHRw(SS)S
	inline infix fun or(other: UShort): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-7apg3OU(SB)I
	inline operator fun plus(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-WZ4Q5Ns(SI)I
	inline operator fun plus(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-VKZWuLQ(SJ)J
	inline operator fun plus(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-xj2QHRw(SS)I
	inline operator fun plus(other: UShort): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rangeTo-xj2QHRw(SS)Lkotlin/ranges/UIntRange;
	inline operator fun rangeTo(other: UShort): UIntRange

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rangeUntil-xj2QHRw(SS)Lkotlin/ranges/UIntRange;
	inline operator fun rangeUntil(other: UShort): UIntRange

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-7apg3OU(SB)I
	inline operator fun rem(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-WZ4Q5Ns(SI)I
	inline operator fun rem(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-VKZWuLQ(SJ)J
	inline operator fun rem(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = rem-xj2QHRw(SS)I
	inline operator fun rem(other: UShort): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-7apg3OU(SB)I
	inline operator fun times(other: UByte): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-WZ4Q5Ns(SI)I
	inline operator fun times(other: UInt): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-VKZWuLQ(SJ)J
	inline operator fun times(other: ULong): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-xj2QHRw(SS)I
	inline operator fun times(other: UShort): UInt

	// JVM method = toByte-impl(S)B
	inline fun toByte(): Byte

	// JVM method = toDouble-impl(S)D
	inline fun toDouble(): Double

	// JVM method = toFloat-impl(S)F
	inline fun toFloat(): Float

	// JVM method = toInt-impl(S)I
	inline fun toInt(): Int

	// JVM method = toLong-impl(S)J
	inline fun toLong(): Long

	// JVM method = toShort-impl(S)S
	inline fun toShort(): Short

	// JVM method = toString-impl(S)Ljava/lang/String;
	open fun toString(): String

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toUByte-w2LRezQ(S)B
	inline fun toUByte(): UByte

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toUInt-pVg5ArA(S)I
	inline fun toUInt(): UInt

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toULong-s-VKNKU(S)J
	inline fun toULong(): ULong

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = toUShort-Mh2AYeg(S)S
	inline fun toUShort(): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = xor-xj2QHRw(SS)S
	inline infix fun xor(other: UShort): UShort
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
private class kotlin.UShortArray.Iterator : Iterator<UShort> {

	// *** PROPERTIES ***

	// JVM field = array:[S
	private val array: ShortArray

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([S)V
	constructor(array: ShortArray)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = next-Mh2AYeg()S
	open operator fun next(): UShort
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
value class kotlin.UShortArray : Collection<UShort> {

	// *** NESTED TYPES ***

	class Iterator


	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize-impl([S)I
		get() = /* non-default */

	// JVM field = storage:[S
	// JVM annotation-holding method = getStorage$annotations()V
	internal val storage: ShortArray


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl(I)[S
	/* secondary */ constructor(size: Int)

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl([S)[S
	internal constructor(storage: ShortArray)


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = contains-xj2QHRw([SS)Z
	open operator fun contains(element: UShort): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = containsAll-impl([SLjava/util/Collection;)Z
	open fun containsAll(elements: Collection<UShort>): Boolean

	// JVM method = equals-impl([SLjava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = get-Mh2AYeg([SI)S
	operator fun get(index: Int): UShort

	// JVM method = hashCode-impl([S)I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = isEmpty-impl([S)Z
	open fun isEmpty(): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = iterator-impl([S)Ljava/util/Iterator;
	open operator fun iterator(): Iterator<UShort>

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = set-01HTLdE([SIS)V
	operator fun set(index: Int, value: UShort)

	// JVM method = toString-impl([S)Ljava/lang/String;
	/* synthesized */ open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

class kotlin.UninitializedPropertyAccessException : RuntimeException /* = java.lang.RuntimeException */ {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	/* secondary */ constructor()

	// JVM method = <init>(Ljava/lang/String;)V
	/* secondary */ constructor(message: String?)

	// JVM method = <init>(Ljava/lang/String;Ljava/lang/Throwable;)V
	/* secondary */ constructor(message: String?, cause: Throwable?)

	// JVM method = <init>(Ljava/lang/Throwable;)V
	/* secondary */ constructor(cause: Throwable?)
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.UnsafeLazyImpl<out T> : Lazy<out T>, Serializable /* = java.io.Serializable */ {

	// *** PROPERTIES ***

	// JVM field = _value:Ljava/lang/Object;
	private var _value: Any?

	// JVM field = initializer:Lkotlin/jvm/functions/Function0;
	private /* to this */ var initializer: (() -> out T)?

	open val value: out T
		// JVM method = getValue()Ljava/lang/Object;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/jvm/functions/Function0;)V
	constructor(initializer: () -> out T)


	// *** FUNCTIONS ***

	// JVM method = isInitialized()Z
	open fun isInitialized(): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String

	// JVM method = writeReplace()Ljava/lang/Object;
	private fun writeReplace(): Any
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.AbstractCollection<out E> : Collection<out E> {

	// *** PROPERTIES ***

	abstract val size: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	protected constructor()


	// *** FUNCTIONS ***

	// JVM method = contains(Ljava/lang/Object;)Z
	open operator fun contains(element: out E): Boolean

	// JVM method = containsAll(Ljava/util/Collection;)Z
	open fun containsAll(elements: Collection<out E>): Boolean

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	abstract operator fun iterator(): Iterator<out E>

	// JVM method = toArray()[Ljava/lang/Object;
	protected open fun toArray(): Array<Any?>

	// JVM method = toArray([Ljava/lang/Object;)[Ljava/lang/Object;
	protected open fun <T> toArray(array: Array<T>): Array<T>

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.AbstractIterator<T> : Iterator<T> {

	// *** PROPERTIES ***

	// JVM field = nextValue:Ljava/lang/Object;
	private var nextValue: T?

	// JVM field = state:Lkotlin/collections/State;
	private var state: State


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = computeNext()V
	protected abstract fun computeNext()

	// JVM method = done()V
	protected fun done()

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T

	// JVM method = setNext(Ljava/lang/Object;)V
	protected fun setNext(value: T)

	// JVM method = tryToComputeNext()Z
	private fun tryToComputeNext(): Boolean
}

// ------------------------------------------------------------------------------------------------------

private open inner class kotlin.collections.AbstractList.IteratorImpl : Iterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = index:I
	protected var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/collections/AbstractList;)V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

private open inner class kotlin.collections.AbstractList.ListIteratorImpl : AbstractList<T#0>.AbstractList.IteratorImpl, ListIterator<T#0> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/collections/AbstractList;I)V
	constructor(index: Int)


	// *** FUNCTIONS ***

	// JVM method = hasPrevious()Z
	open fun hasPrevious(): Boolean

	// JVM method = nextIndex()I
	open fun nextIndex(): Int

	// JVM method = previous()Ljava/lang/Object;
	open fun previous(): T#0

	// JVM method = previousIndex()I
	open fun previousIndex(): Int
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.collections.AbstractList.SubList<out E> : AbstractList<out E>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	// JVM field = _size:I
	private var _size: Int

	// JVM field = fromIndex:I
	private val fromIndex: Int

	// JVM field = list:Lkotlin/collections/AbstractList;
	private val list: AbstractList<out E>

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/collections/AbstractList;II)V
	constructor(list: AbstractList<out E>, fromIndex: Int, toIndex: Int)


	// *** FUNCTIONS ***

	// JVM method = get(I)Ljava/lang/Object;
	open operator fun get(index: Int): out E
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.AbstractList<out E> : AbstractCollection<out E>, List<out E> {

	// *** NESTED TYPES ***

	companion object
	class IteratorImpl
	class ListIteratorImpl
	class SubList


	// *** PROPERTIES ***

	abstract val size: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	protected constructor()


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = get(I)Ljava/lang/Object;
	abstract operator fun get(index: Int): out E

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = indexOf(Ljava/lang/Object;)I
	open fun indexOf(element: out E): Int

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<out E>

	// JVM method = lastIndexOf(Ljava/lang/Object;)I
	open fun lastIndexOf(element: out E): Int

	// JVM method = listIterator()Ljava/util/ListIterator;
	open fun listIterator(): ListIterator<out E>

	// JVM method = listIterator(I)Ljava/util/ListIterator;
	open fun listIterator(index: Int): ListIterator<out E>

	// JVM method = subList(II)Ljava/util/List;
	open fun subList(fromIndex: Int, toIndex: Int): List<out E>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.AbstractMap$keys$1$iterator$1 : Iterator<T#0> {

	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.AbstractMap$keys$1 : AbstractSet<T#0> {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// JVM method = contains(Ljava/lang/Object;)Z
	open operator fun contains(element: T#0): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.AbstractMap$values$1$iterator$1 : Iterator<T#0> {

	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.AbstractMap$values$1 : AbstractCollection<T#0> {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// JVM method = contains(Ljava/lang/Object;)Z
	open operator fun contains(element: T#0): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.AbstractMap<K, out V> : Map<K, out V> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = _keys:Ljava/util/Set;
	private var _keys: Set<K>?

	// JVM field = _values:Ljava/util/Collection;
	private /* to this */ var _values: Collection<out V>?

	open val keys: Set<K>
		// JVM method = getKeys()Ljava/util/Set;
		get() = /* non-default */

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */

	open val values: Collection<out V>
		// JVM method = getValues()Ljava/util/Collection;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	protected constructor()


	// *** FUNCTIONS ***

	// JVM method = containsEntry$kotlin_stdlib(Ljava/util/Map$Entry;)Z
	internal fun containsEntry(entry: Map.Entry<*, *>?): Boolean

	// JVM method = containsKey(Ljava/lang/Object;)Z
	open fun containsKey(key: K): Boolean

	// JVM method = containsValue(Ljava/lang/Object;)Z
	open fun containsValue(value: out V): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = get(Ljava/lang/Object;)Ljava/lang/Object;
	open operator fun get(key: K): out V?

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = implFindEntry(Ljava/lang/Object;)Ljava/util/Map$Entry;
	private fun implFindEntry(key: K): Map.Entry<K, out V>?

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String

	// JVM method = toString(Ljava/lang/Object;)Ljava/lang/String;
	private fun toString(o: Any?): String

	// JVM method = toString(Ljava/util/Map$Entry;)Ljava/lang/String;
	private /* to this */ fun toString(entry: Map.Entry<K, out V>): String
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.AbstractMutableCollection<E> : MutableCollection<E>, java.util.AbstractCollection<E> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	protected constructor()


	// *** FUNCTIONS ***

	// JVM method = add(Ljava/lang/Object;)Z
	abstract fun add(element: E): Boolean
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.AbstractMutableList<E> : MutableList<E>, java.util.AbstractList<E> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	protected constructor()


	// *** FUNCTIONS ***

	// JVM method = add(ILjava/lang/Object;)V
	abstract fun add(index: Int, element: E)

	// JVM method = removeAt(I)Ljava/lang/Object;
	abstract fun removeAt(index: Int): E

	// JVM method = set(ILjava/lang/Object;)Ljava/lang/Object;
	abstract operator fun set(index: Int, element: E): E
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.AbstractMutableMap<K, V> : MutableMap<K, V>, java.util.AbstractMap<K, V> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	protected constructor()


	// *** FUNCTIONS ***

	// JVM method = put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract fun put(key: K, value: V): V?
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.AbstractMutableSet<E> : MutableSet<E>, java.util.AbstractSet<E> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	protected constructor()


	// *** FUNCTIONS ***

	// JVM method = add(Ljava/lang/Object;)Z
	abstract fun add(element: E): Boolean
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.AbstractSet<out E> : AbstractCollection<out E>, Set<out E> {

	// *** NESTED TYPES ***

	companion object


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	protected constructor()


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.collections.ArrayAsCollection<T> : Collection<T> {

	// *** PROPERTIES ***

	// JVM field = isVarargs:Z
	val isVarargs: Boolean

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */

	// JVM field = values:[Ljava/lang/Object;
	val values: Array<out T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>([Ljava/lang/Object;Z)V
	constructor(values: Array<out T>, isVarargs: Boolean)


	// *** FUNCTIONS ***

	// JVM method = contains(Ljava/lang/Object;)Z
	open operator fun contains(element: T): Boolean

	// JVM method = containsAll(Ljava/util/Collection;)Z
	open fun containsAll(elements: Collection<T>): Boolean

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T>

	// JVM method = toArray()[Ljava/lang/Object;
	fun toArray(): Array<out Any?>
}

// ------------------------------------------------------------------------------------------------------

class kotlin.collections.ArrayDeque<E> : AbstractMutableList<E> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = elementData:[Ljava/lang/Object;
	private var elementData: Array<Any?>

	// JVM field = head:I
	private var head: Int

	// JVM field = size:I
	open var size: Int
		private set(`<set-?>`: Int) { /* non-default */ }


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	/* secondary */ constructor(initialCapacity: Int)

	// JVM method = <init>()V
	/* secondary */ constructor()

	// JVM method = <init>(Ljava/util/Collection;)V
	/* secondary */ constructor(elements: Collection<E>)


	// *** FUNCTIONS ***

	// JVM method = add(Ljava/lang/Object;)Z
	open fun add(element: E): Boolean

	// JVM method = add(ILjava/lang/Object;)V
	open fun add(index: Int, element: E)

	// JVM method = addAll(ILjava/util/Collection;)Z
	open fun addAll(index: Int, elements: Collection<E>): Boolean

	// JVM method = addAll(Ljava/util/Collection;)Z
	open fun addAll(elements: Collection<E>): Boolean

	// JVM method = addFirst(Ljava/lang/Object;)V
	fun addFirst(element: E)

	// JVM method = addLast(Ljava/lang/Object;)V
	fun addLast(element: E)

	// JVM method = clear()V
	open fun clear()

	// JVM method = contains(Ljava/lang/Object;)Z
	open operator fun contains(element: E): Boolean

	// JVM method = copyCollectionElements(ILjava/util/Collection;)V
	private fun copyCollectionElements(internalIndex: Int, elements: Collection<E>)

	// JVM method = copyElements(I)V
	private fun copyElements(newCapacity: Int)

	// JVM method = decremented(I)I
	private fun decremented(index: Int): Int

	// JVM method = ensureCapacity(I)V
	private fun ensureCapacity(minCapacity: Int)

	// JVM method = filterInPlace(Lkotlin/jvm/functions/Function1;)Z
	private inline fun filterInPlace(predicate: (E) -> Boolean): Boolean

	// JVM method = first()Ljava/lang/Object;
	fun first(): E

	// JVM method = firstOrNull()Ljava/lang/Object;
	fun firstOrNull(): E?

	// JVM method = get(I)Ljava/lang/Object;
	open operator fun get(index: Int): E

	// JVM method = incremented(I)I
	private fun incremented(index: Int): Int

	// JVM method = indexOf(Ljava/lang/Object;)I
	open fun indexOf(element: E): Int

	// JVM method = internalGet(I)Ljava/lang/Object;
	private inline fun internalGet(internalIndex: Int): E

	// JVM method = internalIndex(I)I
	private inline fun internalIndex(index: Int): Int

	// JVM method = internalStructure$kotlin_stdlib(Lkotlin/jvm/functions/Function2;)V
	internal fun internalStructure(structure: (@ParameterName(name = "head") Int, @ParameterName(name = "elements") Array<Any?>) -> Unit)

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = last()Ljava/lang/Object;
	fun last(): E

	// JVM method = lastIndexOf(Ljava/lang/Object;)I
	open fun lastIndexOf(element: E): Int

	// JVM method = lastOrNull()Ljava/lang/Object;
	fun lastOrNull(): E?

	// JVM method = negativeMod(I)I
	private fun negativeMod(index: Int): Int

	// JVM method = positiveMod(I)I
	private fun positiveMod(index: Int): Int

	// JVM method = remove(Ljava/lang/Object;)Z
	open fun remove(element: E): Boolean

	// JVM method = removeAll(Ljava/util/Collection;)Z
	open fun removeAll(elements: Collection<E>): Boolean

	// JVM method = removeAt(I)Ljava/lang/Object;
	open fun removeAt(index: Int): E

	// JVM method = removeFirst()Ljava/lang/Object;
	fun removeFirst(): E

	// JVM method = removeFirstOrNull()Ljava/lang/Object;
	fun removeFirstOrNull(): E?

	// JVM method = removeLast()Ljava/lang/Object;
	fun removeLast(): E

	// JVM method = removeLastOrNull()Ljava/lang/Object;
	fun removeLastOrNull(): E?

	// JVM method = retainAll(Ljava/util/Collection;)Z
	open fun retainAll(elements: Collection<E>): Boolean

	// JVM method = set(ILjava/lang/Object;)Ljava/lang/Object;
	open operator fun set(index: Int, element: E): E

	// JVM method = testToArray$kotlin_stdlib()[Ljava/lang/Object;
	internal fun testToArray(): Array<Any?>

	// JVM method = testToArray$kotlin_stdlib([Ljava/lang/Object;)[Ljava/lang/Object;
	internal fun <T> testToArray(array: Array<T>): Array<T>

	// JVM method = toArray()[Ljava/lang/Object;
	open fun toArray(): Array<Any?>

	// JVM method = toArray([Ljava/lang/Object;)[Ljava/lang/Object;
	open fun <T> toArray(array: Array<T>): Array<T>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.ArraysKt___ArraysJvmKt$asList$1 : AbstractList<Byte>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// JVM method = contains(B)Z
	open operator fun contains(element: Byte): Boolean

	// JVM method = get(I)Ljava/lang/Byte;
	open operator fun get(index: Int): Byte

	// JVM method = indexOf(B)I
	open fun indexOf(element: Byte): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lastIndexOf(B)I
	open fun lastIndexOf(element: Byte): Int
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.ArraysKt___ArraysJvmKt$asList$2 : AbstractList<Short>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// JVM method = contains(S)Z
	open operator fun contains(element: Short): Boolean

	// JVM method = get(I)Ljava/lang/Short;
	open operator fun get(index: Int): Short

	// JVM method = indexOf(S)I
	open fun indexOf(element: Short): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lastIndexOf(S)I
	open fun lastIndexOf(element: Short): Int
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.ArraysKt___ArraysJvmKt$asList$3 : AbstractList<Int>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// JVM method = contains(I)Z
	open operator fun contains(element: Int): Boolean

	// JVM method = get(I)Ljava/lang/Integer;
	open operator fun get(index: Int): Int

	// JVM method = indexOf(I)I
	open fun indexOf(element: Int): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lastIndexOf(I)I
	open fun lastIndexOf(element: Int): Int
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.ArraysKt___ArraysJvmKt$asList$4 : AbstractList<Long>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// JVM method = contains(J)Z
	open operator fun contains(element: Long): Boolean

	// JVM method = get(I)Ljava/lang/Long;
	open operator fun get(index: Int): Long

	// JVM method = indexOf(J)I
	open fun indexOf(element: Long): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lastIndexOf(J)I
	open fun lastIndexOf(element: Long): Int
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.ArraysKt___ArraysJvmKt$asList$5 : AbstractList<Float>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// JVM method = contains(F)Z
	open operator fun contains(element: Float): Boolean

	// JVM method = get(I)Ljava/lang/Float;
	open operator fun get(index: Int): Float

	// JVM method = indexOf(F)I
	open fun indexOf(element: Float): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lastIndexOf(F)I
	open fun lastIndexOf(element: Float): Int
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.ArraysKt___ArraysJvmKt$asList$6 : AbstractList<Double>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// JVM method = contains(D)Z
	open operator fun contains(element: Double): Boolean

	// JVM method = get(I)Ljava/lang/Double;
	open operator fun get(index: Int): Double

	// JVM method = indexOf(D)I
	open fun indexOf(element: Double): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lastIndexOf(D)I
	open fun lastIndexOf(element: Double): Int
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.ArraysKt___ArraysJvmKt$asList$7 : AbstractList<Boolean>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// JVM method = contains(Z)Z
	open operator fun contains(element: Boolean): Boolean

	// JVM method = get(I)Ljava/lang/Boolean;
	open operator fun get(index: Int): Boolean

	// JVM method = indexOf(Z)I
	open fun indexOf(element: Boolean): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lastIndexOf(Z)I
	open fun lastIndexOf(element: Boolean): Int
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.ArraysKt___ArraysJvmKt$asList$8 : AbstractList<Char>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// JVM method = contains(C)Z
	open operator fun contains(element: Char): Boolean

	// JVM method = get(I)Ljava/lang/Character;
	open operator fun get(index: Int): Char

	// JVM method = indexOf(C)I
	open fun indexOf(element: Char): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lastIndexOf(C)I
	open fun lastIndexOf(element: Char): Int
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: CollectionsKt__IterablesKt$Iterable$1
/* local */ class kotlin.collections.CollectionsKt__IterablesKt$Iterable$1 : Iterable<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: CollectionsKt__IterablesKt$Iterable$1
/* local */ class kotlin.collections.CollectionsKt__IterablesKt$Iterable$1 : Iterable<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: CollectionsKt__IterablesKt$Iterable$1
/* local */ class kotlin.collections.CollectionsKt__IterablesKt$Iterable$1 : Iterable<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: CollectionsKt__IterablesKt$Iterable$1
/* local */ class kotlin.collections.CollectionsKt__IterablesKt$Iterable$1 : Iterable<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: CollectionsKt__IterablesKt$Iterable$1
/* local */ class kotlin.collections.CollectionsKt__IterablesKt$Iterable$1 : Iterable<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: CollectionsKt__IterablesKt$Iterable$1
/* local */ class kotlin.collections.CollectionsKt__IterablesKt$Iterable$1 : Iterable<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: CollectionsKt__IterablesKt$Iterable$1
/* local */ class kotlin.collections.CollectionsKt__IterablesKt$Iterable$1 : Iterable<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: CollectionsKt__IterablesKt$Iterable$1
/* local */ class kotlin.collections.CollectionsKt__IterablesKt$Iterable$1 : Iterable<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: CollectionsKt__IterablesKt$Iterable$1
/* local */ class kotlin.collections.CollectionsKt__IterablesKt$Iterable$1 : Iterable<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.ArraysKt___ArraysKt$groupingBy$1 : Grouping<T#0, T#1> {

	// *** FUNCTIONS ***

	// JVM method = keyOf(Ljava/lang/Object;)Ljava/lang/Object;
	open fun keyOf(element: T#0): T#1

	// JVM method = sourceIterator()Ljava/util/Iterator;
	open fun sourceIterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.BooleanIterator : Iterator<Boolean> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = next()Ljava/lang/Boolean;
	operator fun next(): Boolean

	// JVM method = nextBoolean()Z
	abstract fun nextBoolean(): Boolean
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.ByteIterator : Iterator<Byte> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = next()Ljava/lang/Byte;
	operator fun next(): Byte

	// JVM method = nextByte()B
	abstract fun nextByte(): Byte
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.CharIterator : Iterator<Char> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = next()Ljava/lang/Character;
	operator fun next(): Char

	// JVM method = nextChar()C
	abstract fun nextChar(): Char
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.CollectionsKt__IterablesKt$Iterable$1 : Iterable<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.CollectionsKt__IteratorsJVMKt$iterator$1 : Iterator<T#0> {

	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.CollectionsKt___CollectionsKt$groupingBy$1 : Grouping<T#0, T#1> {

	// *** FUNCTIONS ***

	// JVM method = keyOf(Ljava/lang/Object;)Ljava/lang/Object;
	open fun keyOf(element: T#0): T#1

	// JVM method = sourceIterator()Ljava/util/Iterator;
	open fun sourceIterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.DoubleIterator : Iterator<Double> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = next()Ljava/lang/Double;
	operator fun next(): Double

	// JVM method = nextDouble()D
	abstract fun nextDouble(): Double
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.FloatIterator : Iterator<Float> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = next()Ljava/lang/Float;
	operator fun next(): Float

	// JVM method = nextFloat()F
	abstract fun nextFloat(): Float
}

// ------------------------------------------------------------------------------------------------------

data class kotlin.collections.IndexedValue<out T> {

	// *** PROPERTIES ***

	// JVM field = index:I
	val index: Int

	// JVM field = value:Ljava/lang/Object;
	val value: out T


	// *** CONSTRUCTORS ***

	// JVM method = <init>(ILjava/lang/Object;)V
	constructor(index: Int, value: out T)


	// *** FUNCTIONS ***

	// JVM method = component1()I
	/* synthesized */ operator fun component1(): Int

	// JVM method = component2()Ljava/lang/Object;
	/* synthesized */ operator fun component2(): out T

	// JVM method = copy(ILjava/lang/Object;)Lkotlin/collections/IndexedValue;
	/* synthesized */ fun copy(index: Int /* = default */, value: out T /* = default */): IndexedValue<out T>

	// JVM method = equals(Ljava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	/* synthesized */ open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.IndexingIterable<out T> : Iterable<IndexedValue<out T>> {

	// *** PROPERTIES ***

	// JVM field = iteratorFactory:Lkotlin/jvm/functions/Function0;
	private val iteratorFactory: () -> Iterator<out T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/jvm/functions/Function0;)V
	constructor(iteratorFactory: () -> Iterator<out T>)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<IndexedValue<out T>>
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.IndexingIterator<out T> : Iterator<IndexedValue<out T>> {

	// *** PROPERTIES ***

	// JVM field = index:I
	private var index: Int

	// JVM field = iterator:Ljava/util/Iterator;
	private val iterator: Iterator<out T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/util/Iterator;)V
	constructor(iterator: Iterator<out T>)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	operator fun hasNext(): Boolean

	// JVM method = next()Lkotlin/collections/IndexedValue;
	operator fun next(): IndexedValue<out T>
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.IntIterator : Iterator<Int> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = next()Ljava/lang/Integer;
	operator fun next(): Int

	// JVM method = nextInt()I
	abstract fun nextInt(): Int
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.LongIterator : Iterator<Long> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = next()Ljava/lang/Long;
	operator fun next(): Long

	// JVM method = nextLong()J
	abstract fun nextLong(): Long
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.collections.MapWithDefaultImpl<K, out V> : MapWithDefault<K, out V> {

	// *** PROPERTIES ***

	// JVM field = default:Lkotlin/jvm/functions/Function1;
	private val default: (@ParameterName(name = "key") K) -> out V

	open val entries: Set<Map.Entry<K, out V>>
		// JVM method = getEntries()Ljava/util/Set;
		get() = /* non-default */

	open val keys: Set<K>
		// JVM method = getKeys()Ljava/util/Set;
		get() = /* non-default */

	// JVM field = map:Ljava/util/Map;
	open val map: Map<K, out V>

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */

	open val values: Collection<out V>
		// JVM method = getValues()Ljava/util/Collection;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)V
	constructor(map: Map<K, out V>, default: (@ParameterName(name = "key") K) -> out V)


	// *** FUNCTIONS ***

	// JVM method = containsKey(Ljava/lang/Object;)Z
	open fun containsKey(key: K): Boolean

	// JVM method = containsValue(Ljava/lang/Object;)Z
	open fun containsValue(value: out V): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = get(Ljava/lang/Object;)Ljava/lang/Object;
	open operator fun get(key: K): out V?

	// JVM method = getOrImplicitDefault(Ljava/lang/Object;)Ljava/lang/Object;
	open fun getOrImplicitDefault(key: K): out V

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.MovingSubList<out E> : AbstractList<out E>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	// JVM field = _size:I
	private var _size: Int

	// JVM field = fromIndex:I
	private var fromIndex: Int

	// JVM field = list:Ljava/util/List;
	private val list: List<out E>

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/util/List;)V
	constructor(list: List<out E>)


	// *** FUNCTIONS ***

	// JVM method = get(I)Ljava/lang/Object;
	open operator fun get(index: Int): out E

	// JVM method = move(II)V
	fun move(fromIndex: Int, toIndex: Int)
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.collections.MutableMapWithDefaultImpl<K, V> : MutableMapWithDefault<K, V> {

	// *** PROPERTIES ***

	// JVM field = default:Lkotlin/jvm/functions/Function1;
	private val default: (@ParameterName(name = "key") K) -> V

	open val entries: MutableSet<MutableMap.MutableEntry<K, V>>
		// JVM method = getEntries()Ljava/util/Set;
		get() = /* non-default */

	open val keys: MutableSet<K>
		// JVM method = getKeys()Ljava/util/Set;
		get() = /* non-default */

	// JVM field = map:Ljava/util/Map;
	open val map: MutableMap<K, V>

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */

	open val values: MutableCollection<V>
		// JVM method = getValues()Ljava/util/Collection;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)V
	constructor(map: MutableMap<K, V>, default: (@ParameterName(name = "key") K) -> V)


	// *** FUNCTIONS ***

	// JVM method = clear()V
	open fun clear()

	// JVM method = containsKey(Ljava/lang/Object;)Z
	open fun containsKey(key: K): Boolean

	// JVM method = containsValue(Ljava/lang/Object;)Z
	open fun containsValue(value: V): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = get(Ljava/lang/Object;)Ljava/lang/Object;
	open operator fun get(key: K): V?

	// JVM method = getOrImplicitDefault(Ljava/lang/Object;)Ljava/lang/Object;
	open fun getOrImplicitDefault(key: K): V

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	open fun put(key: K, value: V): V?

	// JVM method = putAll(Ljava/util/Map;)V
	open fun putAll(from: Map<out K, V>)

	// JVM method = remove(Ljava/lang/Object;)Ljava/lang/Object;
	open fun remove(key: K): V?

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.collections.ReversedList<T> : AbstractMutableList<T> {

	// *** PROPERTIES ***

	// JVM field = delegate:Ljava/util/List;
	private val delegate: MutableList<T>

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/util/List;)V
	constructor(delegate: MutableList<T>)


	// *** FUNCTIONS ***

	// JVM method = add(ILjava/lang/Object;)V
	open fun add(index: Int, element: T)

	// JVM method = clear()V
	open fun clear()

	// JVM method = get(I)Ljava/lang/Object;
	open operator fun get(index: Int): T

	// JVM method = removeAt(I)Ljava/lang/Object;
	open fun removeAt(index: Int): T

	// JVM method = set(ILjava/lang/Object;)Ljava/lang/Object;
	open operator fun set(index: Int, element: T): T
}

// ------------------------------------------------------------------------------------------------------

private open class kotlin.collections.ReversedListReadOnly<out T> : AbstractList<out T> {

	// *** PROPERTIES ***

	// JVM field = delegate:Ljava/util/List;
	private val delegate: List<out T>

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/util/List;)V
	constructor(delegate: List<out T>)


	// *** FUNCTIONS ***

	// JVM method = get(I)Ljava/lang/Object;
	open operator fun get(index: Int): out T
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.collections.RingBuffer$iterator$1 : AbstractIterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = count:I
	private var count: Int

	// JVM field = index:I
	private var index: Int


	// *** FUNCTIONS ***

	// JVM method = computeNext()V
	protected open fun computeNext()
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.collections.RingBuffer<T> : AbstractList<T>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	// JVM field = buffer:[Ljava/lang/Object;
	private val buffer: Array<Any?>

	// JVM field = capacity:I
	private val capacity: Int

	// JVM field = size:I
	open var size: Int
		private set(`<set-?>`: Int) { /* non-default */ }

	// JVM field = startIndex:I
	private var startIndex: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	/* secondary */ constructor(capacity: Int)

	// JVM method = <init>([Ljava/lang/Object;I)V
	constructor(buffer: Array<Any?>, filledSize: Int)


	// *** FUNCTIONS ***

	// JVM method = add(Ljava/lang/Object;)V
	fun add(element: T)

	// JVM method = expanded(I)Lkotlin/collections/RingBuffer;
	fun expanded(maxCapacity: Int): RingBuffer<T>

	// JVM method = get(I)Ljava/lang/Object;
	open operator fun get(index: Int): T

	// JVM method = isFull()Z
	fun isFull(): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T>

	// JVM method = removeFirst(I)V
	fun removeFirst(n: Int)

	// JVM method = toArray()[Ljava/lang/Object;
	protected open fun toArray(): Array<Any?>

	// JVM method = toArray([Ljava/lang/Object;)[Ljava/lang/Object;
	protected open fun <T> toArray(array: Array<T>): Array<T>

	// JVM method = forward(II)I
	private inline fun Int.forward(n: Int): Int
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.collections.ShortIterator : Iterator<Short> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = next()Ljava/lang/Short;
	operator fun next(): Short

	// JVM method = nextShort()S
	abstract fun nextShort(): Short
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

internal abstract class kotlin.collections.builders.AbstractMapBuilderEntrySet<E : Map.Entry<K, V>, K, V> : AbstractMutableSet<E : Map.Entry<K, V>> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = contains(Ljava/util/Map$Entry;)Z
	operator fun contains(element: E : Map.Entry<K, V>): Boolean

	// JVM method = containsEntry(Ljava/util/Map$Entry;)Z
	abstract fun containsEntry(element: Map.Entry<K, V>): Boolean
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.collections.builders.ListBuilder.Itr<E> : MutableListIterator<E> {

	// *** PROPERTIES ***

	// JVM field = index:I
	private var index: Int

	// JVM field = lastIndex:I
	private var lastIndex: Int

	// JVM field = list:Lkotlin/collections/builders/ListBuilder;
	private val list: kotlin.collections.builders.ListBuilder<E>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/collections/builders/ListBuilder;I)V
	/* secondary */ constructor(list: kotlin.collections.builders.ListBuilder<E>, index: Int)


	// *** FUNCTIONS ***

	// JVM method = add(Ljava/lang/Object;)V
	open fun add(element: E)

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = hasPrevious()Z
	open fun hasPrevious(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): E

	// JVM method = nextIndex()I
	open fun nextIndex(): Int

	// JVM method = previous()Ljava/lang/Object;
	open fun previous(): E

	// JVM method = previousIndex()I
	open fun previousIndex(): Int

	// JVM method = remove()V
	open fun remove()

	// JVM method = set(Ljava/lang/Object;)V
	open fun set(element: E)
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.builders.ListBuilder<E> :
	MutableList<E>,
	RandomAccess /* = java.util.RandomAccess */,
	AbstractMutableList<E>,
	Serializable /* = java.io.Serializable */ {

	// *** NESTED TYPES ***

	class Itr


	// *** PROPERTIES ***

	// JVM field = array:[Ljava/lang/Object;
	private var array: Array<E>

	// JVM field = backing:Lkotlin/collections/builders/ListBuilder;
	private val backing: kotlin.collections.builders.ListBuilder<E>?

	private val isEffectivelyReadOnly: Boolean
		// JVM method = isEffectivelyReadOnly()Z
		get() = /* non-default */

	// JVM field = isReadOnly:Z
	private var isReadOnly: Boolean

	// JVM field = length:I
	private var length: Int

	// JVM field = offset:I
	private var offset: Int

	// JVM field = root:Lkotlin/collections/builders/ListBuilder;
	private val root: kotlin.collections.builders.ListBuilder<E>?

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	/* secondary */ constructor()

	// JVM method = <init>(I)V
	/* secondary */ constructor(initialCapacity: Int)

	// JVM method = <init>([Ljava/lang/Object;IIZLkotlin/collections/builders/ListBuilder;Lkotlin/collections/builders/ListBuilder;)V
	private constructor(array: Array<E>, offset: Int, length: Int, isReadOnly: Boolean, backing: kotlin.collections.builders.ListBuilder<E>?, root: kotlin.collections.builders.ListBuilder<E>?)


	// *** FUNCTIONS ***

	// JVM method = add(Ljava/lang/Object;)Z
	open fun add(element: E): Boolean

	// JVM method = add(ILjava/lang/Object;)V
	open fun add(index: Int, element: E)

	// JVM method = addAll(ILjava/util/Collection;)Z
	open fun addAll(index: Int, elements: Collection<E>): Boolean

	// JVM method = addAll(Ljava/util/Collection;)Z
	open fun addAll(elements: Collection<E>): Boolean

	// JVM method = addAllInternal(ILjava/util/Collection;I)V
	private fun addAllInternal(i: Int, elements: Collection<E>, n: Int)

	// JVM method = addAtInternal(ILjava/lang/Object;)V
	private fun addAtInternal(i: Int, element: E)

	// JVM method = build()Ljava/util/List;
	fun build(): List<E>

	// JVM method = checkIsMutable()V
	private fun checkIsMutable()

	// JVM method = clear()V
	open fun clear()

	// JVM method = contentEquals(Ljava/util/List;)Z
	private fun contentEquals(other: List<*>): Boolean

	// JVM method = ensureCapacity(I)V
	private fun ensureCapacity(minCapacity: Int)

	// JVM method = ensureExtraCapacity(I)V
	private fun ensureExtraCapacity(n: Int)

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = get(I)Ljava/lang/Object;
	open operator fun get(index: Int): E

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = indexOf(Ljava/lang/Object;)I
	open fun indexOf(element: E): Int

	// JVM method = insertAtInternal(II)V
	private fun insertAtInternal(i: Int, n: Int)

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): MutableIterator<E>

	// JVM method = lastIndexOf(Ljava/lang/Object;)I
	open fun lastIndexOf(element: E): Int

	// JVM method = listIterator()Ljava/util/ListIterator;
	open fun listIterator(): MutableListIterator<E>

	// JVM method = listIterator(I)Ljava/util/ListIterator;
	open fun listIterator(index: Int): MutableListIterator<E>

	// JVM method = remove(Ljava/lang/Object;)Z
	open fun remove(element: E): Boolean

	// JVM method = removeAll(Ljava/util/Collection;)Z
	open fun removeAll(elements: Collection<E>): Boolean

	// JVM method = removeAt(I)Ljava/lang/Object;
	open fun removeAt(index: Int): E

	// JVM method = removeAtInternal(I)Ljava/lang/Object;
	private fun removeAtInternal(i: Int): E

	// JVM method = removeRangeInternal(II)V
	private fun removeRangeInternal(rangeOffset: Int, rangeLength: Int)

	// JVM method = retainAll(Ljava/util/Collection;)Z
	open fun retainAll(elements: Collection<E>): Boolean

	// JVM method = retainOrRemoveAllInternal(IILjava/util/Collection;Z)I
	private fun retainOrRemoveAllInternal(rangeOffset: Int, rangeLength: Int, elements: Collection<E>, retain: Boolean): Int

	// JVM method = set(ILjava/lang/Object;)Ljava/lang/Object;
	open operator fun set(index: Int, element: E): E

	// JVM method = subList(II)Ljava/util/List;
	open fun subList(fromIndex: Int, toIndex: Int): MutableList<E>

	// JVM method = toArray()[Ljava/lang/Object;
	open fun toArray(): Array<Any?>

	// JVM method = toArray([Ljava/lang/Object;)[Ljava/lang/Object;
	open fun <T> toArray(destination: Array<T>): Array<T>

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String

	// JVM method = writeReplace()Ljava/lang/Object;
	private fun writeReplace(): Any
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.builders.MapBuilder.EntriesItr<K, V> : kotlin.collections.builders.MapBuilder.Itr<K, V>, MutableIterator<MutableMap.MutableEntry<K, V>> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/collections/builders/MapBuilder;)V
	constructor(map: kotlin.collections.builders.MapBuilder<K, V>)


	// *** FUNCTIONS ***

	// JVM method = next()Lkotlin/collections/builders/MapBuilder$EntryRef;
	open operator fun next(): kotlin.collections.builders.MapBuilder.EntryRef<K, V>

	// JVM method = nextAppendString(Ljava/lang/StringBuilder;)V
	fun nextAppendString(sb: StringBuilder /* = java.lang.StringBuilder */)

	// JVM method = nextHashCode$kotlin_stdlib()I
	internal fun nextHashCode(): Int
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.builders.MapBuilder.EntryRef<K, V> : MutableMap.MutableEntry<K, V> {

	// *** PROPERTIES ***

	// JVM field = index:I
	private val index: Int

	open val key: K
		// JVM method = getKey()Ljava/lang/Object;
		get() = /* non-default */

	// JVM field = map:Lkotlin/collections/builders/MapBuilder;
	private val map: kotlin.collections.builders.MapBuilder<K, V>

	open val value: V
		// JVM method = getValue()Ljava/lang/Object;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/collections/builders/MapBuilder;I)V
	constructor(map: kotlin.collections.builders.MapBuilder<K, V>, index: Int)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = setValue(Ljava/lang/Object;)Ljava/lang/Object;
	open fun setValue(newValue: V): V

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal open class kotlin.collections.builders.MapBuilder.Itr<K, V> {

	// *** PROPERTIES ***

	// JVM field = index:I
	internal var index: Int

	// JVM field = lastIndex:I
	internal var lastIndex: Int

	// JVM field = map:Lkotlin/collections/builders/MapBuilder;
	internal val map: kotlin.collections.builders.MapBuilder<K, V>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/collections/builders/MapBuilder;)V
	constructor(map: kotlin.collections.builders.MapBuilder<K, V>)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	fun hasNext(): Boolean

	// JVM method = initNext$kotlin_stdlib()V
	internal fun initNext()

	// JVM method = remove()V
	fun remove()
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.builders.MapBuilder.KeysItr<K, V> : kotlin.collections.builders.MapBuilder.Itr<K, V>, MutableIterator<K> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/collections/builders/MapBuilder;)V
	constructor(map: kotlin.collections.builders.MapBuilder<K, V>)


	// *** FUNCTIONS ***

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): K
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.builders.MapBuilder.ValuesItr<K, V> : kotlin.collections.builders.MapBuilder.Itr<K, V>, MutableIterator<V> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/collections/builders/MapBuilder;)V
	constructor(map: kotlin.collections.builders.MapBuilder<K, V>)


	// *** FUNCTIONS ***

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): V
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.builders.MapBuilder<K, V> : MutableMap<K, V>, Serializable /* = java.io.Serializable */ {

	// *** NESTED TYPES ***

	companion object
	class EntriesItr
	class EntryRef
	class Itr
	class KeysItr
	class ValuesItr


	// *** PROPERTIES ***

	internal val capacity: Int
		// JVM method = getCapacity$kotlin_stdlib()I
		get() = /* non-default */

	open val entries: MutableSet<MutableMap.MutableEntry<K, V>>
		// JVM method = getEntries()Ljava/util/Set;
		get() = /* non-default */

	// JVM field = entriesView:Lkotlin/collections/builders/MapBuilderEntries;
	private var entriesView: kotlin.collections.builders.MapBuilderEntries<K, V>?

	// JVM field = hashArray:[I
	private var hashArray: IntArray

	// JVM field = hashShift:I
	private var hashShift: Int

	private val hashSize: Int
		// JVM method = getHashSize()I
		get() = /* non-default */

	// JVM field = isReadOnly:Z
	internal var isReadOnly: Boolean
		private set(`<set-?>`: Boolean) { /* non-default */ }

	open val keys: MutableSet<K>
		// JVM method = getKeys()Ljava/util/Set;
		get() = /* non-default */

	// JVM field = keysArray:[Ljava/lang/Object;
	private var keysArray: Array<K>

	// JVM field = keysView:Lkotlin/collections/builders/MapBuilderKeys;
	private var keysView: kotlin.collections.builders.MapBuilderKeys<K>?

	// JVM field = length:I
	private var length: Int

	// JVM field = maxProbeDistance:I
	private var maxProbeDistance: Int

	// JVM field = presenceArray:[I
	private var presenceArray: IntArray

	// JVM field = size:I
	open var size: Int
		private set(`<set-?>`: Int) { /* non-default */ }

	open val values: MutableCollection<V>
		// JVM method = getValues()Ljava/util/Collection;
		get() = /* non-default */

	// JVM field = valuesArray:[Ljava/lang/Object;
	private var valuesArray: Array<V>?

	// JVM field = valuesView:Lkotlin/collections/builders/MapBuilderValues;
	private var valuesView: kotlin.collections.builders.MapBuilderValues<V>?


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	/* secondary */ constructor()

	// JVM method = <init>(I)V
	/* secondary */ constructor(initialCapacity: Int)

	// JVM method = <init>([Ljava/lang/Object;[Ljava/lang/Object;[I[III)V
	private constructor(keysArray: Array<K>, valuesArray: Array<V>?, presenceArray: IntArray, hashArray: IntArray, maxProbeDistance: Int, length: Int)


	// *** FUNCTIONS ***

	// JVM method = addKey$kotlin_stdlib(Ljava/lang/Object;)I
	internal fun addKey(key: K): Int

	// JVM method = allocateValuesArray()[Ljava/lang/Object;
	private fun allocateValuesArray(): Array<V>

	// JVM method = build()Ljava/util/Map;
	fun build(): Map<K, V>

	// JVM method = checkIsMutable$kotlin_stdlib()V
	internal fun checkIsMutable()

	// JVM method = clear()V
	open fun clear()

	// JVM method = compact()V
	private fun compact()

	// JVM method = containsAllEntries$kotlin_stdlib(Ljava/util/Collection;)Z
	internal fun containsAllEntries(m: Collection<*>): Boolean

	// JVM method = containsEntry$kotlin_stdlib(Ljava/util/Map$Entry;)Z
	internal fun containsEntry(entry: Map.Entry<K, V>): Boolean

	// JVM method = containsKey(Ljava/lang/Object;)Z
	open fun containsKey(key: K): Boolean

	// JVM method = containsValue(Ljava/lang/Object;)Z
	open fun containsValue(value: V): Boolean

	// JVM method = contentEquals(Ljava/util/Map;)Z
	private fun contentEquals(other: Map<*, *>): Boolean

	// JVM method = ensureCapacity(I)V
	private fun ensureCapacity(capacity: Int)

	// JVM method = ensureExtraCapacity(I)V
	private fun ensureExtraCapacity(n: Int)

	// JVM method = entriesIterator$kotlin_stdlib()Lkotlin/collections/builders/MapBuilder$EntriesItr;
	internal fun entriesIterator(): kotlin.collections.builders.MapBuilder.EntriesItr<K, V>

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = findKey(Ljava/lang/Object;)I
	private fun findKey(key: K): Int

	// JVM method = findValue(Ljava/lang/Object;)I
	private fun findValue(value: V): Int

	// JVM method = get(Ljava/lang/Object;)Ljava/lang/Object;
	open operator fun get(key: K): V?

	// JVM method = hash(Ljava/lang/Object;)I
	private fun hash(key: K): Int

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = keysIterator$kotlin_stdlib()Lkotlin/collections/builders/MapBuilder$KeysItr;
	internal fun keysIterator(): kotlin.collections.builders.MapBuilder.KeysItr<K, V>

	// JVM method = put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	open fun put(key: K, value: V): V?

	// JVM method = putAll(Ljava/util/Map;)V
	open fun putAll(from: Map<out K, V>)

	// JVM method = putAllEntries(Ljava/util/Collection;)Z
	private fun putAllEntries(from: Collection<Map.Entry<K, V>>): Boolean

	// JVM method = putEntry(Ljava/util/Map$Entry;)Z
	private fun putEntry(entry: Map.Entry<K, V>): Boolean

	// JVM method = putRehash(I)Z
	private fun putRehash(i: Int): Boolean

	// JVM method = rehash(I)V
	private fun rehash(newHashSize: Int)

	// JVM method = remove(Ljava/lang/Object;)Ljava/lang/Object;
	open fun remove(key: K): V?

	// JVM method = removeEntry$kotlin_stdlib(Ljava/util/Map$Entry;)Z
	internal fun removeEntry(entry: Map.Entry<K, V>): Boolean

	// JVM method = removeHashAt(I)V
	private fun removeHashAt(removedHash: Int)

	// JVM method = removeKey$kotlin_stdlib(Ljava/lang/Object;)I
	internal fun removeKey(key: K): Int

	// JVM method = removeKeyAt(I)V
	private fun removeKeyAt(index: Int)

	// JVM method = removeValue$kotlin_stdlib(Ljava/lang/Object;)Z
	internal fun removeValue(element: V): Boolean

	// JVM method = shouldCompact(I)Z
	private fun shouldCompact(extraCapacity: Int): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String

	// JVM method = valuesIterator$kotlin_stdlib()Lkotlin/collections/builders/MapBuilder$ValuesItr;
	internal fun valuesIterator(): kotlin.collections.builders.MapBuilder.ValuesItr<K, V>

	// JVM method = writeReplace()Ljava/lang/Object;
	private fun writeReplace(): Any
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.builders.MapBuilderEntries<K, V> : kotlin.collections.builders.AbstractMapBuilderEntrySet<MutableMap.MutableEntry<K, V>, K, V> {

	// *** PROPERTIES ***

	// JVM field = backing:Lkotlin/collections/builders/MapBuilder;
	val backing: kotlin.collections.builders.MapBuilder<K, V>

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/collections/builders/MapBuilder;)V
	internal constructor(backing: kotlin.collections.builders.MapBuilder<K, V>)


	// *** FUNCTIONS ***

	// JVM method = add(Ljava/util/Map$Entry;)Z
	open fun add(element: MutableMap.MutableEntry<K, V>): Boolean

	// JVM method = addAll(Ljava/util/Collection;)Z
	open fun addAll(elements: Collection<MutableMap.MutableEntry<K, V>>): Boolean

	// JVM method = clear()V
	open fun clear()

	// JVM method = containsAll(Ljava/util/Collection;)Z
	open fun containsAll(elements: Collection<MutableMap.MutableEntry<K, V>>): Boolean

	// JVM method = containsEntry(Ljava/util/Map$Entry;)Z
	open fun containsEntry(element: Map.Entry<K, V>): Boolean

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): MutableIterator<MutableMap.MutableEntry<K, V>>

	// JVM method = remove(Ljava/util/Map$Entry;)Z
	open fun remove(element: MutableMap.MutableEntry<K, V>): Boolean

	// JVM method = removeAll(Ljava/util/Collection;)Z
	open fun removeAll(elements: Collection<MutableMap.MutableEntry<K, V>>): Boolean

	// JVM method = retainAll(Ljava/util/Collection;)Z
	open fun retainAll(elements: Collection<MutableMap.MutableEntry<K, V>>): Boolean
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.builders.MapBuilderKeys<E> : MutableSet<E>, AbstractMutableSet<E> {

	// *** PROPERTIES ***

	// JVM field = backing:Lkotlin/collections/builders/MapBuilder;
	private val backing: kotlin.collections.builders.MapBuilder<E, *>

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/collections/builders/MapBuilder;)V
	internal constructor(backing: kotlin.collections.builders.MapBuilder<E, *>)


	// *** FUNCTIONS ***

	// JVM method = add(Ljava/lang/Object;)Z
	open fun add(element: E): Boolean

	// JVM method = addAll(Ljava/util/Collection;)Z
	open fun addAll(elements: Collection<E>): Boolean

	// JVM method = clear()V
	open fun clear()

	// JVM method = contains(Ljava/lang/Object;)Z
	open operator fun contains(element: E): Boolean

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): MutableIterator<E>

	// JVM method = remove(Ljava/lang/Object;)Z
	open fun remove(element: E): Boolean

	// JVM method = removeAll(Ljava/util/Collection;)Z
	open fun removeAll(elements: Collection<E>): Boolean

	// JVM method = retainAll(Ljava/util/Collection;)Z
	open fun retainAll(elements: Collection<E>): Boolean
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.builders.MapBuilderValues<V> : MutableCollection<V>, AbstractMutableCollection<V> {

	// *** PROPERTIES ***

	// JVM field = backing:Lkotlin/collections/builders/MapBuilder;
	val backing: kotlin.collections.builders.MapBuilder<*, V>

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/collections/builders/MapBuilder;)V
	internal constructor(backing: kotlin.collections.builders.MapBuilder<*, V>)


	// *** FUNCTIONS ***

	// JVM method = add(Ljava/lang/Object;)Z
	open fun add(element: V): Boolean

	// JVM method = addAll(Ljava/util/Collection;)Z
	open fun addAll(elements: Collection<V>): Boolean

	// JVM method = clear()V
	open fun clear()

	// JVM method = contains(Ljava/lang/Object;)Z
	open operator fun contains(element: V): Boolean

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): MutableIterator<V>

	// JVM method = remove(Ljava/lang/Object;)Z
	open fun remove(element: V): Boolean

	// JVM method = removeAll(Ljava/util/Collection;)Z
	open fun removeAll(elements: Collection<V>): Boolean

	// JVM method = retainAll(Ljava/util/Collection;)Z
	open fun retainAll(elements: Collection<V>): Boolean
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.builders.SerializedCollection : java.io.Externalizable {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = collection:Ljava/util/Collection;
	private var collection: Collection<*>

	// JVM field = tag:I
	private val tag: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	/* secondary */ constructor()

	// JVM method = <init>(Ljava/util/Collection;I)V
	constructor(collection: Collection<*>, tag: Int)


	// *** FUNCTIONS ***

	// JVM method = readExternal(Ljava/io/ObjectInput;)V
	open fun readExternal(input: java.io.ObjectInput)

	// JVM method = readResolve()Ljava/lang/Object;
	private fun readResolve(): Any

	// JVM method = writeExternal(Ljava/io/ObjectOutput;)V
	open fun writeExternal(output: java.io.ObjectOutput)
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.collections.builders.SerializedMap : java.io.Externalizable {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = map:Ljava/util/Map;
	private var map: Map<*, *>


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	/* secondary */ constructor()

	// JVM method = <init>(Ljava/util/Map;)V
	constructor(map: Map<*, *>)


	// *** FUNCTIONS ***

	// JVM method = readExternal(Ljava/io/ObjectInput;)V
	open fun readExternal(input: java.io.ObjectInput)

	// JVM method = readResolve()Ljava/lang/Object;
	private fun readResolve(): Any

	// JVM method = writeExternal(Ljava/io/ObjectOutput;)V
	open fun writeExternal(output: java.io.ObjectOutput)
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.collections.builders.SetBuilder<E> :
	MutableSet<E>,
	AbstractMutableSet<E>,
	Serializable /* = java.io.Serializable */ {

	// *** PROPERTIES ***

	// JVM field = backing:Lkotlin/collections/builders/MapBuilder;
	private val backing: kotlin.collections.builders.MapBuilder<E, *>

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	/* secondary */ constructor()

	// JVM method = <init>(I)V
	/* secondary */ constructor(initialCapacity: Int)

	// JVM method = <init>(Lkotlin/collections/builders/MapBuilder;)V
	internal constructor(backing: kotlin.collections.builders.MapBuilder<E, *>)


	// *** FUNCTIONS ***

	// JVM method = add(Ljava/lang/Object;)Z
	open fun add(element: E): Boolean

	// JVM method = addAll(Ljava/util/Collection;)Z
	open fun addAll(elements: Collection<E>): Boolean

	// JVM method = build()Ljava/util/Set;
	fun build(): Set<E>

	// JVM method = clear()V
	open fun clear()

	// JVM method = contains(Ljava/lang/Object;)Z
	open operator fun contains(element: E): Boolean

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): MutableIterator<E>

	// JVM method = remove(Ljava/lang/Object;)Z
	open fun remove(element: E): Boolean

	// JVM method = removeAll(Ljava/util/Collection;)Z
	open fun removeAll(elements: Collection<E>): Boolean

	// JVM method = retainAll(Ljava/util/Collection;)Z
	open fun retainAll(elements: Collection<E>): Boolean

	// JVM method = writeReplace()Ljava/lang/Object;
	private fun writeReplace(): Any
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
/* local */ class kotlin.collections.unsigned.UArraysKt___UArraysJvmKt$asList$1 : AbstractList<UInt>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = contains-WZ4Q5Ns(I)Z
	open operator fun contains(element: UInt): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = get-pVg5ArA(I)I
	open operator fun get(index: Int): UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = indexOf-WZ4Q5Ns(I)I
	open fun indexOf(element: UInt): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = lastIndexOf-WZ4Q5Ns(I)I
	open fun lastIndexOf(element: UInt): Int
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
/* local */ class kotlin.collections.unsigned.UArraysKt___UArraysJvmKt$asList$2 : AbstractList<ULong>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = contains-VKZWuLQ(J)Z
	open operator fun contains(element: ULong): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = get-s-VKNKU(I)J
	open operator fun get(index: Int): ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = indexOf-VKZWuLQ(J)I
	open fun indexOf(element: ULong): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = lastIndexOf-VKZWuLQ(J)I
	open fun lastIndexOf(element: ULong): Int
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
/* local */ class kotlin.collections.unsigned.UArraysKt___UArraysJvmKt$asList$3 : AbstractList<UByte>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = contains-7apg3OU(B)Z
	open operator fun contains(element: UByte): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = get-w2LRezQ(I)B
	open operator fun get(index: Int): UByte

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = indexOf-7apg3OU(B)I
	open fun indexOf(element: UByte): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = lastIndexOf-7apg3OU(B)I
	open fun lastIndexOf(element: UByte): Int
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
/* local */ class kotlin.collections.unsigned.UArraysKt___UArraysJvmKt$asList$4 : AbstractList<UShort>, RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = contains-xj2QHRw(S)Z
	open operator fun contains(element: UShort): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = get-Mh2AYeg(I)S
	open operator fun get(index: Int): UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = indexOf-xj2QHRw(S)I
	open fun indexOf(element: UShort): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = lastIndexOf-xj2QHRw(S)I
	open fun lastIndexOf(element: UShort): Int
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.comparisons.ReversedComparator<T> : Comparator<T> /* = java.util.Comparator<T> */ {

	// *** PROPERTIES ***

	// JVM field = comparator:Ljava/util/Comparator;
	val comparator: Comparator<T> /* = java.util.Comparator<T> */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/util/Comparator;)V
	constructor(comparator: Comparator<T> /* = java.util.Comparator<T> */)


	// *** FUNCTIONS ***

	// JVM method = compare(Ljava/lang/Object;Ljava/lang/Object;)I
	open fun compare(a: T, b: T): Int

	// JVM method = reversed()Ljava/util/Comparator;
	fun reversed(): Comparator<T> /* = java.util.Comparator<T> */
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.concurrent.ThreadsKt$thread$thread$1 : java.lang.Thread {

	// *** FUNCTIONS ***

	// JVM method = run()V
	open fun run()
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.concurrent.TimersKt$timerTask$1 : java.util.TimerTask {

	// *** FUNCTIONS ***

	// JVM method = run()V
	open fun run()
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.coroutines.AbstractCoroutineContextElement : kotlin.coroutines.CoroutineContext.Element {

	// *** PROPERTIES ***

	// JVM field = key:Lkotlin/coroutines/CoroutineContext$Key;
	open val key: kotlin.coroutines.CoroutineContext.Key<*>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/coroutines/CoroutineContext$Key;)V
	constructor(key: kotlin.coroutines.CoroutineContext.Key<*>)
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.coroutines.AbstractCoroutineContextKey<B : kotlin.coroutines.CoroutineContext.Element, E : B : kotlin.coroutines.CoroutineContext.Element> : kotlin.coroutines.CoroutineContext.Key<E : B : kotlin.coroutines.CoroutineContext.Element> {

	// *** PROPERTIES ***

	// JVM field = safeCast:Lkotlin/jvm/functions/Function1;
	private val safeCast: (@ParameterName(name = "element") kotlin.coroutines.CoroutineContext.Element) -> E : B : kotlin.coroutines.CoroutineContext.Element?

	// JVM field = topmostKey:Lkotlin/coroutines/CoroutineContext$Key;
	private val topmostKey: kotlin.coroutines.CoroutineContext.Key<*>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/coroutines/CoroutineContext$Key;Lkotlin/jvm/functions/Function1;)V
	constructor(baseKey: kotlin.coroutines.CoroutineContext.Key<B : kotlin.coroutines.CoroutineContext.Element>, safeCast: (@ParameterName(name = "element") kotlin.coroutines.CoroutineContext.Element) -> E : B : kotlin.coroutines.CoroutineContext.Element?)


	// *** FUNCTIONS ***

	// JVM method = isSubKey$kotlin_stdlib(Lkotlin/coroutines/CoroutineContext$Key;)Z
	internal fun isSubKey(key: kotlin.coroutines.CoroutineContext.Key<*>): Boolean

	// JVM method = tryCast$kotlin_stdlib(Lkotlin/coroutines/CoroutineContext$Element;)Lkotlin/coroutines/CoroutineContext$Element;
	internal fun tryCast(element: kotlin.coroutines.CoroutineContext.Element): E : B : kotlin.coroutines.CoroutineContext.Element?
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.coroutines.CombinedContext.Serialized : Serializable /* = java.io.Serializable */ {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = elements:[Lkotlin/coroutines/CoroutineContext;
	val elements: Array<kotlin.coroutines.CoroutineContext>


	// *** CONSTRUCTORS ***

	// JVM method = <init>([Lkotlin/coroutines/CoroutineContext;)V
	constructor(elements: Array<kotlin.coroutines.CoroutineContext>)


	// *** FUNCTIONS ***

	// JVM method = readResolve()Ljava/lang/Object;
	private fun readResolve(): Any
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.coroutines.CombinedContext : kotlin.coroutines.CoroutineContext, Serializable /* = java.io.Serializable */ {

	// *** NESTED TYPES ***

	class Serialized


	// *** PROPERTIES ***

	// JVM field = element:Lkotlin/coroutines/CoroutineContext$Element;
	private val element: kotlin.coroutines.CoroutineContext.Element

	// JVM field = left:Lkotlin/coroutines/CoroutineContext;
	private val left: kotlin.coroutines.CoroutineContext


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/coroutines/CoroutineContext;Lkotlin/coroutines/CoroutineContext$Element;)V
	constructor(left: kotlin.coroutines.CoroutineContext, element: kotlin.coroutines.CoroutineContext.Element)


	// *** FUNCTIONS ***

	// JVM method = contains(Lkotlin/coroutines/CoroutineContext$Element;)Z
	private fun contains(element: kotlin.coroutines.CoroutineContext.Element): Boolean

	// JVM method = containsAll(Lkotlin/coroutines/CombinedContext;)Z
	private fun containsAll(context: kotlin.coroutines.CombinedContext): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = fold(Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
	open fun <R> fold(initial: R, operation: (R, kotlin.coroutines.CoroutineContext.Element) -> R): R

	// JVM method = get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;
	open operator fun <E : kotlin.coroutines.CoroutineContext.Element> get(key: kotlin.coroutines.CoroutineContext.Key<E : kotlin.coroutines.CoroutineContext.Element>): E : kotlin.coroutines.CoroutineContext.Element?

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = minusKey(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext;
	open fun minusKey(key: kotlin.coroutines.CoroutineContext.Key<*>): kotlin.coroutines.CoroutineContext

	// JVM method = size()I
	private fun size(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String

	// JVM method = writeReplace()Ljava/lang/Object;
	private fun writeReplace(): Any
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.coroutines.ContinuationKt$Continuation$1 : kotlin.coroutines.Continuation<T#0> {

	// *** PROPERTIES ***

	open val context: kotlin.coroutines.CoroutineContext
		// JVM method = getContext()Lkotlin/coroutines/CoroutineContext;
		get() = /* non-default */


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = resumeWith(Ljava/lang/Object;)V
	open fun resumeWith(result: Result<T#0>)
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.coroutines.SafeContinuation<in T> : kotlin.coroutines.Continuation<in T>, kotlin.coroutines.jvm.internal.CoroutineStackFrame {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	open val callerFrame: kotlin.coroutines.jvm.internal.CoroutineStackFrame?
		// JVM method = getCallerFrame()Lkotlin/coroutines/jvm/internal/CoroutineStackFrame;
		get() = /* non-default */

	open val context: kotlin.coroutines.CoroutineContext
		// JVM method = getContext()Lkotlin/coroutines/CoroutineContext;
		get() = /* non-default */

	// JVM field = delegate:Lkotlin/coroutines/Continuation;
	private val delegate: kotlin.coroutines.Continuation<in T>

	// JVM field = result:Ljava/lang/Object;
	private var result: Any?


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/coroutines/Continuation;)V
	internal /* secondary */ constructor(delegate: kotlin.coroutines.Continuation<in T>)

	// JVM method = <init>(Lkotlin/coroutines/Continuation;Ljava/lang/Object;)V
	internal constructor(delegate: kotlin.coroutines.Continuation<in T>, initialResult: Any?)


	// *** FUNCTIONS ***

	// JVM method = getOrThrow()Ljava/lang/Object;
	internal fun getOrThrow(): Any?

	// JVM method = getStackTraceElement()Ljava/lang/StackTraceElement;
	open fun getStackTraceElement(): java.lang.StackTraceElement?

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = resumeWith(Ljava/lang/Object;)V
	open fun resumeWith(result: Result<in T>)

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineFromSuspendFunction$1 : kotlin.coroutines.jvm.internal.RestrictedContinuationImpl {

	// *** PROPERTIES ***

	// JVM field = label:I
	private var label: Int


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = invokeSuspend(Ljava/lang/Object;)Ljava/lang/Object;
	protected open fun invokeSuspend(result: Result<Any?>): Any?
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineFromSuspendFunction$2 : kotlin.coroutines.jvm.internal.ContinuationImpl {

	// *** PROPERTIES ***

	// JVM field = label:I
	private var label: Int


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = invokeSuspend(Ljava/lang/Object;)Ljava/lang/Object;
	protected open fun invokeSuspend(result: Result<Any?>): Any?
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineFromSuspendFunction$1
/* local */ class kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineFromSuspendFunction$1 : kotlin.coroutines.jvm.internal.RestrictedContinuationImpl {

	// *** PROPERTIES ***

	// JVM field = label:I
	private var label: Int


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = invokeSuspend(Ljava/lang/Object;)Ljava/lang/Object;
	protected open fun invokeSuspend(result: Result<Any?>): Any?
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineFromSuspendFunction$2
/* local */ class kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineFromSuspendFunction$2 : kotlin.coroutines.jvm.internal.ContinuationImpl {

	// *** PROPERTIES ***

	// JVM field = label:I
	private var label: Int


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = invokeSuspend(Ljava/lang/Object;)Ljava/lang/Object;
	protected open fun invokeSuspend(result: Result<Any?>): Any?
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineFromSuspendFunction$1
/* local */ class kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineFromSuspendFunction$1 : kotlin.coroutines.jvm.internal.RestrictedContinuationImpl {

	// *** PROPERTIES ***

	// JVM field = label:I
	private var label: Int


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = invokeSuspend(Ljava/lang/Object;)Ljava/lang/Object;
	protected open fun invokeSuspend(result: Result<Any?>): Any?
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineFromSuspendFunction$2
/* local */ class kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt$createCoroutineFromSuspendFunction$2 : kotlin.coroutines.jvm.internal.ContinuationImpl {

	// *** PROPERTIES ***

	// JVM field = label:I
	private var label: Int


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = invokeSuspend(Ljava/lang/Object;)Ljava/lang/Object;
	protected open fun invokeSuspend(result: Result<Any?>): Any?
}

// ------------------------------------------------------------------------------------------------------

internal abstract class kotlin.coroutines.jvm.internal.BaseContinuationImpl :
	kotlin.coroutines.Continuation<Any?>,
	kotlin.coroutines.jvm.internal.CoroutineStackFrame,
	java.io.Serializable {

	// *** PROPERTIES ***

	open val callerFrame: kotlin.coroutines.jvm.internal.CoroutineStackFrame?
		// JVM method = getCallerFrame()Lkotlin/coroutines/jvm/internal/CoroutineStackFrame;
		get() = /* non-default */

	// JVM field = completion:Lkotlin/coroutines/Continuation;
	val completion: kotlin.coroutines.Continuation<Any?>?


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/coroutines/Continuation;)V
	constructor(completion: kotlin.coroutines.Continuation<Any?>?)


	// *** FUNCTIONS ***

	// JVM method = create(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation;
	open fun create(value: Any?, completion: kotlin.coroutines.Continuation<*>): kotlin.coroutines.Continuation<Unit>

	// JVM method = create(Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation;
	open fun create(completion: kotlin.coroutines.Continuation<*>): kotlin.coroutines.Continuation<Unit>

	// JVM method = getStackTraceElement()Ljava/lang/StackTraceElement;
	open fun getStackTraceElement(): java.lang.StackTraceElement?

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = invokeSuspend(Ljava/lang/Object;)Ljava/lang/Object;
	protected abstract fun invokeSuspend(result: Result<Any?>): Any?

	// JVM method = releaseIntercepted()V
	protected open fun releaseIntercepted()

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = resumeWith(Ljava/lang/Object;)V
	fun resumeWith(result: Result<Any?>)

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal abstract class kotlin.coroutines.jvm.internal.ContinuationImpl : kotlin.coroutines.jvm.internal.BaseContinuationImpl {

	// *** PROPERTIES ***

	// JVM field = _context:Lkotlin/coroutines/CoroutineContext;
	private val _context: kotlin.coroutines.CoroutineContext?

	open val context: kotlin.coroutines.CoroutineContext
		// JVM method = getContext()Lkotlin/coroutines/CoroutineContext;
		get() = /* non-default */

	// JVM field = intercepted:Lkotlin/coroutines/Continuation;
	private var intercepted: kotlin.coroutines.Continuation<Any?>?


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/coroutines/Continuation;)V
	/* secondary */ constructor(completion: kotlin.coroutines.Continuation<Any?>?)

	// JVM method = <init>(Lkotlin/coroutines/Continuation;Lkotlin/coroutines/CoroutineContext;)V
	constructor(completion: kotlin.coroutines.Continuation<Any?>?, _context: kotlin.coroutines.CoroutineContext?)


	// *** FUNCTIONS ***

	// JVM method = intercepted()Lkotlin/coroutines/Continuation;
	fun intercepted(): kotlin.coroutines.Continuation<Any?>

	// JVM method = releaseIntercepted()V
	protected open fun releaseIntercepted()
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.coroutines.jvm.internal.ModuleNameRetriever.Cache {

	// *** PROPERTIES ***

	// JVM field = getDescriptorMethod:Ljava/lang/reflect/Method;
	val getDescriptorMethod: java.lang.reflect.Method?

	// JVM field = getModuleMethod:Ljava/lang/reflect/Method;
	val getModuleMethod: java.lang.reflect.Method?

	// JVM field = nameMethod:Ljava/lang/reflect/Method;
	val nameMethod: java.lang.reflect.Method?


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/reflect/Method;Ljava/lang/reflect/Method;Ljava/lang/reflect/Method;)V
	constructor(getModuleMethod: java.lang.reflect.Method?, getDescriptorMethod: java.lang.reflect.Method?, nameMethod: java.lang.reflect.Method?)
}

// ------------------------------------------------------------------------------------------------------

internal abstract class kotlin.coroutines.jvm.internal.RestrictedContinuationImpl : kotlin.coroutines.jvm.internal.BaseContinuationImpl {

	// *** PROPERTIES ***

	open val context: kotlin.coroutines.CoroutineContext
		// JVM method = getContext()Lkotlin/coroutines/CoroutineContext;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/coroutines/Continuation;)V
	constructor(completion: kotlin.coroutines.Continuation<Any?>?)
}

// ------------------------------------------------------------------------------------------------------

internal abstract class kotlin.coroutines.jvm.internal.RestrictedSuspendLambda :
	kotlin.coroutines.jvm.internal.RestrictedContinuationImpl,
	kotlin.jvm.internal.FunctionBase<Any?>,
	kotlin.coroutines.jvm.internal.SuspendFunction {

	// *** PROPERTIES ***

	// JVM field = arity:I
	open val arity: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	/* secondary */ constructor(arity: Int)

	// JVM method = <init>(ILkotlin/coroutines/Continuation;)V
	constructor(arity: Int, completion: kotlin.coroutines.Continuation<Any?>?)


	// *** FUNCTIONS ***

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.coroutines.jvm.internal.RunSuspend : kotlin.coroutines.Continuation<Unit> {

	// *** PROPERTIES ***

	open val context: kotlin.coroutines.CoroutineContext
		// JVM method = getContext()Lkotlin/coroutines/CoroutineContext;
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = result:Lkotlin/Result;
	var result: Result<Unit>?


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = await()V
	fun await()

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = resumeWith(Ljava/lang/Object;)V
	open fun resumeWith(result: Result<Unit>)
}

// ------------------------------------------------------------------------------------------------------

internal abstract class kotlin.coroutines.jvm.internal.SuspendLambda :
	kotlin.coroutines.jvm.internal.ContinuationImpl,
	kotlin.jvm.internal.FunctionBase<Any?>,
	kotlin.coroutines.jvm.internal.SuspendFunction {

	// *** PROPERTIES ***

	// JVM field = arity:I
	open val arity: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	/* secondary */ constructor(arity: Int)

	// JVM method = <init>(ILkotlin/coroutines/Continuation;)V
	constructor(arity: Int, completion: kotlin.coroutines.Continuation<Any?>?)


	// *** FUNCTIONS ***

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.enums.EnumEntriesList<T : Enum<T>> :
	kotlin.enums.EnumEntries<T : Enum<T>>,
	AbstractList<T : Enum<T>>,
	Serializable /* = java.io.Serializable */ {

	// *** PROPERTIES ***

	// JVM field = _entries:[Ljava/lang/Enum;
	private var _entries: Array<T : Enum<T>>?

	private val entries: Array<T : Enum<T>>
		// JVM method = getEntries()[Ljava/lang/Enum;
		get() = /* non-default */

	// JVM field = entriesProvider:Lkotlin/jvm/functions/Function0;
	private val entriesProvider: () -> Array<T : Enum<T>>

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/jvm/functions/Function0;)V
	constructor(entriesProvider: () -> Array<T : Enum<T>>)


	// *** FUNCTIONS ***

	// JVM method = contains(Ljava/lang/Enum;)Z
	open operator fun contains(element: T : Enum<T>): Boolean

	// JVM method = get(I)Ljava/lang/Enum;
	open operator fun get(index: Int): T : Enum<T>

	// JVM method = indexOf(Ljava/lang/Enum;)I
	open fun indexOf(element: T : Enum<T>): Int

	// JVM method = lastIndexOf(Ljava/lang/Enum;)I
	open fun lastIndexOf(element: T : Enum<T>): Int

	// JVM method = writeReplace()Ljava/lang/Object;
	private fun writeReplace(): Any
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.enums.EnumEntriesSerializationProxy<E : Enum<E>> : Serializable /* = java.io.Serializable */ {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = c:Ljava/lang/Class;
	private val c: java.lang.Class<E : Enum<E>>


	// *** CONSTRUCTORS ***

	// JVM method = <init>([Ljava/lang/Enum;)V
	constructor(entries: Array<E : Enum<E>>)


	// *** FUNCTIONS ***

	// JVM method = readResolve()Ljava/lang/Object;
	private fun readResolve(): Any
}

// ------------------------------------------------------------------------------------------------------

internal open class kotlin.internal.PlatformImplementations {

	// *** NESTED TYPES ***

	class ReflectThrowable


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = addSuppressed(Ljava/lang/Throwable;Ljava/lang/Throwable;)V
	open fun addSuppressed(cause: Throwable, exception: Throwable)

	// JVM method = defaultPlatformRandom()Lkotlin/random/Random;
	open fun defaultPlatformRandom(): kotlin.random.Random

	// JVM method = getMatchResultNamedGroup(Ljava/util/regex/MatchResult;Ljava/lang/String;)Lkotlin/text/MatchGroup;
	open fun getMatchResultNamedGroup(matchResult: java.util.regex.MatchResult, name: String): MatchGroup?

	// JVM method = getSuppressed(Ljava/lang/Throwable;)Ljava/util/List;
	open fun getSuppressed(exception: Throwable): List<Throwable>
}

// ------------------------------------------------------------------------------------------------------

class kotlin.io.AccessDeniedException : FileSystemException {

	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/io/File;Ljava/io/File;Ljava/lang/String;)V
	constructor(file: java.io.File, other: java.io.File? /* = default */, reason: String? /* = default */)
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.io.ByteStreamsKt$iterator$1 : ByteIterator {

	// *** PROPERTIES ***

	// JVM field = finished:Z
	var finished: Boolean

	// JVM field = nextByte:I
	var nextByte: Int

	// JVM field = nextPrepared:Z
	var nextPrepared: Boolean


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextByte()B
	open fun nextByte(): Byte

	// JVM method = prepareNext()V
	private fun prepareNext()
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.io.ExposingBufferByteArrayOutputStream : java.io.ByteArrayOutputStream {

	// *** PROPERTIES ***

	val buffer: ByteArray
		// JVM method = getBuffer()[B
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(size: Int)
}

// ------------------------------------------------------------------------------------------------------

class kotlin.io.FileAlreadyExistsException : FileSystemException {

	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/io/File;Ljava/io/File;Ljava/lang/String;)V
	constructor(file: java.io.File, other: java.io.File? /* = default */, reason: String? /* = default */)
}

// ------------------------------------------------------------------------------------------------------

internal data class kotlin.io.FilePathComponents {

	// *** PROPERTIES ***

	val isRooted: Boolean
		// JVM method = isRooted()Z
		get() = /* non-default */

	// JVM field = root:Ljava/io/File;
	val root: java.io.File

	val rootName: String
		// JVM method = getRootName()Ljava/lang/String;
		get() = /* non-default */

	// JVM field = segments:Ljava/util/List;
	val segments: List<java.io.File>

	val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/io/File;Ljava/util/List;)V
	internal constructor(root: java.io.File, segments: List<java.io.File>)


	// *** FUNCTIONS ***

	// JVM method = component1()Ljava/io/File;
	/* synthesized */ operator fun component1(): java.io.File

	// JVM method = component2()Ljava/util/List;
	/* synthesized */ operator fun component2(): List<java.io.File>

	// JVM method = copy(Ljava/io/File;Ljava/util/List;)Lkotlin/io/FilePathComponents;
	/* synthesized */ fun copy(root: java.io.File /* = default */, segments: List<java.io.File> /* = default */): FilePathComponents

	// JVM method = equals(Ljava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = subPath(II)Ljava/io/File;
	fun subPath(beginIndex: Int, endIndex: Int): java.io.File

	// JVM method = toString()Ljava/lang/String;
	/* synthesized */ open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

open class kotlin.io.FileSystemException : java.io.IOException {

	// *** PROPERTIES ***

	// JVM field = file:Ljava/io/File;
	val file: java.io.File

	// JVM field = other:Ljava/io/File;
	val other: java.io.File?

	// JVM field = reason:Ljava/lang/String;
	val reason: String?


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/io/File;Ljava/io/File;Ljava/lang/String;)V
	constructor(file: java.io.File, other: java.io.File? /* = default */, reason: String? /* = default */)
}

// ------------------------------------------------------------------------------------------------------

private abstract class kotlin.io.FileTreeWalk.DirectoryState : FileTreeWalk.WalkState {

	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/io/File;)V
	constructor(rootDir: java.io.File)
}

// ------------------------------------------------------------------------------------------------------

private inner class kotlin.io.FileTreeWalk.FileTreeWalkIterator.BottomUpDirectoryState : FileTreeWalk.DirectoryState {

	// *** PROPERTIES ***

	// JVM field = failed:Z
	private var failed: Boolean

	// JVM field = fileIndex:I
	private var fileIndex: Int

	// JVM field = fileList:[Ljava/io/File;
	private var fileList: Array<java.io.File>?

	// JVM field = rootVisited:Z
	private var rootVisited: Boolean


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/io/FileTreeWalk$FileTreeWalkIterator;Ljava/io/File;)V
	constructor(rootDir: java.io.File)


	// *** FUNCTIONS ***

	// JVM method = step()Ljava/io/File;
	open fun step(): java.io.File?
}

// ------------------------------------------------------------------------------------------------------

private inner class kotlin.io.FileTreeWalk.FileTreeWalkIterator.SingleFileState : FileTreeWalk.WalkState {

	// *** PROPERTIES ***

	// JVM field = visited:Z
	private var visited: Boolean


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/io/FileTreeWalk$FileTreeWalkIterator;Ljava/io/File;)V
	constructor(rootFile: java.io.File)


	// *** FUNCTIONS ***

	// JVM method = step()Ljava/io/File;
	open fun step(): java.io.File?
}

// ------------------------------------------------------------------------------------------------------

private inner class kotlin.io.FileTreeWalk.FileTreeWalkIterator.TopDownDirectoryState : FileTreeWalk.DirectoryState {

	// *** PROPERTIES ***

	// JVM field = fileIndex:I
	private var fileIndex: Int

	// JVM field = fileList:[Ljava/io/File;
	private var fileList: Array<java.io.File>?

	// JVM field = rootVisited:Z
	private var rootVisited: Boolean


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/io/FileTreeWalk$FileTreeWalkIterator;Ljava/io/File;)V
	constructor(rootDir: java.io.File)


	// *** FUNCTIONS ***

	// JVM method = step()Ljava/io/File;
	open fun step(): java.io.File?
}

// ------------------------------------------------------------------------------------------------------

private inner class kotlin.io.FileTreeWalk.FileTreeWalkIterator : AbstractIterator<java.io.File> {

	// *** NESTED TYPES ***

	class BottomUpDirectoryState
	class SingleFileState
	class TopDownDirectoryState


	// *** PROPERTIES ***

	// JVM field = state:Ljava/util/ArrayDeque;
	private val state: java.util.ArrayDeque<FileTreeWalk.WalkState>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/io/FileTreeWalk;)V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = computeNext()V
	protected open fun computeNext()

	// JVM method = directoryState(Ljava/io/File;)Lkotlin/io/FileTreeWalk$DirectoryState;
	private fun directoryState(root: java.io.File): FileTreeWalk.DirectoryState

	// JVM method = gotoNext()Ljava/io/File;
	private tailrec fun gotoNext(): java.io.File?
}

// ------------------------------------------------------------------------------------------------------

private abstract class kotlin.io.FileTreeWalk.WalkState {

	// *** PROPERTIES ***

	// JVM field = root:Ljava/io/File;
	val root: java.io.File


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/io/File;)V
	constructor(root: java.io.File)


	// *** FUNCTIONS ***

	// JVM method = step()Ljava/io/File;
	abstract fun step(): java.io.File?
}

// ------------------------------------------------------------------------------------------------------

class kotlin.io.FileTreeWalk : Sequence<java.io.File> {

	// *** NESTED TYPES ***

	class DirectoryState
	class FileTreeWalkIterator
	class WalkState


	// *** PROPERTIES ***

	// JVM field = direction:Lkotlin/io/FileWalkDirection;
	private val direction: FileWalkDirection

	// JVM field = maxDepth:I
	private val maxDepth: Int

	// JVM field = onEnter:Lkotlin/jvm/functions/Function1;
	private val onEnter: ((java.io.File) -> Boolean)?

	// JVM field = onFail:Lkotlin/jvm/functions/Function2;
	private val onFail: ((@ParameterName(name = "f") java.io.File, @ParameterName(name = "e") java.io.IOException) -> Unit)?

	// JVM field = onLeave:Lkotlin/jvm/functions/Function1;
	private val onLeave: ((java.io.File) -> Unit)?

	// JVM field = start:Ljava/io/File;
	private val start: java.io.File


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/io/File;Lkotlin/io/FileWalkDirection;)V
	internal /* secondary */ constructor(start: java.io.File, direction: FileWalkDirection /* = default */)

	// JVM method = <init>(Ljava/io/File;Lkotlin/io/FileWalkDirection;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function2;I)V
	private constructor(start: java.io.File, direction: FileWalkDirection /* = default */, onEnter: ((java.io.File) -> Boolean)?, onLeave: ((java.io.File) -> Unit)?, onFail: ((@ParameterName(name = "f") java.io.File, @ParameterName(name = "e") java.io.IOException) -> Unit)?, maxDepth: Int /* = default */)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<java.io.File>

	// JVM method = maxDepth(I)Lkotlin/io/FileTreeWalk;
	fun maxDepth(depth: Int): FileTreeWalk

	// JVM method = onEnter(Lkotlin/jvm/functions/Function1;)Lkotlin/io/FileTreeWalk;
	fun onEnter(function: (java.io.File) -> Boolean): FileTreeWalk

	// JVM method = onFail(Lkotlin/jvm/functions/Function2;)Lkotlin/io/FileTreeWalk;
	fun onFail(function: (java.io.File, java.io.IOException) -> Unit): FileTreeWalk

	// JVM method = onLeave(Lkotlin/jvm/functions/Function1;)Lkotlin/io/FileTreeWalk;
	fun onLeave(function: (java.io.File) -> Unit): FileTreeWalk
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.io.LinesSequence$iterator$1 : Iterator<String> {

	// *** PROPERTIES ***

	// JVM field = done:Z
	private var done: Boolean

	// JVM field = nextValue:Ljava/lang/String;
	private var nextValue: String?


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/String;
	open operator fun next(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.io.LinesSequence : Sequence<String> {

	// *** PROPERTIES ***

	// JVM field = reader:Ljava/io/BufferedReader;
	private val reader: java.io.BufferedReader


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/io/BufferedReader;)V
	constructor(reader: java.io.BufferedReader)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<String>
}

// ------------------------------------------------------------------------------------------------------

class kotlin.io.NoSuchFileException : FileSystemException {

	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/io/File;Ljava/io/File;Ljava/lang/String;)V
	constructor(file: java.io.File, other: java.io.File? /* = default */, reason: String? /* = default */)
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.io.ReadAfterEOFException : RuntimeException /* = java.lang.RuntimeException */ {

	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;)V
	constructor(message: String?)
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.io.TerminateException : FileSystemException {

	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/io/File;)V
	constructor(file: java.io.File)
}

// ------------------------------------------------------------------------------------------------------

open class kotlin.io.encoding.Base64 {

	// *** NESTED TYPES ***

	companion object Default


	// *** PROPERTIES ***

	// JVM field = isMimeScheme:Z
	internal val isMimeScheme: Boolean

	// JVM field = isUrlSafe:Z
	internal val isUrlSafe: Boolean


	// *** CONSTRUCTORS ***

	// JVM method = <init>(ZZ)V
	private constructor(isUrlSafe: Boolean, isMimeScheme: Boolean)


	// *** FUNCTIONS ***

	// JVM method = bytesToStringImpl$kotlin_stdlib([B)Ljava/lang/String;
	internal fun bytesToStringImpl(source: ByteArray): String

	// JVM method = charsToBytesImpl$kotlin_stdlib(Ljava/lang/CharSequence;II)[B
	internal fun charsToBytesImpl(source: CharSequence, startIndex: Int, endIndex: Int): ByteArray

	// JVM method = checkDestinationBounds(III)V
	private fun checkDestinationBounds(destinationSize: Int, destinationOffset: Int, capacityNeeded: Int)

	// JVM method = checkSourceBounds$kotlin_stdlib(III)V
	internal fun checkSourceBounds(sourceSize: Int, startIndex: Int, endIndex: Int)

	// JVM method = decode([BII)[B
	fun decode(source: ByteArray, startIndex: Int /* = default */, endIndex: Int /* = default */): ByteArray

	// JVM method = decode(Ljava/lang/CharSequence;II)[B
	fun decode(source: CharSequence, startIndex: Int /* = default */, endIndex: Int /* = default */): ByteArray

	// JVM method = decodeImpl([B[BIII)I
	private fun decodeImpl(source: ByteArray, destination: ByteArray, destinationOffset: Int, startIndex: Int, endIndex: Int): Int

	// JVM method = decodeIntoByteArray([B[BIII)I
	fun decodeIntoByteArray(source: ByteArray, destination: ByteArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): Int

	// JVM method = decodeIntoByteArray(Ljava/lang/CharSequence;[BIII)I
	fun decodeIntoByteArray(source: CharSequence, destination: ByteArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): Int

	// JVM method = decodeSize([BII)I
	private fun decodeSize(source: ByteArray, startIndex: Int, endIndex: Int): Int

	// JVM method = encode([BII)Ljava/lang/String;
	fun encode(source: ByteArray, startIndex: Int /* = default */, endIndex: Int /* = default */): String

	// JVM method = encodeIntoByteArray([B[BIII)I
	fun encodeIntoByteArray(source: ByteArray, destination: ByteArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): Int

	// JVM method = encodeIntoByteArrayImpl$kotlin_stdlib([B[BIII)I
	internal fun encodeIntoByteArrayImpl(source: ByteArray, destination: ByteArray, destinationOffset: Int, startIndex: Int, endIndex: Int): Int

	// JVM method = encodeSize(I)I
	private fun encodeSize(sourceSize: Int): Int

	// JVM method = encodeToAppendable([BLjava/lang/Appendable;II)Ljava/lang/Appendable;
	fun <A : Appendable /* = java.lang.Appendable */> encodeToAppendable(source: ByteArray, destination: A : Appendable /* = java.lang.Appendable */, startIndex: Int /* = default */, endIndex: Int /* = default */): A : Appendable /* = java.lang.Appendable */

	// JVM method = encodeToByteArray([BII)[B
	fun encodeToByteArray(source: ByteArray, startIndex: Int /* = default */, endIndex: Int /* = default */): ByteArray

	// JVM method = encodeToByteArrayImpl$kotlin_stdlib([BII)[B
	internal fun encodeToByteArrayImpl(source: ByteArray, startIndex: Int, endIndex: Int): ByteArray

	// JVM method = handlePaddingSymbol([BIII)I
	private fun handlePaddingSymbol(source: ByteArray, padIndex: Int, endIndex: Int, byteStart: Int): Int

	// JVM method = skipIllegalSymbolsIfMime([BII)I
	private fun skipIllegalSymbolsIfMime(source: ByteArray, startIndex: Int, endIndex: Int): Int
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.io.encoding.DecodeInputStream : java.io.InputStream {

	// *** PROPERTIES ***

	// JVM field = base64:Lkotlin/io/encoding/Base64;
	private val base64: kotlin.io.encoding.Base64

	// JVM field = byteBuffer:[B
	private val byteBuffer: ByteArray

	// JVM field = byteBufferEndIndex:I
	private var byteBufferEndIndex: Int

	private val byteBufferLength: Int
		// JVM method = getByteBufferLength()I
		get() = /* non-default */

	// JVM field = byteBufferStartIndex:I
	private var byteBufferStartIndex: Int

	// JVM field = input:Ljava/io/InputStream;
	private val input: java.io.InputStream

	// JVM field = isClosed:Z
	private var isClosed: Boolean

	// JVM field = isEOF:Z
	private var isEOF: Boolean

	// JVM field = singleByteBuffer:[B
	private val singleByteBuffer: ByteArray

	// JVM field = symbolBuffer:[B
	private val symbolBuffer: ByteArray


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/io/InputStream;Lkotlin/io/encoding/Base64;)V
	constructor(input: java.io.InputStream, base64: kotlin.io.encoding.Base64)


	// *** FUNCTIONS ***

	// JVM method = close()V
	open fun close()

	// JVM method = copyByteBufferInto([BII)V
	private fun copyByteBufferInto(dst: ByteArray, dstOffset: Int, length: Int)

	// JVM method = decodeSymbolBufferInto([BIII)I
	private fun decodeSymbolBufferInto(dst: ByteArray, dstOffset: Int, dstEndIndex: Int, symbolBufferLength: Int): Int

	// JVM method = handlePaddingSymbol(I)I
	private fun handlePaddingSymbol(symbolBufferLength: Int): Int

	// JVM method = read()I
	open fun read(): Int

	// JVM method = read([BII)I
	open fun read(destination: ByteArray, offset: Int, length: Int): Int

	// JVM method = readNextSymbol()I
	private fun readNextSymbol(): Int

	// JVM method = resetByteBufferIfEmpty()V
	private fun resetByteBufferIfEmpty()

	// JVM method = shiftByteBufferToStartIfNeeded()V
	private fun shiftByteBufferToStartIfNeeded()
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.io.encoding.EncodeOutputStream : java.io.OutputStream {

	// *** PROPERTIES ***

	// JVM field = base64:Lkotlin/io/encoding/Base64;
	private val base64: kotlin.io.encoding.Base64

	// JVM field = byteBuffer:[B
	private val byteBuffer: ByteArray

	// JVM field = byteBufferLength:I
	private var byteBufferLength: Int

	// JVM field = isClosed:Z
	private var isClosed: Boolean

	// JVM field = lineLength:I
	private var lineLength: Int

	// JVM field = output:Ljava/io/OutputStream;
	private val output: java.io.OutputStream

	// JVM field = symbolBuffer:[B
	private val symbolBuffer: ByteArray


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/io/OutputStream;Lkotlin/io/encoding/Base64;)V
	constructor(output: java.io.OutputStream, base64: kotlin.io.encoding.Base64)


	// *** FUNCTIONS ***

	// JVM method = checkOpen()V
	private fun checkOpen()

	// JVM method = close()V
	open fun close()

	// JVM method = copyIntoByteBuffer([BII)I
	private fun copyIntoByteBuffer(source: ByteArray, startIndex: Int, endIndex: Int): Int

	// JVM method = encodeByteBufferIntoOutput()V
	private fun encodeByteBufferIntoOutput()

	// JVM method = encodeIntoOutput([BII)I
	private fun encodeIntoOutput(source: ByteArray, startIndex: Int, endIndex: Int): Int

	// JVM method = flush()V
	open fun flush()

	// JVM method = write([BII)V
	open fun write(source: ByteArray, offset: Int, length: Int)

	// JVM method = write(I)V
	open fun write(b: Int)
}

// ------------------------------------------------------------------------------------------------------

open class kotlin.jvm.KotlinReflectionNotSupportedError : java.lang.Error {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	/* secondary */ constructor()

	// JVM method = <init>(Ljava/lang/String;)V
	/* secondary */ constructor(message: String?)

	// JVM method = <init>(Ljava/lang/String;Ljava/lang/Throwable;)V
	/* secondary */ constructor(message: String?, cause: Throwable?)

	// JVM method = <init>(Ljava/lang/Throwable;)V
	/* secondary */ constructor(cause: Throwable?)
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.jvm.internal.ArrayBooleanIterator : BooleanIterator {

	// *** PROPERTIES ***

	// JVM field = array:[Z
	private val array: BooleanArray

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([Z)V
	constructor(array: BooleanArray)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextBoolean()Z
	open fun nextBoolean(): Boolean
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.jvm.internal.ArrayByteIterator : ByteIterator {

	// *** PROPERTIES ***

	// JVM field = array:[B
	private val array: ByteArray

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([B)V
	constructor(array: ByteArray)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextByte()B
	open fun nextByte(): Byte
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.jvm.internal.ArrayCharIterator : CharIterator {

	// *** PROPERTIES ***

	// JVM field = array:[C
	private val array: CharArray

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([C)V
	constructor(array: CharArray)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextChar()C
	open fun nextChar(): Char
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.jvm.internal.ArrayDoubleIterator : DoubleIterator {

	// *** PROPERTIES ***

	// JVM field = array:[D
	private val array: DoubleArray

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([D)V
	constructor(array: DoubleArray)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextDouble()D
	open fun nextDouble(): Double
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.jvm.internal.ArrayFloatIterator : FloatIterator {

	// *** PROPERTIES ***

	// JVM field = array:[F
	private val array: FloatArray

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([F)V
	constructor(array: FloatArray)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextFloat()F
	open fun nextFloat(): Float
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.jvm.internal.ArrayIntIterator : IntIterator {

	// *** PROPERTIES ***

	// JVM field = array:[I
	private val array: IntArray

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([I)V
	constructor(array: IntArray)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextInt()I
	open fun nextInt(): Int
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.jvm.internal.ArrayIterator<T> : Iterator<T> {

	// *** PROPERTIES ***

	// JVM field = array:[Ljava/lang/Object;
	val array: Array<T>

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([Ljava/lang/Object;)V
	constructor(array: Array<T>)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.jvm.internal.ArrayLongIterator : LongIterator {

	// *** PROPERTIES ***

	// JVM field = array:[J
	private val array: LongArray

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([J)V
	constructor(array: LongArray)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextLong()J
	open fun nextLong(): Long
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.jvm.internal.ArrayShortIterator : ShortIterator {

	// *** PROPERTIES ***

	// JVM field = array:[S
	private val array: ShortArray

	// JVM field = index:I
	private var index: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>([S)V
	constructor(array: ShortArray)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextShort()S
	open fun nextShort(): Short
}

// ------------------------------------------------------------------------------------------------------

class kotlin.jvm.internal.BooleanSpreadBuilder : kotlin.jvm.internal.PrimitiveSpreadBuilder<BooleanArray> {

	// *** PROPERTIES ***

	// JVM field = values:[Z
	private val values: BooleanArray


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(size: Int)


	// *** FUNCTIONS ***

	// JVM method = add(Z)V
	fun add(value: Boolean)

	// JVM method = toArray()[Z
	fun toArray(): BooleanArray

	// JVM method = getSize([Z)I
	protected open fun BooleanArray.getSize(): Int
}

// ------------------------------------------------------------------------------------------------------

class kotlin.jvm.internal.ByteSpreadBuilder : kotlin.jvm.internal.PrimitiveSpreadBuilder<ByteArray> {

	// *** PROPERTIES ***

	// JVM field = values:[B
	private val values: ByteArray


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(size: Int)


	// *** FUNCTIONS ***

	// JVM method = add(B)V
	fun add(value: Byte)

	// JVM method = toArray()[B
	fun toArray(): ByteArray

	// JVM method = getSize([B)I
	protected open fun ByteArray.getSize(): Int
}

// ------------------------------------------------------------------------------------------------------

class kotlin.jvm.internal.CharSpreadBuilder : kotlin.jvm.internal.PrimitiveSpreadBuilder<CharArray> {

	// *** PROPERTIES ***

	// JVM field = values:[C
	private val values: CharArray


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(size: Int)


	// *** FUNCTIONS ***

	// JVM method = add(C)V
	fun add(value: Char)

	// JVM method = toArray()[C
	fun toArray(): CharArray

	// JVM method = getSize([C)I
	protected open fun CharArray.getSize(): Int
}

// ------------------------------------------------------------------------------------------------------

class kotlin.jvm.internal.ClassReference : kotlin.reflect.KClass<Any>, kotlin.jvm.internal.ClassBasedDeclarationContainer {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	open val annotations: List<Annotation>
		// JVM method = getAnnotations()Ljava/util/List;
		get() = /* non-default */

	open val constructors: Collection<kotlin.reflect.KFunction<Any>>
		// JVM method = getConstructors()Ljava/util/Collection;
		get() = /* non-default */

	// JVM annotation-holding method = isAbstract$annotations()V
	open val isAbstract: Boolean
		// JVM method = isAbstract()Z
		get() = /* non-default */

	// JVM annotation-holding method = isCompanion$annotations()V
	open val isCompanion: Boolean
		// JVM method = isCompanion()Z
		get() = /* non-default */

	// JVM annotation-holding method = isData$annotations()V
	open val isData: Boolean
		// JVM method = isData()Z
		get() = /* non-default */

	// JVM annotation-holding method = isFinal$annotations()V
	open val isFinal: Boolean
		// JVM method = isFinal()Z
		get() = /* non-default */

	// JVM annotation-holding method = isFun$annotations()V
	open val isFun: Boolean
		// JVM method = isFun()Z
		get() = /* non-default */

	// JVM annotation-holding method = isInner$annotations()V
	open val isInner: Boolean
		// JVM method = isInner()Z
		get() = /* non-default */

	// JVM annotation-holding method = isOpen$annotations()V
	open val isOpen: Boolean
		// JVM method = isOpen()Z
		get() = /* non-default */

	// JVM annotation-holding method = isSealed$annotations()V
	open val isSealed: Boolean
		// JVM method = isSealed()Z
		get() = /* non-default */

	// JVM annotation-holding method = isValue$annotations()V
	open val isValue: Boolean
		// JVM method = isValue()Z
		get() = /* non-default */

	// JVM field = jClass:Ljava/lang/Class;
	open val jClass: java.lang.Class<*>

	open val members: Collection<kotlin.reflect.KCallable<*>>
		// JVM method = getMembers()Ljava/util/Collection;
		get() = /* non-default */

	open val nestedClasses: Collection<kotlin.reflect.KClass<*>>
		// JVM method = getNestedClasses()Ljava/util/Collection;
		get() = /* non-default */

	open val objectInstance: Any?
		// JVM method = getObjectInstance()Ljava/lang/Object;
		get() = /* non-default */

	open val qualifiedName: String?
		// JVM method = getQualifiedName()Ljava/lang/String;
		get() = /* non-default */

	// JVM annotation-holding method = getSealedSubclasses$annotations()V
	open val sealedSubclasses: List<kotlin.reflect.KClass<out Any>>
		// JVM method = getSealedSubclasses()Ljava/util/List;
		get() = /* non-default */

	open val simpleName: String?
		// JVM method = getSimpleName()Ljava/lang/String;
		get() = /* non-default */

	// JVM annotation-holding method = getSupertypes$annotations()V
	open val supertypes: List<kotlin.reflect.KType>
		// JVM method = getSupertypes()Ljava/util/List;
		get() = /* non-default */

	// JVM annotation-holding method = getTypeParameters$annotations()V
	open val typeParameters: List<kotlin.reflect.KTypeParameter>
		// JVM method = getTypeParameters()Ljava/util/List;
		get() = /* non-default */

	// JVM annotation-holding method = getVisibility$annotations()V
	open val visibility: kotlin.reflect.KVisibility?
		// JVM method = getVisibility()Lkotlin/reflect/KVisibility;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/Class;)V
	constructor(jClass: java.lang.Class<*>)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = error()Ljava/lang/Void;
	private fun error(): Nothing

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isInstance(Ljava/lang/Object;)Z
	open fun isInstance(value: Any?): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

class kotlin.jvm.internal.DoubleSpreadBuilder : kotlin.jvm.internal.PrimitiveSpreadBuilder<DoubleArray> {

	// *** PROPERTIES ***

	// JVM field = values:[D
	private val values: DoubleArray


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(size: Int)


	// *** FUNCTIONS ***

	// JVM method = add(D)V
	fun add(value: Double)

	// JVM method = toArray()[D
	fun toArray(): DoubleArray

	// JVM method = getSize([D)I
	protected open fun DoubleArray.getSize(): Int
}

// ------------------------------------------------------------------------------------------------------

class kotlin.jvm.internal.FloatSpreadBuilder : kotlin.jvm.internal.PrimitiveSpreadBuilder<FloatArray> {

	// *** PROPERTIES ***

	// JVM field = values:[F
	private val values: FloatArray


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(size: Int)


	// *** FUNCTIONS ***

	// JVM method = add(F)V
	fun add(value: Float)

	// JVM method = toArray()[F
	fun toArray(): FloatArray

	// JVM method = getSize([F)I
	protected open fun FloatArray.getSize(): Int
}

// ------------------------------------------------------------------------------------------------------

class kotlin.jvm.internal.IntSpreadBuilder : kotlin.jvm.internal.PrimitiveSpreadBuilder<IntArray> {

	// *** PROPERTIES ***

	// JVM field = values:[I
	private val values: IntArray


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(size: Int)


	// *** FUNCTIONS ***

	// JVM method = add(I)V
	fun add(value: Int)

	// JVM method = toArray()[I
	fun toArray(): IntArray

	// JVM method = getSize([I)I
	protected open fun IntArray.getSize(): Int
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.jvm.internal.Lambda<out R> : kotlin.jvm.internal.FunctionBase<out R>, java.io.Serializable {

	// *** PROPERTIES ***

	// JVM field = arity:I
	open val arity: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(arity: Int)


	// *** FUNCTIONS ***

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

open class kotlin.jvm.internal.LocalVariableReference : kotlin.jvm.internal.PropertyReference0 {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = get()Ljava/lang/Object;
	open fun get(): Any?

	// JVM method = getOwner()Lkotlin/reflect/KDeclarationContainer;
	open fun getOwner(): kotlin.reflect.KDeclarationContainer
}

// ------------------------------------------------------------------------------------------------------

class kotlin.jvm.internal.LongSpreadBuilder : kotlin.jvm.internal.PrimitiveSpreadBuilder<LongArray> {

	// *** PROPERTIES ***

	// JVM field = values:[J
	private val values: LongArray


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(size: Int)


	// *** FUNCTIONS ***

	// JVM method = add(J)V
	fun add(value: Long)

	// JVM method = toArray()[J
	fun toArray(): LongArray

	// JVM method = getSize([J)I
	protected open fun LongArray.getSize(): Int
}

// ------------------------------------------------------------------------------------------------------

open class kotlin.jvm.internal.MutableLocalVariableReference : kotlin.jvm.internal.MutablePropertyReference0 {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = get()Ljava/lang/Object;
	open fun get(): Any?

	// JVM method = getOwner()Lkotlin/reflect/KDeclarationContainer;
	open fun getOwner(): kotlin.reflect.KDeclarationContainer

	// JVM method = set(Ljava/lang/Object;)V
	open fun set(value: Any?)
}

// ------------------------------------------------------------------------------------------------------

class kotlin.jvm.internal.PackageReference : kotlin.jvm.internal.ClassBasedDeclarationContainer {

	// *** PROPERTIES ***

	// JVM field = jClass:Ljava/lang/Class;
	open val jClass: java.lang.Class<*>

	open val members: Collection<kotlin.reflect.KCallable<*>>
		// JVM method = getMembers()Ljava/util/Collection;
		get() = /* non-default */

	// JVM field = moduleName:Ljava/lang/String;
	private val moduleName: String


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/Class;Ljava/lang/String;)V
	constructor(jClass: java.lang.Class<*>, moduleName: String)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.jvm.internal.PrimitiveSpreadBuilder<T : Any> {

	// *** PROPERTIES ***

	// JVM field = position:I
	protected var position: Int

	// JVM field = size:I
	private val size: Int

	// JVM field = spreads:[Ljava/lang/Object;
	// JVM annotation-holding method = getSpreads$annotations()V
	private val spreads: Array<T : Any?>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(size: Int)


	// *** FUNCTIONS ***

	// JVM method = addSpread(Ljava/lang/Object;)V
	fun addSpread(spreadArgument: T : Any)

	// JVM method = size()I
	protected fun size(): Int

	// JVM method = toArray(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	protected fun toArray(values: T : Any, result: T : Any): T : Any

	// JVM method = getSize(Ljava/lang/Object;)I
	protected abstract fun T : Any.getSize(): Int
}

// ------------------------------------------------------------------------------------------------------

class kotlin.jvm.internal.ShortSpreadBuilder : kotlin.jvm.internal.PrimitiveSpreadBuilder<ShortArray> {

	// *** PROPERTIES ***

	// JVM field = values:[S
	private val values: ShortArray


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(size: Int)


	// *** FUNCTIONS ***

	// JVM method = add(S)V
	fun add(value: Short)

	// JVM method = toArray()[S
	fun toArray(): ShortArray

	// JVM method = getSize([S)I
	protected open fun ShortArray.getSize(): Int
}

// ------------------------------------------------------------------------------------------------------

class kotlin.jvm.internal.TypeParameterReference : kotlin.reflect.KTypeParameter {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = bounds:Ljava/util/List;
	private var bounds: List<kotlin.reflect.KType>?

	// JVM field = container:Ljava/lang/Object;
	private val container: Any?

	// JVM field = isReified:Z
	open val isReified: Boolean

	// JVM field = name:Ljava/lang/String;
	open val name: String

	// JVM annotation-holding method = getUpperBounds$annotations()V
	open val upperBounds: List<kotlin.reflect.KType>
		// JVM method = getUpperBounds()Ljava/util/List;
		get() = /* non-default */

	// JVM field = variance:Lkotlin/reflect/KVariance;
	open val variance: kotlin.reflect.KVariance


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/Object;Ljava/lang/String;Lkotlin/reflect/KVariance;Z)V
	constructor(container: Any?, name: String, variance: kotlin.reflect.KVariance, isReified: Boolean)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = setUpperBounds(Ljava/util/List;)V
	fun setUpperBounds(upperBounds: List<kotlin.reflect.KType>)

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

class kotlin.jvm.internal.TypeReference : kotlin.reflect.KType {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	open val annotations: List<Annotation>
		// JVM method = getAnnotations()Ljava/util/List;
		get() = /* non-default */

	// JVM field = arguments:Ljava/util/List;
	open val arguments: List<kotlin.reflect.KTypeProjection>

	// JVM field = classifier:Lkotlin/reflect/KClassifier;
	open val classifier: kotlin.reflect.KClassifier

	// JVM field = flags:I
	// JVM annotation-holding method = getFlags$kotlin_stdlib$annotations()V
	internal val flags: Int

	open val isMarkedNullable: Boolean
		// JVM method = isMarkedNullable()Z
		get() = /* non-default */

	// JVM field = platformTypeUpperBound:Lkotlin/reflect/KType;
	// JVM annotation-holding method = getPlatformTypeUpperBound$kotlin_stdlib$annotations()V
	internal val platformTypeUpperBound: kotlin.reflect.KType?

	private val java.lang.Class<*>.arrayClassName: String
		// JVM method = getArrayClassName(Ljava/lang/Class;)Ljava/lang/String;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/reflect/KClassifier;Ljava/util/List;Z)V
	/* secondary */ constructor(classifier: kotlin.reflect.KClassifier, arguments: List<kotlin.reflect.KTypeProjection>, isMarkedNullable: Boolean)

	// JVM method = <init>(Lkotlin/reflect/KClassifier;Ljava/util/List;Lkotlin/reflect/KType;I)V
	constructor(classifier: kotlin.reflect.KClassifier, arguments: List<kotlin.reflect.KTypeProjection>, platformTypeUpperBound: kotlin.reflect.KType?, flags: Int)


	// *** FUNCTIONS ***

	// JVM method = asString(Z)Ljava/lang/String;
	private fun asString(convertPrimitiveToWrapper: Boolean): String

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String

	// JVM method = asString(Lkotlin/reflect/KTypeProjection;)Ljava/lang/String;
	private fun kotlin.reflect.KTypeProjection.asString(): String
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.properties.Delegates$observable$1 : kotlin.properties.ObservableProperty<T#0> {

	// *** FUNCTIONS ***

	// JVM method = afterChange(Lkotlin/reflect/KProperty;Ljava/lang/Object;Ljava/lang/Object;)V
	protected open fun afterChange(property: kotlin.reflect.KProperty<*>, oldValue: T#0, newValue: T#0)
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.properties.Delegates$vetoable$1 : kotlin.properties.ObservableProperty<T#0> {

	// *** FUNCTIONS ***

	// JVM method = beforeChange(Lkotlin/reflect/KProperty;Ljava/lang/Object;Ljava/lang/Object;)Z
	protected open fun beforeChange(property: kotlin.reflect.KProperty<*>, oldValue: T#0, newValue: T#0): Boolean
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.properties.NotNullVar<T : Any> : kotlin.properties.ReadWriteProperty<Any?, T : Any> {

	// *** PROPERTIES ***

	// JVM field = value:Ljava/lang/Object;
	private var value: T : Any?


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = getValue(Ljava/lang/Object;Lkotlin/reflect/KProperty;)Ljava/lang/Object;
	open operator fun getValue(thisRef: Any?, property: kotlin.reflect.KProperty<*>): T : Any

	// JVM method = setValue(Ljava/lang/Object;Lkotlin/reflect/KProperty;Ljava/lang/Object;)V
	open operator fun setValue(thisRef: Any?, property: kotlin.reflect.KProperty<*>, value: T : Any)
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.properties.ObservableProperty<V> : kotlin.properties.ReadWriteProperty<Any?, V> {

	// *** PROPERTIES ***

	// JVM field = value:Ljava/lang/Object;
	private var value: V


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/Object;)V
	constructor(initialValue: V)


	// *** FUNCTIONS ***

	// JVM method = afterChange(Lkotlin/reflect/KProperty;Ljava/lang/Object;Ljava/lang/Object;)V
	protected open fun afterChange(property: kotlin.reflect.KProperty<*>, oldValue: V, newValue: V)

	// JVM method = beforeChange(Lkotlin/reflect/KProperty;Ljava/lang/Object;Ljava/lang/Object;)Z
	protected open fun beforeChange(property: kotlin.reflect.KProperty<*>, oldValue: V, newValue: V): Boolean

	// JVM method = getValue(Ljava/lang/Object;Lkotlin/reflect/KProperty;)Ljava/lang/Object;
	open operator fun getValue(thisRef: Any?, property: kotlin.reflect.KProperty<*>): V

	// JVM method = setValue(Ljava/lang/Object;Lkotlin/reflect/KProperty;Ljava/lang/Object;)V
	open operator fun setValue(thisRef: Any?, property: kotlin.reflect.KProperty<*>, value: V)
}

// ------------------------------------------------------------------------------------------------------

internal abstract class kotlin.random.AbstractPlatformRandom : kotlin.random.Random {

	// *** PROPERTIES ***

	abstract val impl: java.util.Random


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = nextBits(I)I
	open fun nextBits(bitCount: Int): Int

	// JVM method = nextBoolean()Z
	open fun nextBoolean(): Boolean

	// JVM method = nextBytes([B)[B
	open fun nextBytes(array: ByteArray): ByteArray

	// JVM method = nextDouble()D
	open fun nextDouble(): Double

	// JVM method = nextFloat()F
	open fun nextFloat(): Float

	// JVM method = nextInt()I
	open fun nextInt(): Int

	// JVM method = nextInt(I)I
	open fun nextInt(until: Int): Int

	// JVM method = nextLong()J
	open fun nextLong(): Long
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.random.FallbackThreadLocalRandom$implStorage$1 : java.lang.ThreadLocal<java.util.Random> {

	// *** FUNCTIONS ***

	// JVM method = initialValue()Ljava/util/Random;
	protected open fun initialValue(): java.util.Random
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.random.FallbackThreadLocalRandom : kotlin.random.AbstractPlatformRandom {

	// *** PROPERTIES ***

	open val impl: java.util.Random
		// JVM method = getImpl()Ljava/util/Random;
		get() = /* non-default */

	// JVM field = implStorage:Lkotlin/random/FallbackThreadLocalRandom$implStorage$1;
	private val implStorage: kotlin.random.FallbackThreadLocalRandom$implStorage$1


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.random.KotlinRandom : java.util.Random {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = impl:Lkotlin/random/Random;
	val impl: kotlin.random.Random

	// JVM field = seedInitialized:Z
	private var seedInitialized: Boolean


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/random/Random;)V
	constructor(impl: kotlin.random.Random)


	// *** FUNCTIONS ***

	// JVM method = next(I)I
	protected open fun next(bits: Int): Int

	// JVM method = nextBoolean()Z
	open fun nextBoolean(): Boolean

	// JVM method = nextBytes([B)V
	open fun nextBytes(bytes: ByteArray)

	// JVM method = nextDouble()D
	open fun nextDouble(): Double

	// JVM method = nextFloat()F
	open fun nextFloat(): Float

	// JVM method = nextInt()I
	open fun nextInt(): Int

	// JVM method = nextInt(I)I
	open fun nextInt(bound: Int): Int

	// JVM method = nextLong()J
	open fun nextLong(): Long

	// JVM method = setSeed(J)V
	open fun setSeed(seed: Long)
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.random.PlatformRandom : kotlin.random.AbstractPlatformRandom, Serializable /* = java.io.Serializable */ {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = impl:Ljava/util/Random;
	open val impl: java.util.Random


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/util/Random;)V
	constructor(impl: java.util.Random)
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.random.Random {

	// *** NESTED TYPES ***

	companion object Default


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = nextBits(I)I
	abstract fun nextBits(bitCount: Int): Int

	// JVM method = nextBoolean()Z
	open fun nextBoolean(): Boolean

	// JVM method = nextBytes([B)[B
	open fun nextBytes(array: ByteArray): ByteArray

	// JVM method = nextBytes([BII)[B
	open fun nextBytes(array: ByteArray, fromIndex: Int /* = default */, toIndex: Int /* = default */): ByteArray

	// JVM method = nextBytes(I)[B
	open fun nextBytes(size: Int): ByteArray

	// JVM method = nextDouble()D
	open fun nextDouble(): Double

	// JVM method = nextDouble(D)D
	open fun nextDouble(until: Double): Double

	// JVM method = nextDouble(DD)D
	open fun nextDouble(from: Double, until: Double): Double

	// JVM method = nextFloat()F
	open fun nextFloat(): Float

	// JVM method = nextInt()I
	open fun nextInt(): Int

	// JVM method = nextInt(I)I
	open fun nextInt(until: Int): Int

	// JVM method = nextInt(II)I
	open fun nextInt(from: Int, until: Int): Int

	// JVM method = nextLong()J
	open fun nextLong(): Long

	// JVM method = nextLong(J)J
	open fun nextLong(until: Long): Long

	// JVM method = nextLong(JJ)J
	open fun nextLong(from: Long, until: Long): Long
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.random.XorWowRandom : kotlin.random.Random, Serializable /* = java.io.Serializable */ {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = addend:I
	private var addend: Int

	// JVM field = v:I
	private var v: Int

	// JVM field = w:I
	private var w: Int

	// JVM field = x:I
	private var x: Int

	// JVM field = y:I
	private var y: Int

	// JVM field = z:I
	private var z: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(II)V
	internal /* secondary */ constructor(seed1: Int, seed2: Int)

	// JVM method = <init>(IIIIII)V
	internal constructor(x: Int, y: Int, z: Int, w: Int, v: Int, addend: Int)


	// *** FUNCTIONS ***

	// JVM method = nextBits(I)I
	open fun nextBits(bitCount: Int): Int

	// JVM method = nextInt()I
	open fun nextInt(): Int
}

// ------------------------------------------------------------------------------------------------------

open class kotlin.ranges.CharProgression : Iterable<Char> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = first:C
	val first: Char

	// JVM field = last:C
	val last: Char

	// JVM field = step:I
	val step: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(CCI)V
	internal constructor(start: Char, endInclusive: Char, step: Int)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Lkotlin/collections/CharIterator;
	open operator fun iterator(): CharIterator

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.ranges.CharProgressionIterator : CharIterator {

	// *** PROPERTIES ***

	// JVM field = finalElement:I
	private val finalElement: Int

	// JVM field = hasNext:Z
	private var hasNext: Boolean

	// JVM field = next:I
	private var next: Int

	// JVM field = step:I
	val step: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(CCI)V
	constructor(first: Char, last: Char, step: Int)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextChar()C
	open fun nextChar(): Char
}

// ------------------------------------------------------------------------------------------------------

class kotlin.ranges.CharRange :
	CharProgression,
	ClosedRange<Char>,
	OpenEndRange<Char> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM annotation-holding method = getEndExclusive$annotations()V
	open val endExclusive: Char
		// JVM method = getEndExclusive()Ljava/lang/Character;
		get() = /* non-default */

	open val endInclusive: Char
		// JVM method = getEndInclusive()Ljava/lang/Character;
		get() = /* non-default */

	open val start: Char
		// JVM method = getStart()Ljava/lang/Character;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(CC)V
	constructor(start: Char, endInclusive: Char)


	// *** FUNCTIONS ***

	// JVM method = contains(C)Z
	open operator fun contains(value: Char): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.ranges.ClosedDoubleRange : ClosedFloatingPointRange<Double> {

	// *** PROPERTIES ***

	// JVM field = _endInclusive:D
	private val _endInclusive: Double

	// JVM field = _start:D
	private val _start: Double

	open val endInclusive: Double
		// JVM method = getEndInclusive()Ljava/lang/Double;
		get() = /* non-default */

	open val start: Double
		// JVM method = getStart()Ljava/lang/Double;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(DD)V
	constructor(start: Double, endInclusive: Double)


	// *** FUNCTIONS ***

	// JVM method = contains(D)Z
	open operator fun contains(value: Double): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lessThanOrEquals(DD)Z
	open fun lessThanOrEquals(a: Double, b: Double): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.ranges.ClosedFloatRange : ClosedFloatingPointRange<Float> {

	// *** PROPERTIES ***

	// JVM field = _endInclusive:F
	private val _endInclusive: Float

	// JVM field = _start:F
	private val _start: Float

	open val endInclusive: Float
		// JVM method = getEndInclusive()Ljava/lang/Float;
		get() = /* non-default */

	open val start: Float
		// JVM method = getStart()Ljava/lang/Float;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(FF)V
	constructor(start: Float, endInclusive: Float)


	// *** FUNCTIONS ***

	// JVM method = contains(F)Z
	open operator fun contains(value: Float): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lessThanOrEquals(FF)Z
	open fun lessThanOrEquals(a: Float, b: Float): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private open class kotlin.ranges.ComparableOpenEndRange<T : Comparable<T>> : OpenEndRange<T : Comparable<T>> {

	// *** PROPERTIES ***

	// JVM field = endExclusive:Ljava/lang/Comparable;
	open val endExclusive: T : Comparable<T>

	// JVM field = start:Ljava/lang/Comparable;
	open val start: T : Comparable<T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/Comparable;Ljava/lang/Comparable;)V
	constructor(start: T : Comparable<T>, endExclusive: T : Comparable<T>)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private open class kotlin.ranges.ComparableRange<T : Comparable<T>> : ClosedRange<T : Comparable<T>> {

	// *** PROPERTIES ***

	// JVM field = endInclusive:Ljava/lang/Comparable;
	open val endInclusive: T : Comparable<T>

	// JVM field = start:Ljava/lang/Comparable;
	open val start: T : Comparable<T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/Comparable;Ljava/lang/Comparable;)V
	constructor(start: T : Comparable<T>, endInclusive: T : Comparable<T>)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

open class kotlin.ranges.IntProgression : Iterable<Int> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = first:I
	val first: Int

	// JVM field = last:I
	val last: Int

	// JVM field = step:I
	val step: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(III)V
	internal constructor(start: Int, endInclusive: Int, step: Int)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Lkotlin/collections/IntIterator;
	open operator fun iterator(): IntIterator

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.ranges.IntProgressionIterator : IntIterator {

	// *** PROPERTIES ***

	// JVM field = finalElement:I
	private val finalElement: Int

	// JVM field = hasNext:Z
	private var hasNext: Boolean

	// JVM field = next:I
	private var next: Int

	// JVM field = step:I
	val step: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(III)V
	constructor(first: Int, last: Int, step: Int)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextInt()I
	open fun nextInt(): Int
}

// ------------------------------------------------------------------------------------------------------

class kotlin.ranges.IntRange :
	IntProgression,
	ClosedRange<Int>,
	OpenEndRange<Int> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM annotation-holding method = getEndExclusive$annotations()V
	open val endExclusive: Int
		// JVM method = getEndExclusive()Ljava/lang/Integer;
		get() = /* non-default */

	open val endInclusive: Int
		// JVM method = getEndInclusive()Ljava/lang/Integer;
		get() = /* non-default */

	open val start: Int
		// JVM method = getStart()Ljava/lang/Integer;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(II)V
	constructor(start: Int, endInclusive: Int)


	// *** FUNCTIONS ***

	// JVM method = contains(I)Z
	open operator fun contains(value: Int): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

open class kotlin.ranges.LongProgression : Iterable<Long> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = first:J
	val first: Long

	// JVM field = last:J
	val last: Long

	// JVM field = step:J
	val step: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>(JJJ)V
	internal constructor(start: Long, endInclusive: Long, step: Long)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Lkotlin/collections/LongIterator;
	open operator fun iterator(): LongIterator

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.ranges.LongProgressionIterator : LongIterator {

	// *** PROPERTIES ***

	// JVM field = finalElement:J
	private val finalElement: Long

	// JVM field = hasNext:Z
	private var hasNext: Boolean

	// JVM field = next:J
	private var next: Long

	// JVM field = step:J
	val step: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>(JJJ)V
	constructor(first: Long, last: Long, step: Long)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextLong()J
	open fun nextLong(): Long
}

// ------------------------------------------------------------------------------------------------------

class kotlin.ranges.LongRange :
	LongProgression,
	ClosedRange<Long>,
	OpenEndRange<Long> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM annotation-holding method = getEndExclusive$annotations()V
	open val endExclusive: Long
		// JVM method = getEndExclusive()Ljava/lang/Long;
		get() = /* non-default */

	open val endInclusive: Long
		// JVM method = getEndInclusive()Ljava/lang/Long;
		get() = /* non-default */

	open val start: Long
		// JVM method = getStart()Ljava/lang/Long;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(JJ)V
	constructor(start: Long, endInclusive: Long)


	// *** FUNCTIONS ***

	// JVM method = contains(J)Z
	open operator fun contains(value: Long): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.ranges.OpenEndDoubleRange : OpenEndRange<Double> {

	// *** PROPERTIES ***

	// JVM field = _endExclusive:D
	private val _endExclusive: Double

	// JVM field = _start:D
	private val _start: Double

	open val endExclusive: Double
		// JVM method = getEndExclusive()Ljava/lang/Double;
		get() = /* non-default */

	open val start: Double
		// JVM method = getStart()Ljava/lang/Double;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(DD)V
	constructor(start: Double, endExclusive: Double)


	// *** FUNCTIONS ***

	// JVM method = contains(D)Z
	open operator fun contains(value: Double): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lessThanOrEquals(DD)Z
	private fun lessThanOrEquals(a: Double, b: Double): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.ranges.OpenEndFloatRange : OpenEndRange<Float> {

	// *** PROPERTIES ***

	// JVM field = _endExclusive:F
	private val _endExclusive: Float

	// JVM field = _start:F
	private val _start: Float

	open val endExclusive: Float
		// JVM method = getEndExclusive()Ljava/lang/Float;
		get() = /* non-default */

	open val start: Float
		// JVM method = getStart()Ljava/lang/Float;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(FF)V
	constructor(start: Float, endExclusive: Float)


	// *** FUNCTIONS ***

	// JVM method = contains(F)Z
	open operator fun contains(value: Float): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lessThanOrEquals(FF)Z
	private fun lessThanOrEquals(a: Float, b: Float): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
open class kotlin.ranges.UIntProgression : Iterable<UInt> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = first:I
	val first: UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = last:I
	val last: UInt

	// JVM field = step:I
	val step: Int


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = <init>(IIILkotlin/jvm/internal/DefaultConstructorMarker;)V
	internal constructor(start: UInt, endInclusive: UInt, step: Int)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = iterator()Ljava/util/Iterator;
	operator fun iterator(): Iterator<UInt>

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
private class kotlin.ranges.UIntProgressionIterator : Iterator<UInt> {

	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = finalElement:I
	private val finalElement: UInt

	// JVM field = hasNext:Z
	private var hasNext: Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = next:I
	private var next: UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = step:I
	private val step: UInt


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = <init>(IIILkotlin/jvm/internal/DefaultConstructorMarker;)V
	constructor(first: UInt, last: UInt, step: Int)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = next-pVg5ArA()I
	open operator fun next(): UInt
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
class kotlin.ranges.UIntRange :
	UIntProgression,
	ClosedRange<UInt>,
	OpenEndRange<UInt> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getEndExclusive-pVg5ArA$annotations()V
	open val endExclusive: UInt
		// JVM method = getEndExclusive-pVg5ArA()I
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	open val endInclusive: UInt
		// JVM method = getEndInclusive-pVg5ArA()I
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	open val start: UInt
		// JVM method = getStart-pVg5ArA()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = <init>(IILkotlin/jvm/internal/DefaultConstructorMarker;)V
	constructor(start: UInt, endInclusive: UInt)


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = contains-WZ4Q5Ns(I)Z
	open operator fun contains(value: UInt): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
open class kotlin.ranges.ULongProgression : Iterable<ULong> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = first:J
	val first: ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = last:J
	val last: ULong

	// JVM field = step:J
	val step: Long


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = <init>(JJJLkotlin/jvm/internal/DefaultConstructorMarker;)V
	internal constructor(start: ULong, endInclusive: ULong, step: Long)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = iterator()Ljava/util/Iterator;
	operator fun iterator(): Iterator<ULong>

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
private class kotlin.ranges.ULongProgressionIterator : Iterator<ULong> {

	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = finalElement:J
	private val finalElement: ULong

	// JVM field = hasNext:Z
	private var hasNext: Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = next:J
	private var next: ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = step:J
	private val step: ULong


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = <init>(JJJLkotlin/jvm/internal/DefaultConstructorMarker;)V
	constructor(first: ULong, last: ULong, step: Long)


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = next-s-VKNKU()J
	open operator fun next(): ULong
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
class kotlin.ranges.ULongRange :
	ULongProgression,
	ClosedRange<ULong>,
	OpenEndRange<ULong> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getEndExclusive-s-VKNKU$annotations()V
	open val endExclusive: ULong
		// JVM method = getEndExclusive-s-VKNKU()J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	open val endInclusive: ULong
		// JVM method = getEndInclusive-s-VKNKU()J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	open val start: ULong
		// JVM method = getStart-s-VKNKU()J
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = <init>(JJLkotlin/jvm/internal/DefaultConstructorMarker;)V
	constructor(start: ULong, endInclusive: ULong)


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = contains-VKZWuLQ(J)Z
	open operator fun contains(value: ULong): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.reflect.GenericArrayTypeImpl : java.lang.reflect.GenericArrayType, kotlin.reflect.TypeImpl {

	// *** PROPERTIES ***

	// JVM field = elementType:Ljava/lang/reflect/Type;
	private val elementType: java.lang.reflect.Type


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/reflect/Type;)V
	constructor(elementType: java.lang.reflect.Type)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = getGenericComponentType()Ljava/lang/reflect/Type;
	open fun getGenericComponentType(): java.lang.reflect.Type

	// JVM method = getTypeName()Ljava/lang/String;
	open fun getTypeName(): String

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

data class kotlin.reflect.KTypeProjection {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = type:Lkotlin/reflect/KType;
	val type: kotlin.reflect.KType?

	// JVM field = variance:Lkotlin/reflect/KVariance;
	val variance: kotlin.reflect.KVariance?


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/reflect/KVariance;Lkotlin/reflect/KType;)V
	constructor(variance: kotlin.reflect.KVariance?, type: kotlin.reflect.KType?)


	// *** FUNCTIONS ***

	// JVM method = component1()Lkotlin/reflect/KVariance;
	/* synthesized */ operator fun component1(): kotlin.reflect.KVariance?

	// JVM method = component2()Lkotlin/reflect/KType;
	/* synthesized */ operator fun component2(): kotlin.reflect.KType?

	// JVM method = copy(Lkotlin/reflect/KVariance;Lkotlin/reflect/KType;)Lkotlin/reflect/KTypeProjection;
	/* synthesized */ fun copy(variance: kotlin.reflect.KVariance? /* = default */, type: kotlin.reflect.KType? /* = default */): kotlin.reflect.KTypeProjection

	// JVM method = equals(Ljava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.reflect.ParameterizedTypeImpl : java.lang.reflect.ParameterizedType, kotlin.reflect.TypeImpl {

	// *** PROPERTIES ***

	// JVM field = ownerType:Ljava/lang/reflect/Type;
	private val ownerType: java.lang.reflect.Type?

	// JVM field = rawType:Ljava/lang/Class;
	private val rawType: java.lang.Class<*>

	// JVM field = typeArguments:[Ljava/lang/reflect/Type;
	private val typeArguments: Array<java.lang.reflect.Type>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/Class;Ljava/lang/reflect/Type;Ljava/util/List;)V
	constructor(rawType: java.lang.Class<*>, ownerType: java.lang.reflect.Type?, typeArguments: List<java.lang.reflect.Type>)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = getActualTypeArguments()[Ljava/lang/reflect/Type;
	open fun getActualTypeArguments(): Array<java.lang.reflect.Type>

	// JVM method = getOwnerType()Ljava/lang/reflect/Type;
	open fun getOwnerType(): java.lang.reflect.Type?

	// JVM method = getRawType()Ljava/lang/reflect/Type;
	open fun getRawType(): java.lang.reflect.Type

	// JVM method = getTypeName()Ljava/lang/String;
	open fun getTypeName(): String

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.reflect.TypeVariableImpl : java.lang.reflect.TypeVariable<java.lang.reflect.GenericDeclaration>, kotlin.reflect.TypeImpl {

	// *** PROPERTIES ***

	// JVM field = typeParameter:Lkotlin/reflect/KTypeParameter;
	private val typeParameter: kotlin.reflect.KTypeParameter


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/reflect/KTypeParameter;)V
	constructor(typeParameter: kotlin.reflect.KTypeParameter)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = getAnnotation(Ljava/lang/Class;)Ljava/lang/annotation/Annotation;
	fun <T : Annotation> getAnnotation(annotationClass: java.lang.Class<T : Annotation>): T : Annotation?

	// JVM method = getAnnotations()[Ljava/lang/annotation/Annotation;
	fun getAnnotations(): Array<Annotation>

	// JVM method = getBounds()[Ljava/lang/reflect/Type;
	open fun getBounds(): Array<java.lang.reflect.Type>

	// JVM method = getDeclaredAnnotations()[Ljava/lang/annotation/Annotation;
	fun getDeclaredAnnotations(): Array<Annotation>

	// JVM method = getGenericDeclaration()Ljava/lang/reflect/GenericDeclaration;
	open fun getGenericDeclaration(): java.lang.reflect.GenericDeclaration

	// JVM method = getName()Ljava/lang/String;
	open fun getName(): String

	// JVM method = getTypeName()Ljava/lang/String;
	open fun getTypeName(): String

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.reflect.WildcardTypeImpl : java.lang.reflect.WildcardType, kotlin.reflect.TypeImpl {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = lowerBound:Ljava/lang/reflect/Type;
	private val lowerBound: java.lang.reflect.Type?

	// JVM field = upperBound:Ljava/lang/reflect/Type;
	private val upperBound: java.lang.reflect.Type?


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)V
	constructor(upperBound: java.lang.reflect.Type?, lowerBound: java.lang.reflect.Type?)


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = getLowerBounds()[Ljava/lang/reflect/Type;
	open fun getLowerBounds(): Array<java.lang.reflect.Type>

	// JVM method = getTypeName()Ljava/lang/String;
	open fun getTypeName(): String

	// JVM method = getUpperBounds()[Ljava/lang/reflect/Type;
	open fun getUpperBounds(): Array<java.lang.reflect.Type>

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.ConstrainedOnceSequence<T> : Sequence<T> {

	// *** PROPERTIES ***

	// JVM field = sequenceRef:Ljava/util/concurrent/atomic/AtomicReference;
	private val sequenceRef: java.util.concurrent.atomic.AtomicReference<Sequence<T>!>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;)V
	constructor(sequence: Sequence<T>)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T>
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.sequences.DistinctIterator<T, K> : AbstractIterator<T> {

	// *** PROPERTIES ***

	// JVM field = keySelector:Lkotlin/jvm/functions/Function1;
	private val keySelector: (T) -> K

	// JVM field = observed:Ljava/util/HashSet;
	private val observed: HashSet<K> /* = java.util.HashSet<K> */

	// JVM field = source:Ljava/util/Iterator;
	private val source: Iterator<T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/util/Iterator;Lkotlin/jvm/functions/Function1;)V
	constructor(source: Iterator<T>, keySelector: (T) -> K)


	// *** FUNCTIONS ***

	// JVM method = computeNext()V
	protected open fun computeNext()
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.DistinctSequence<T, K> : Sequence<T> {

	// *** PROPERTIES ***

	// JVM field = keySelector:Lkotlin/jvm/functions/Function1;
	private val keySelector: (T) -> K

	// JVM field = source:Lkotlin/sequences/Sequence;
	private val source: Sequence<T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)V
	constructor(source: Sequence<T>, keySelector: (T) -> K)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.DropSequence$iterator$1 : Iterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = iterator:Ljava/util/Iterator;
	val iterator: Iterator<T#0>

	// JVM field = left:I
	var left: Int


	// *** FUNCTIONS ***

	// JVM method = drop()V
	private fun drop()

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.DropSequence<T> : Sequence<T>, DropTakeSequence<T> {

	// *** PROPERTIES ***

	// JVM field = count:I
	private val count: Int

	// JVM field = sequence:Lkotlin/sequences/Sequence;
	private val sequence: Sequence<T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;I)V
	constructor(sequence: Sequence<T>, count: Int)


	// *** FUNCTIONS ***

	// JVM method = drop(I)Lkotlin/sequences/Sequence;
	open fun drop(n: Int): Sequence<T>

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T>

	// JVM method = take(I)Lkotlin/sequences/Sequence;
	open fun take(n: Int): Sequence<T>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.DropWhileSequence$iterator$1 : Iterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = dropState:I
	var dropState: Int

	// JVM field = iterator:Ljava/util/Iterator;
	val iterator: Iterator<T#0>

	// JVM field = nextItem:Ljava/lang/Object;
	var nextItem: T#0?


	// *** FUNCTIONS ***

	// JVM method = drop()V
	private fun drop()

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.DropWhileSequence<T> : Sequence<T> {

	// *** PROPERTIES ***

	// JVM field = predicate:Lkotlin/jvm/functions/Function1;
	private val predicate: (T) -> Boolean

	// JVM field = sequence:Lkotlin/sequences/Sequence;
	private val sequence: Sequence<T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)V
	constructor(sequence: Sequence<T>, predicate: (T) -> Boolean)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.FilteringSequence$iterator$1 : Iterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = iterator:Ljava/util/Iterator;
	val iterator: Iterator<T#0>

	// JVM field = nextItem:Ljava/lang/Object;
	var nextItem: T#0?

	// JVM field = nextState:I
	var nextState: Int


	// *** FUNCTIONS ***

	// JVM method = calcNext()V
	private fun calcNext()

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.FilteringSequence<T> : Sequence<T> {

	// *** PROPERTIES ***

	// JVM field = predicate:Lkotlin/jvm/functions/Function1;
	private val predicate: (T) -> Boolean

	// JVM field = sendWhen:Z
	private val sendWhen: Boolean

	// JVM field = sequence:Lkotlin/sequences/Sequence;
	private val sequence: Sequence<T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;ZLkotlin/jvm/functions/Function1;)V
	constructor(sequence: Sequence<T>, sendWhen: Boolean /* = default */, predicate: (T) -> Boolean)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.FlatteningSequence$iterator$1 : Iterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = itemIterator:Ljava/util/Iterator;
	var itemIterator: Iterator<T#0>?

	// JVM field = iterator:Ljava/util/Iterator;
	val iterator: Iterator<T#1>


	// *** FUNCTIONS ***

	// JVM method = ensureItemIterator()Z
	private fun ensureItemIterator(): Boolean

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.FlatteningSequence<T, R, E> : Sequence<E> {

	// *** PROPERTIES ***

	// JVM field = iterator:Lkotlin/jvm/functions/Function1;
	private val iterator: (R) -> Iterator<E>

	// JVM field = sequence:Lkotlin/sequences/Sequence;
	private val sequence: Sequence<T>

	// JVM field = transformer:Lkotlin/jvm/functions/Function1;
	private val transformer: (T) -> R


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)V
	constructor(sequence: Sequence<T>, transformer: (T) -> R, iterator: (R) -> Iterator<E>)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<E>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.GeneratorSequence$iterator$1 : Iterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = nextItem:Ljava/lang/Object;
	var nextItem: T#0?

	// JVM field = nextState:I
	var nextState: Int


	// *** FUNCTIONS ***

	// JVM method = calcNext()V
	private fun calcNext()

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.sequences.GeneratorSequence<T : Any> : Sequence<T : Any> {

	// *** PROPERTIES ***

	// JVM field = getInitialValue:Lkotlin/jvm/functions/Function0;
	private val getInitialValue: () -> T : Any?

	// JVM field = getNextValue:Lkotlin/jvm/functions/Function1;
	private val getNextValue: (T : Any) -> T : Any?


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;)V
	constructor(getInitialValue: () -> T : Any?, getNextValue: (T : Any) -> T : Any?)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T : Any>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.IndexingSequence$iterator$1 : Iterator<IndexedValue<T#0>> {

	// *** PROPERTIES ***

	// JVM field = index:I
	var index: Int

	// JVM field = iterator:Ljava/util/Iterator;
	val iterator: Iterator<T#0>


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Lkotlin/collections/IndexedValue;
	open operator fun next(): IndexedValue<T#0>
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.IndexingSequence<T> : Sequence<IndexedValue<T>> {

	// *** PROPERTIES ***

	// JVM field = sequence:Lkotlin/sequences/Sequence;
	private val sequence: Sequence<T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;)V
	constructor(sequence: Sequence<T>)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<IndexedValue<T>>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.MergingSequence$iterator$1 : Iterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = iterator1:Ljava/util/Iterator;
	val iterator1: Iterator<T#1>

	// JVM field = iterator2:Ljava/util/Iterator;
	val iterator2: Iterator<T#1>


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.MergingSequence<T1, T2, V> : Sequence<V> {

	// *** PROPERTIES ***

	// JVM field = sequence1:Lkotlin/sequences/Sequence;
	private val sequence1: Sequence<T1>

	// JVM field = sequence2:Lkotlin/sequences/Sequence;
	private val sequence2: Sequence<T2>

	// JVM field = transform:Lkotlin/jvm/functions/Function2;
	private val transform: (T1, T2) -> V


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)V
	constructor(sequence1: Sequence<T1>, sequence2: Sequence<T2>, transform: (T1, T2) -> V)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<V>
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.sequences.SequenceBuilderIterator<T> :
	SequenceScope<T>,
	Iterator<T>,
	kotlin.coroutines.Continuation<Unit> {

	// *** PROPERTIES ***

	open val context: kotlin.coroutines.CoroutineContext
		// JVM method = getContext()Lkotlin/coroutines/CoroutineContext;
		get() = /* non-default */

	// JVM field = nextIterator:Ljava/util/Iterator;
	private var nextIterator: Iterator<T>?

	// JVM field = nextStep:Lkotlin/coroutines/Continuation;
	var nextStep: kotlin.coroutines.Continuation<Unit>?

	// JVM field = nextValue:Ljava/lang/Object;
	private var nextValue: T?

	// JVM field = state:I
	private var state: State /* = Int */


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = exceptionalState()Ljava/lang/Throwable;
	private fun exceptionalState(): Throwable

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T

	// JVM method = nextNotReady()Ljava/lang/Object;
	private fun nextNotReady(): T

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = resumeWith(Ljava/lang/Object;)V
	open fun resumeWith(result: Result<Unit>)

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = yield(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	open suspend fun yield(value: T)

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = yieldAll(Ljava/util/Iterator;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	open suspend fun yieldAll(iterator: Iterator<T>)
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.sequences.SequenceScope<in T> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	internal constructor()


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = yield(Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	abstract suspend fun yield(value: in T)

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = yieldAll(Ljava/lang/Iterable;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	suspend fun yieldAll(elements: Iterable<in T>)

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = yieldAll(Ljava/util/Iterator;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	abstract suspend fun yieldAll(iterator: Iterator<in T>)

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = yieldAll(Lkotlin/sequences/Sequence;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	suspend fun yieldAll(sequence: Sequence<in T>)
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: CollectionsKt__IterablesKt$Iterable$1
/* local */ class kotlin.collections.CollectionsKt__IterablesKt$Iterable$1 : Iterable<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.SequencesKt___SequencesKt$groupingBy$1 : Grouping<T#0, T#1> {

	// *** FUNCTIONS ***

	// JVM method = keyOf(Ljava/lang/Object;)Ljava/lang/Object;
	open fun keyOf(element: T#0): T#1

	// JVM method = sourceIterator()Ljava/util/Iterator;
	open fun sourceIterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.SequencesKt___SequencesKt$minus$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.SequencesKt___SequencesKt$minus$2 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.SequencesKt___SequencesKt$minus$3 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.SequencesKt___SequencesKt$minus$4 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.SequencesKt___SequencesKt$sorted$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.SequencesKt___SequencesKt$sortedWith$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.SubSequence$iterator$1 : Iterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = iterator:Ljava/util/Iterator;
	val iterator: Iterator<T#0>

	// JVM field = position:I
	var position: Int


	// *** FUNCTIONS ***

	// JVM method = drop()V
	private fun drop()

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.SubSequence<T> : Sequence<T>, DropTakeSequence<T> {

	// *** PROPERTIES ***

	private val count: Int
		// JVM method = getCount()I
		get() = /* non-default */

	// JVM field = endIndex:I
	private val endIndex: Int

	// JVM field = sequence:Lkotlin/sequences/Sequence;
	private val sequence: Sequence<T>

	// JVM field = startIndex:I
	private val startIndex: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;II)V
	constructor(sequence: Sequence<T>, startIndex: Int, endIndex: Int)


	// *** FUNCTIONS ***

	// JVM method = drop(I)Lkotlin/sequences/Sequence;
	open fun drop(n: Int): Sequence<T>

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T>

	// JVM method = take(I)Lkotlin/sequences/Sequence;
	open fun take(n: Int): Sequence<T>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.TakeSequence$iterator$1 : Iterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = iterator:Ljava/util/Iterator;
	val iterator: Iterator<T#0>

	// JVM field = left:I
	var left: Int


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.TakeSequence<T> : Sequence<T>, DropTakeSequence<T> {

	// *** PROPERTIES ***

	// JVM field = count:I
	private val count: Int

	// JVM field = sequence:Lkotlin/sequences/Sequence;
	private val sequence: Sequence<T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;I)V
	constructor(sequence: Sequence<T>, count: Int)


	// *** FUNCTIONS ***

	// JVM method = drop(I)Lkotlin/sequences/Sequence;
	open fun drop(n: Int): Sequence<T>

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T>

	// JVM method = take(I)Lkotlin/sequences/Sequence;
	open fun take(n: Int): Sequence<T>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.TakeWhileSequence$iterator$1 : Iterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = iterator:Ljava/util/Iterator;
	val iterator: Iterator<T#0>

	// JVM field = nextItem:Ljava/lang/Object;
	var nextItem: T#0?

	// JVM field = nextState:I
	var nextState: Int


	// *** FUNCTIONS ***

	// JVM method = calcNext()V
	private fun calcNext()

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.TakeWhileSequence<T> : Sequence<T> {

	// *** PROPERTIES ***

	// JVM field = predicate:Lkotlin/jvm/functions/Function1;
	private val predicate: (T) -> Boolean

	// JVM field = sequence:Lkotlin/sequences/Sequence;
	private val sequence: Sequence<T>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)V
	constructor(sequence: Sequence<T>, predicate: (T) -> Boolean)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.TransformingIndexedSequence$iterator$1 : Iterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = index:I
	var index: Int

	// JVM field = iterator:Ljava/util/Iterator;
	val iterator: Iterator<T#1>


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.TransformingIndexedSequence<T, R> : Sequence<R> {

	// *** PROPERTIES ***

	// JVM field = sequence:Lkotlin/sequences/Sequence;
	private val sequence: Sequence<T>

	// JVM field = transformer:Lkotlin/jvm/functions/Function2;
	private val transformer: (Int, T) -> R


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)V
	constructor(sequence: Sequence<T>, transformer: (Int, T) -> R)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<R>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.sequences.TransformingSequence$iterator$1 : Iterator<T#0> {

	// *** PROPERTIES ***

	// JVM field = iterator:Ljava/util/Iterator;
	val iterator: Iterator<T#1>


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Ljava/lang/Object;
	open operator fun next(): T#0
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.sequences.TransformingSequence<T, R> : Sequence<R> {

	// *** PROPERTIES ***

	// JVM field = sequence:Lkotlin/sequences/Sequence;
	private val sequence: Sequence<T>

	// JVM field = transformer:Lkotlin/jvm/functions/Function1;
	private val transformer: (T) -> R


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)V
	constructor(sequence: Sequence<T>, transformer: (T) -> R)


	// *** FUNCTIONS ***

	// JVM method = flatten$kotlin_stdlib(Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
	internal fun <E> flatten(iterator: (R) -> Iterator<E>): Sequence<E>

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<R>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.text.DelimitedRangesSequence$iterator$1 : Iterator<IntRange> {

	// *** PROPERTIES ***

	// JVM field = counter:I
	var counter: Int

	// JVM field = currentStartIndex:I
	var currentStartIndex: Int

	// JVM field = nextItem:Lkotlin/ranges/IntRange;
	var nextItem: IntRange?

	// JVM field = nextSearchIndex:I
	var nextSearchIndex: Int

	// JVM field = nextState:I
	var nextState: Int


	// *** FUNCTIONS ***

	// JVM method = calcNext()V
	private fun calcNext()

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = next()Lkotlin/ranges/IntRange;
	open operator fun next(): IntRange
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.text.DelimitedRangesSequence : Sequence<IntRange> {

	// *** PROPERTIES ***

	// JVM field = getNextMatch:Lkotlin/jvm/functions/Function2;
	private val getNextMatch: CharSequence.(@ParameterName(name = "currentIndex") Int) -> Pair<Int, Int>?

	// JVM field = input:Ljava/lang/CharSequence;
	private val input: CharSequence

	// JVM field = limit:I
	private val limit: Int

	// JVM field = startIndex:I
	private val startIndex: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/CharSequence;IILkotlin/jvm/functions/Function2;)V
	constructor(input: CharSequence, startIndex: Int, limit: Int, getNextMatch: CharSequence.(@ParameterName(name = "currentIndex") Int) -> Pair<Int, Int>?)


	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<IntRange>
}

// ------------------------------------------------------------------------------------------------------

data class kotlin.text.MatchGroup {

	// *** PROPERTIES ***

	// JVM field = range:Lkotlin/ranges/IntRange;
	val range: IntRange

	// JVM field = value:Ljava/lang/String;
	val value: String


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;Lkotlin/ranges/IntRange;)V
	constructor(value: String, range: IntRange)


	// *** FUNCTIONS ***

	// JVM method = component1()Ljava/lang/String;
	/* synthesized */ operator fun component1(): String

	// JVM method = component2()Lkotlin/ranges/IntRange;
	/* synthesized */ operator fun component2(): IntRange

	// JVM method = copy(Ljava/lang/String;Lkotlin/ranges/IntRange;)Lkotlin/text/MatchGroup;
	/* synthesized */ fun copy(value: String /* = default */, range: IntRange /* = default */): MatchGroup

	// JVM method = equals(Ljava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	/* synthesized */ open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

class kotlin.text.MatchResult.Destructured {

	// *** PROPERTIES ***

	// JVM field = match:Lkotlin/text/MatchResult;
	val match: MatchResult


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/text/MatchResult;)V
	internal constructor(match: MatchResult)


	// *** FUNCTIONS ***

	// JVM method = component1()Ljava/lang/String;
	inline operator fun component1(): String

	// JVM method = component10()Ljava/lang/String;
	inline operator fun component10(): String

	// JVM method = component2()Ljava/lang/String;
	inline operator fun component2(): String

	// JVM method = component3()Ljava/lang/String;
	inline operator fun component3(): String

	// JVM method = component4()Ljava/lang/String;
	inline operator fun component4(): String

	// JVM method = component5()Ljava/lang/String;
	inline operator fun component5(): String

	// JVM method = component6()Ljava/lang/String;
	inline operator fun component6(): String

	// JVM method = component7()Ljava/lang/String;
	inline operator fun component7(): String

	// JVM method = component8()Ljava/lang/String;
	inline operator fun component8(): String

	// JVM method = component9()Ljava/lang/String;
	inline operator fun component9(): String

	// JVM method = toList()Ljava/util/List;
	fun toList(): List<String>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.text.MatcherMatchResult$groupValues$1 : AbstractList<String> {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// JVM method = get(I)Ljava/lang/String;
	open operator fun get(index: Int): String
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.text.MatcherMatchResult$groups$1 : MatchNamedGroupCollection, AbstractCollection<MatchGroup?> {

	// *** PROPERTIES ***

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** FUNCTIONS ***

	// JVM method = get(I)Lkotlin/text/MatchGroup;
	open operator fun get(index: Int): MatchGroup?

	// JVM method = get(Ljava/lang/String;)Lkotlin/text/MatchGroup;
	open operator fun get(name: String): MatchGroup?

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<MatchGroup?>
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.text.MatcherMatchResult : MatchResult {

	// *** PROPERTIES ***

	open val groupValues: List<String>
		// JVM method = getGroupValues()Ljava/util/List;
		get() = /* non-default */

	// JVM field = groupValues_:Ljava/util/List;
	private var groupValues_: List<String>?

	// JVM field = groups:Lkotlin/text/MatchGroupCollection;
	open val groups: MatchGroupCollection

	// JVM field = input:Ljava/lang/CharSequence;
	private val input: CharSequence

	private val matchResult: java.util.regex.MatchResult
		// JVM method = getMatchResult()Ljava/util/regex/MatchResult;
		get() = /* non-default */

	// JVM field = matcher:Ljava/util/regex/Matcher;
	private val matcher: java.util.regex.Matcher

	open val range: IntRange
		// JVM method = getRange()Lkotlin/ranges/IntRange;
		get() = /* non-default */

	open val value: String
		// JVM method = getValue()Ljava/lang/String;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/util/regex/Matcher;Ljava/lang/CharSequence;)V
	constructor(matcher: java.util.regex.Matcher, input: CharSequence)


	// *** FUNCTIONS ***

	// JVM method = next()Lkotlin/text/MatchResult;
	open fun next(): MatchResult?
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.text.Regex.Serialized : Serializable /* = java.io.Serializable */ {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = flags:I
	val flags: Int

	// JVM field = pattern:Ljava/lang/String;
	val pattern: String


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	constructor(pattern: String, flags: Int)


	// *** FUNCTIONS ***

	// JVM method = readResolve()Ljava/lang/Object;
	private fun readResolve(): Any
}

// ------------------------------------------------------------------------------------------------------

class kotlin.text.Regex : Serializable /* = java.io.Serializable */ {

	// *** NESTED TYPES ***

	companion object
	class Serialized


	// *** PROPERTIES ***

	// JVM field = _options:Ljava/util/Set;
	private var _options: Set<RegexOption>?

	// JVM field = nativePattern:Ljava/util/regex/Pattern;
	private val nativePattern: java.util.regex.Pattern

	val options: Set<RegexOption>
		// JVM method = getOptions()Ljava/util/Set;
		get() = /* non-default */

	val pattern: String
		// JVM method = getPattern()Ljava/lang/String;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;)V
	/* secondary */ constructor(pattern: String)

	// JVM method = <init>(Ljava/lang/String;Lkotlin/text/RegexOption;)V
	/* secondary */ constructor(pattern: String, option: RegexOption)

	// JVM method = <init>(Ljava/lang/String;Ljava/util/Set;)V
	/* secondary */ constructor(pattern: String, options: Set<RegexOption>)

	// JVM method = <init>(Ljava/util/regex/Pattern;)V
	internal constructor(nativePattern: java.util.regex.Pattern)


	// *** FUNCTIONS ***

	// JVM method = containsMatchIn(Ljava/lang/CharSequence;)Z
	fun containsMatchIn(input: CharSequence): Boolean

	// JVM method = find(Ljava/lang/CharSequence;I)Lkotlin/text/MatchResult;
	fun find(input: CharSequence, startIndex: Int /* = default */): MatchResult?

	// JVM method = findAll(Ljava/lang/CharSequence;I)Lkotlin/sequences/Sequence;
	fun findAll(input: CharSequence, startIndex: Int /* = default */): Sequence<MatchResult>

	// JVM method = matchAt(Ljava/lang/CharSequence;I)Lkotlin/text/MatchResult;
	fun matchAt(input: CharSequence, index: Int): MatchResult?

	// JVM method = matchEntire(Ljava/lang/CharSequence;)Lkotlin/text/MatchResult;
	fun matchEntire(input: CharSequence): MatchResult?

	// JVM method = matches(Ljava/lang/CharSequence;)Z
	infix fun matches(input: CharSequence): Boolean

	// JVM method = matchesAt(Ljava/lang/CharSequence;I)Z
	fun matchesAt(input: CharSequence, index: Int): Boolean

	// JVM method = replace(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
	fun replace(input: CharSequence, transform: (MatchResult) -> CharSequence): String

	// JVM method = replace(Ljava/lang/CharSequence;Ljava/lang/String;)Ljava/lang/String;
	fun replace(input: CharSequence, replacement: String): String

	// JVM method = replaceFirst(Ljava/lang/CharSequence;Ljava/lang/String;)Ljava/lang/String;
	fun replaceFirst(input: CharSequence, replacement: String): String

	// JVM method = split(Ljava/lang/CharSequence;I)Ljava/util/List;
	fun split(input: CharSequence, limit: Int /* = default */): List<String>

	// JVM method = splitToSequence(Ljava/lang/CharSequence;I)Lkotlin/sequences/Sequence;
	fun splitToSequence(input: CharSequence, limit: Int /* = default */): Sequence<String>

	// JVM method = toPattern()Ljava/util/regex/Pattern;
	fun toPattern(): java.util.regex.Pattern

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String

	// JVM method = writeReplace()Ljava/lang/Object;
	private fun writeReplace(): Any
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.text.StringsKt__StringsKt$iterator$1 : CharIterator {

	// *** PROPERTIES ***

	// JVM field = index:I
	private var index: Int


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = nextChar()C
	open fun nextChar(): Char
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: CollectionsKt__IterablesKt$Iterable$1
/* local */ class kotlin.collections.CollectionsKt__IterablesKt$Iterable$1 : Iterable<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

/* local */ class kotlin.text.StringsKt___StringsKt$groupingBy$1 : Grouping<Char, T#0> {

	// *** FUNCTIONS ***

	// JVM method = keyOf(C)Ljava/lang/Object;
	open fun keyOf(element: Char): T#0

	// JVM method = sourceIterator()Ljava/util/Iterator;
	open fun sourceIterator(): Iterator<Char>
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.time.AbstractDoubleTimeSource.DoubleTimeMark : kotlin.time.ComparableTimeMark {

	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = offset:J
	private val offset: kotlin.time.Duration

	// JVM field = startedAt:D
	private val startedAt: Double

	// JVM field = timeSource:Lkotlin/time/AbstractDoubleTimeSource;
	private val timeSource: kotlin.time.AbstractDoubleTimeSource


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = <init>(DLkotlin/time/AbstractDoubleTimeSource;JLkotlin/jvm/internal/DefaultConstructorMarker;)V
	constructor(startedAt: Double, timeSource: kotlin.time.AbstractDoubleTimeSource, offset: kotlin.time.Duration)


	// *** FUNCTIONS ***

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = elapsedNow-UwyO8pc()J
	open fun elapsedNow(): kotlin.time.Duration

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-UwyO8pc(Lkotlin/time/ComparableTimeMark;)J
	open operator fun minus(other: kotlin.time.ComparableTimeMark): kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-LRDsOJo(J)Lkotlin/time/ComparableTimeMark;
	open operator fun plus(duration: kotlin.time.Duration): kotlin.time.ComparableTimeMark

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.time.AbstractDoubleTimeSource : kotlin.time.TimeSource.WithComparableMarks {

	// *** NESTED TYPES ***

	class DoubleTimeMark


	// *** PROPERTIES ***

	// JVM field = unit:Lkotlin/time/DurationUnit;
	protected val unit: kotlin.time.DurationUnit


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/time/DurationUnit;)V
	constructor(unit: kotlin.time.DurationUnit)


	// *** FUNCTIONS ***

	// JVM method = markNow()Lkotlin/time/ComparableTimeMark;
	open fun markNow(): kotlin.time.ComparableTimeMark

	// JVM method = read()D
	protected abstract fun read(): Double
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.time.AbstractLongTimeSource.LongTimeMark : kotlin.time.ComparableTimeMark {

	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = offset:J
	private val offset: kotlin.time.Duration

	// JVM field = startedAt:J
	private val startedAt: Long

	// JVM field = timeSource:Lkotlin/time/AbstractLongTimeSource;
	private val timeSource: kotlin.time.AbstractLongTimeSource


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = <init>(JLkotlin/time/AbstractLongTimeSource;JLkotlin/jvm/internal/DefaultConstructorMarker;)V
	constructor(startedAt: Long, timeSource: kotlin.time.AbstractLongTimeSource, offset: kotlin.time.Duration)


	// *** FUNCTIONS ***

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = effectiveDuration-UwyO8pc$kotlin_stdlib()J
	internal fun effectiveDuration(): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = elapsedNow-UwyO8pc()J
	open fun elapsedNow(): kotlin.time.Duration

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-UwyO8pc(Lkotlin/time/ComparableTimeMark;)J
	open operator fun minus(other: kotlin.time.ComparableTimeMark): kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-LRDsOJo(J)Lkotlin/time/ComparableTimeMark;
	open operator fun plus(duration: kotlin.time.Duration): kotlin.time.ComparableTimeMark

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

abstract class kotlin.time.AbstractLongTimeSource : kotlin.time.TimeSource.WithComparableMarks {

	// *** NESTED TYPES ***

	class LongTimeMark


	// *** PROPERTIES ***

	// JVM field = unit:Lkotlin/time/DurationUnit;
	protected val unit: kotlin.time.DurationUnit


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/time/DurationUnit;)V
	constructor(unit: kotlin.time.DurationUnit)


	// *** FUNCTIONS ***

	// JVM method = markNow()Lkotlin/time/ComparableTimeMark;
	open fun markNow(): kotlin.time.ComparableTimeMark

	// JVM method = read()J
	protected abstract fun read(): Long
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.time.AdjustedTimeMark : kotlin.time.TimeMark {

	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = adjustment:J
	val adjustment: kotlin.time.Duration

	// JVM field = mark:Lkotlin/time/TimeMark;
	val mark: kotlin.time.TimeMark


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = <init>(Lkotlin/time/TimeMark;JLkotlin/jvm/internal/DefaultConstructorMarker;)V
	constructor(mark: kotlin.time.TimeMark, adjustment: kotlin.time.Duration)


	// *** FUNCTIONS ***

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = elapsedNow-UwyO8pc()J
	open fun elapsedNow(): kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-LRDsOJo(J)Lkotlin/time/TimeMark;
	open operator fun plus(duration: kotlin.time.Duration): kotlin.time.TimeMark
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
value class kotlin.time.Duration : Comparable<kotlin.time.Duration> {

	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	val absoluteValue: kotlin.time.Duration
		// JVM method = getAbsoluteValue-UwyO8pc(J)J
		get() = /* non-default */

	// JVM annotation-holding method = getHoursComponent$annotations()V
	internal val hoursComponent: Int
		// JVM method = getHoursComponent-impl(J)I
		get() = /* non-default */

	// JVM annotation-holding method = getInDays$annotations()V
	val inDays: Double
		// JVM method = getInDays-impl(J)D
		get() = /* non-default */

	// JVM annotation-holding method = getInHours$annotations()V
	val inHours: Double
		// JVM method = getInHours-impl(J)D
		get() = /* non-default */

	// JVM annotation-holding method = getInMicroseconds$annotations()V
	val inMicroseconds: Double
		// JVM method = getInMicroseconds-impl(J)D
		get() = /* non-default */

	// JVM annotation-holding method = getInMilliseconds$annotations()V
	val inMilliseconds: Double
		// JVM method = getInMilliseconds-impl(J)D
		get() = /* non-default */

	// JVM annotation-holding method = getInMinutes$annotations()V
	val inMinutes: Double
		// JVM method = getInMinutes-impl(J)D
		get() = /* non-default */

	// JVM annotation-holding method = getInNanoseconds$annotations()V
	val inNanoseconds: Double
		// JVM method = getInNanoseconds-impl(J)D
		get() = /* non-default */

	// JVM annotation-holding method = getInSeconds$annotations()V
	val inSeconds: Double
		// JVM method = getInSeconds-impl(J)D
		get() = /* non-default */

	val inWholeDays: Long
		// JVM method = getInWholeDays-impl(J)J
		get() = /* non-default */

	val inWholeHours: Long
		// JVM method = getInWholeHours-impl(J)J
		get() = /* non-default */

	val inWholeMicroseconds: Long
		// JVM method = getInWholeMicroseconds-impl(J)J
		get() = /* non-default */

	val inWholeMilliseconds: Long
		// JVM method = getInWholeMilliseconds-impl(J)J
		get() = /* non-default */

	val inWholeMinutes: Long
		// JVM method = getInWholeMinutes-impl(J)J
		get() = /* non-default */

	val inWholeNanoseconds: Long
		// JVM method = getInWholeNanoseconds-impl(J)J
		get() = /* non-default */

	val inWholeSeconds: Long
		// JVM method = getInWholeSeconds-impl(J)J
		get() = /* non-default */

	// JVM annotation-holding method = getMinutesComponent$annotations()V
	internal val minutesComponent: Int
		// JVM method = getMinutesComponent-impl(J)I
		get() = /* non-default */

	// JVM annotation-holding method = getNanosecondsComponent$annotations()V
	internal val nanosecondsComponent: Int
		// JVM method = getNanosecondsComponent-impl(J)I
		get() = /* non-default */

	// JVM field = rawValue:J
	private val rawValue: Long

	// JVM annotation-holding method = getSecondsComponent$annotations()V
	internal val secondsComponent: Int
		// JVM method = getSecondsComponent-impl(J)I
		get() = /* non-default */

	private val storageUnit: kotlin.time.DurationUnit
		// JVM method = getStorageUnit-impl(J)Lkotlin/time/DurationUnit;
		get() = /* non-default */

	private inline val unitDiscriminator: Int
		// JVM method = getUnitDiscriminator-impl(J)I
		get() = /* non-default */

	private val value: Long
		// JVM method = getValue-impl(J)J
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl(J)J
	internal constructor(rawValue: Long)


	// *** FUNCTIONS ***

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = addValuesMixedRanges-UwyO8pc(JJJ)J
	private fun addValuesMixedRanges(thisMillis: Long, otherNanos: Long): kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-LRDsOJo(JJ)I
	open operator fun compareTo(other: kotlin.time.Duration): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-UwyO8pc(JD)J
	operator fun div(scale: Double): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-UwyO8pc(JI)J
	operator fun div(scale: Int): kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = div-LRDsOJo(JJ)D
	operator fun div(other: kotlin.time.Duration): Double

	// JVM method = equals-impl(JLjava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode-impl(J)I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = isFinite-impl(J)Z
	fun isFinite(): Boolean

	// JVM method = isInMillis-impl(J)Z
	private fun isInMillis(): Boolean

	// JVM method = isInNanos-impl(J)Z
	private fun isInNanos(): Boolean

	// JVM method = isInfinite-impl(J)Z
	fun isInfinite(): Boolean

	// JVM method = isNegative-impl(J)Z
	fun isNegative(): Boolean

	// JVM method = isPositive-impl(J)Z
	fun isPositive(): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-LRDsOJo(JJ)J
	operator fun minus(other: kotlin.time.Duration): kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-LRDsOJo(JJ)J
	operator fun plus(other: kotlin.time.Duration): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-UwyO8pc(JD)J
	operator fun times(scale: Double): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = times-UwyO8pc(JI)J
	operator fun times(scale: Int): kotlin.time.Duration

	// requires compiler version >= 1.3.50, otherwise diagnostic error
	// JVM method = toComponents-impl(JLkotlin/jvm/functions/Function5;)Ljava/lang/Object;
	inline fun <T> toComponents(action: (@ParameterName(name = "days") Long, @ParameterName(name = "hours") Int, @ParameterName(name = "minutes") Int, @ParameterName(name = "seconds") Int, @ParameterName(name = "nanoseconds") Int) -> T): T {
		contract {
			callsInPlace(action, InvocationKind.EXACTLY_ONCE)
		}
	}

	// requires compiler version >= 1.3.50, otherwise diagnostic error
	// JVM method = toComponents-impl(JLkotlin/jvm/functions/Function4;)Ljava/lang/Object;
	inline fun <T> toComponents(action: (@ParameterName(name = "hours") Long, @ParameterName(name = "minutes") Int, @ParameterName(name = "seconds") Int, @ParameterName(name = "nanoseconds") Int) -> T): T {
		contract {
			callsInPlace(action, InvocationKind.EXACTLY_ONCE)
		}
	}

	// requires compiler version >= 1.3.50, otherwise diagnostic error
	// JVM method = toComponents-impl(JLkotlin/jvm/functions/Function3;)Ljava/lang/Object;
	inline fun <T> toComponents(action: (@ParameterName(name = "minutes") Long, @ParameterName(name = "seconds") Int, @ParameterName(name = "nanoseconds") Int) -> T): T {
		contract {
			callsInPlace(action, InvocationKind.EXACTLY_ONCE)
		}
	}

	// requires compiler version >= 1.3.50, otherwise diagnostic error
	// JVM method = toComponents-impl(JLkotlin/jvm/functions/Function2;)Ljava/lang/Object;
	inline fun <T> toComponents(action: (@ParameterName(name = "seconds") Long, @ParameterName(name = "nanoseconds") Int) -> T): T {
		contract {
			callsInPlace(action, InvocationKind.EXACTLY_ONCE)
		}
	}

	// JVM method = toDouble-impl(JLkotlin/time/DurationUnit;)D
	fun toDouble(unit: kotlin.time.DurationUnit): Double

	// JVM method = toInt-impl(JLkotlin/time/DurationUnit;)I
	fun toInt(unit: kotlin.time.DurationUnit): Int

	// JVM method = toIsoString-impl(J)Ljava/lang/String;
	fun toIsoString(): String

	// JVM method = toLong-impl(JLkotlin/time/DurationUnit;)J
	fun toLong(unit: kotlin.time.DurationUnit): Long

	// JVM method = toLongMilliseconds-impl(J)J
	fun toLongMilliseconds(): Long

	// JVM method = toLongNanoseconds-impl(J)J
	fun toLongNanoseconds(): Long

	// JVM method = toString-impl(J)Ljava/lang/String;
	open fun toString(): String

	// JVM method = toString-impl(JLkotlin/time/DurationUnit;I)Ljava/lang/String;
	fun toString(unit: kotlin.time.DurationUnit, decimals: Int /* = default */): String

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = unaryMinus-UwyO8pc(J)J
	operator fun unaryMinus(): kotlin.time.Duration

	// JVM method = appendFractional-impl(JLjava/lang/StringBuilder;IIILjava/lang/String;Z)V
	private fun StringBuilder /* = java.lang.StringBuilder */.appendFractional(whole: Int, fractional: Int, fractionalSize: Int, unit: String, isoZeroes: Boolean)
}

// ------------------------------------------------------------------------------------------------------

class kotlin.time.TestTimeSource : kotlin.time.AbstractLongTimeSource {

	// *** PROPERTIES ***

	// JVM field = reading:J
	private var reading: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = overflow-LRDsOJo(J)V
	private fun overflow(duration: kotlin.time.Duration)

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plusAssign-LRDsOJo(J)V
	operator fun plusAssign(duration: kotlin.time.Duration)

	// JVM method = read()J
	protected open fun read(): Long
}

// ------------------------------------------------------------------------------------------------------

// requires language version >= 1.3, otherwise diagnostic error
value class kotlin.time.TimeSource.Monotonic.ValueTimeMark : kotlin.time.ComparableTimeMark {

	// *** PROPERTIES ***

	// JVM field = reading:J
	internal val reading: kotlin.time.ValueTimeMarkReading /* = Long */


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = constructor-impl(J)J
	internal constructor(reading: kotlin.time.ValueTimeMarkReading /* = Long */)


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = compareTo-6eNON_k(JJ)I
	operator fun compareTo(other: kotlin.time.TimeSource.Monotonic.ValueTimeMark): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = elapsedNow-UwyO8pc(J)J
	open fun elapsedNow(): kotlin.time.Duration

	// JVM method = equals-impl(JLjava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// JVM method = hasNotPassedNow-impl(J)Z
	open fun hasNotPassedNow(): Boolean

	// JVM method = hasPassedNow-impl(J)Z
	open fun hasPassedNow(): Boolean

	// JVM method = hashCode-impl(J)I
	/* synthesized */ open fun hashCode(): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-UwyO8pc(JLkotlin/time/ComparableTimeMark;)J
	open operator fun minus(other: kotlin.time.ComparableTimeMark): kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-LRDsOJo(JJ)J
	open operator fun minus(duration: kotlin.time.Duration): kotlin.time.TimeSource.Monotonic.ValueTimeMark

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-6eNON_k(JJ)J
	operator fun minus(other: kotlin.time.TimeSource.Monotonic.ValueTimeMark): kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-LRDsOJo(JJ)J
	open operator fun plus(duration: kotlin.time.Duration): kotlin.time.TimeSource.Monotonic.ValueTimeMark

	// JVM method = toString-impl(J)Ljava/lang/String;
	/* synthesized */ open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

data class kotlin.time.TimedValue<T> {

	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = duration:J
	val duration: kotlin.time.Duration

	// JVM field = value:Ljava/lang/Object;
	val value: T


	// *** CONSTRUCTORS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = <init>(Ljava/lang/Object;JLkotlin/jvm/internal/DefaultConstructorMarker;)V
	constructor(value: T, duration: kotlin.time.Duration)


	// *** FUNCTIONS ***

	// JVM method = component1()Ljava/lang/Object;
	/* synthesized */ operator fun component1(): T

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = component2-UwyO8pc()J
	/* synthesized */ operator fun component2(): kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = copy-RFiDyg4(Ljava/lang/Object;J)Lkotlin/time/TimedValue;
	/* synthesized */ fun copy(value: T /* = default */, duration: kotlin.time.Duration /* = default */): kotlin.time.TimedValue<T>

	// JVM method = equals(Ljava/lang/Object;)Z
	/* synthesized */ open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	/* synthesized */ open fun hashCode(): Int

	// JVM method = toString()Ljava/lang/String;
	/* synthesized */ open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal open class kotlin.internal.jdk7.JDK7PlatformImplementations : kotlin.internal.PlatformImplementations {

	// *** NESTED TYPES ***

	class ReflectSdkVersion


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = addSuppressed(Ljava/lang/Throwable;Ljava/lang/Throwable;)V
	open fun addSuppressed(cause: Throwable, exception: Throwable)

	// JVM method = getSuppressed(Ljava/lang/Throwable;)Ljava/util/List;
	open fun getSuppressed(exception: Throwable): List<Throwable>

	// JVM method = sdkIsNullOrAtLeast(I)Z
	private fun sdkIsNullOrAtLeast(version: Int): Boolean
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.io.path.DirectoryEntriesReader : java.nio.file.SimpleFileVisitor<java.nio.file.Path> {

	// *** PROPERTIES ***

	// JVM field = directoryNode:Lkotlin/io/path/PathNode;
	private var directoryNode: kotlin.io.path.PathNode?

	// JVM field = entries:Lkotlin/collections/ArrayDeque;
	private var entries: ArrayDeque<kotlin.io.path.PathNode>

	// JVM field = followLinks:Z
	val followLinks: Boolean


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Z)V
	constructor(followLinks: Boolean)


	// *** FUNCTIONS ***

	// JVM method = preVisitDirectory(Ljava/nio/file/Path;Ljava/nio/file/attribute/BasicFileAttributes;)Ljava/nio/file/FileVisitResult;
	open fun preVisitDirectory(dir: java.nio.file.Path, attrs: java.nio.file.attribute.BasicFileAttributes): java.nio.file.FileVisitResult

	// JVM method = readEntries(Lkotlin/io/path/PathNode;)Ljava/util/List;
	fun readEntries(directoryNode: kotlin.io.path.PathNode): List<kotlin.io.path.PathNode>

	// JVM method = visitFile(Ljava/nio/file/Path;Ljava/nio/file/attribute/BasicFileAttributes;)Ljava/nio/file/FileVisitResult;
	open fun visitFile(file: java.nio.file.Path, attrs: java.nio.file.attribute.BasicFileAttributes): java.nio.file.FileVisitResult
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.io.path.ExceptionsCollector {

	// *** PROPERTIES ***

	// JVM field = collectedExceptions:Ljava/util/List;
	val collectedExceptions: MutableList<Exception /* = java.lang.Exception */>

	// JVM field = limit:I
	private val limit: Int

	// JVM field = path:Ljava/nio/file/Path;
	var path: java.nio.file.Path?

	// JVM field = totalExceptions:I
	var totalExceptions: Int
		private set(`<set-?>`: Int) { /* non-default */ }


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(limit: Int /* = default */)


	// *** FUNCTIONS ***

	// JVM method = collect(Ljava/lang/Exception;)V
	fun collect(exception: Exception /* = java.lang.Exception */)

	// JVM method = enterEntry(Ljava/nio/file/Path;)V
	fun enterEntry(name: java.nio.file.Path)

	// JVM method = exitEntry(Ljava/nio/file/Path;)V
	fun exitEntry(name: java.nio.file.Path)
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.io.path.FileVisitorBuilderImpl : kotlin.io.path.FileVisitorBuilder {

	// *** PROPERTIES ***

	// JVM field = isBuilt:Z
	private var isBuilt: Boolean

	// JVM field = onPostVisitDirectory:Lkotlin/jvm/functions/Function2;
	private var onPostVisitDirectory: ((java.nio.file.Path, java.io.IOException?) -> java.nio.file.FileVisitResult)?

	// JVM field = onPreVisitDirectory:Lkotlin/jvm/functions/Function2;
	private var onPreVisitDirectory: ((java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes) -> java.nio.file.FileVisitResult)?

	// JVM field = onVisitFile:Lkotlin/jvm/functions/Function2;
	private var onVisitFile: ((java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes) -> java.nio.file.FileVisitResult)?

	// JVM field = onVisitFileFailed:Lkotlin/jvm/functions/Function2;
	private var onVisitFileFailed: ((java.nio.file.Path, java.io.IOException) -> java.nio.file.FileVisitResult)?


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = build()Ljava/nio/file/FileVisitor;
	fun build(): java.nio.file.FileVisitor<java.nio.file.Path>

	// JVM method = checkIsNotBuilt()V
	private fun checkIsNotBuilt()

	// JVM method = checkNotDefined(Ljava/lang/Object;Ljava/lang/String;)V
	private fun checkNotDefined(function: Any?, name: String)

	// JVM method = onPostVisitDirectory(Lkotlin/jvm/functions/Function2;)V
	open fun onPostVisitDirectory(function: (@ParameterName(name = "directory") java.nio.file.Path, @ParameterName(name = "exception") java.io.IOException?) -> java.nio.file.FileVisitResult)

	// JVM method = onPreVisitDirectory(Lkotlin/jvm/functions/Function2;)V
	open fun onPreVisitDirectory(function: (@ParameterName(name = "directory") java.nio.file.Path, @ParameterName(name = "attributes") java.nio.file.attribute.BasicFileAttributes) -> java.nio.file.FileVisitResult)

	// JVM method = onVisitFile(Lkotlin/jvm/functions/Function2;)V
	open fun onVisitFile(function: (@ParameterName(name = "file") java.nio.file.Path, @ParameterName(name = "attributes") java.nio.file.attribute.BasicFileAttributes) -> java.nio.file.FileVisitResult)

	// JVM method = onVisitFileFailed(Lkotlin/jvm/functions/Function2;)V
	open fun onVisitFileFailed(function: (@ParameterName(name = "file") java.nio.file.Path, @ParameterName(name = "exception") java.io.IOException) -> java.nio.file.FileVisitResult)
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.io.path.FileVisitorImpl : java.nio.file.SimpleFileVisitor<java.nio.file.Path> {

	// *** PROPERTIES ***

	// JVM field = onPostVisitDirectory:Lkotlin/jvm/functions/Function2;
	private val onPostVisitDirectory: ((java.nio.file.Path, java.io.IOException?) -> java.nio.file.FileVisitResult)?

	// JVM field = onPreVisitDirectory:Lkotlin/jvm/functions/Function2;
	private val onPreVisitDirectory: ((java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes) -> java.nio.file.FileVisitResult)?

	// JVM field = onVisitFile:Lkotlin/jvm/functions/Function2;
	private val onVisitFile: ((java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes) -> java.nio.file.FileVisitResult)?

	// JVM field = onVisitFileFailed:Lkotlin/jvm/functions/Function2;
	private val onVisitFileFailed: ((java.nio.file.Path, java.io.IOException) -> java.nio.file.FileVisitResult)?


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/jvm/functions/Function2;Lkotlin/jvm/functions/Function2;Lkotlin/jvm/functions/Function2;Lkotlin/jvm/functions/Function2;)V
	constructor(onPreVisitDirectory: ((java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes) -> java.nio.file.FileVisitResult)?, onVisitFile: ((java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes) -> java.nio.file.FileVisitResult)?, onVisitFileFailed: ((java.nio.file.Path, java.io.IOException) -> java.nio.file.FileVisitResult)?, onPostVisitDirectory: ((java.nio.file.Path, java.io.IOException?) -> java.nio.file.FileVisitResult)?)


	// *** FUNCTIONS ***

	// JVM method = postVisitDirectory(Ljava/nio/file/Path;Ljava/io/IOException;)Ljava/nio/file/FileVisitResult;
	open fun postVisitDirectory(dir: java.nio.file.Path, exc: java.io.IOException?): java.nio.file.FileVisitResult

	// JVM method = preVisitDirectory(Ljava/nio/file/Path;Ljava/nio/file/attribute/BasicFileAttributes;)Ljava/nio/file/FileVisitResult;
	open fun preVisitDirectory(dir: java.nio.file.Path, attrs: java.nio.file.attribute.BasicFileAttributes): java.nio.file.FileVisitResult

	// JVM method = visitFile(Ljava/nio/file/Path;Ljava/nio/file/attribute/BasicFileAttributes;)Ljava/nio/file/FileVisitResult;
	open fun visitFile(file: java.nio.file.Path, attrs: java.nio.file.attribute.BasicFileAttributes): java.nio.file.FileVisitResult

	// JVM method = visitFileFailed(Ljava/nio/file/Path;Ljava/io/IOException;)Ljava/nio/file/FileVisitResult;
	open fun visitFileFailed(file: java.nio.file.Path, exc: java.io.IOException): java.nio.file.FileVisitResult
}

// ------------------------------------------------------------------------------------------------------

private class kotlin.io.path.PathNode {

	// *** PROPERTIES ***

	// JVM field = contentIterator:Ljava/util/Iterator;
	var contentIterator: Iterator<kotlin.io.path.PathNode>?

	// JVM field = key:Ljava/lang/Object;
	val key: Any?

	// JVM field = parent:Lkotlin/io/path/PathNode;
	val parent: kotlin.io.path.PathNode?

	// JVM field = path:Ljava/nio/file/Path;
	val path: java.nio.file.Path


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/nio/file/Path;Ljava/lang/Object;Lkotlin/io/path/PathNode;)V
	constructor(path: java.nio.file.Path, key: Any?, parent: kotlin.io.path.PathNode?)
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.io.path.PathTreeWalk : Sequence<java.nio.file.Path> {

	// *** PROPERTIES ***

	private val followLinks: Boolean
		// JVM method = getFollowLinks()Z
		get() = /* non-default */

	private val includeDirectories: Boolean
		// JVM method = getIncludeDirectories()Z
		get() = /* non-default */

	private val isBFS: Boolean
		// JVM method = isBFS()Z
		get() = /* non-default */

	private val linkOptions: Array<java.nio.file.LinkOption>
		// JVM method = getLinkOptions()[Ljava/nio/file/LinkOption;
		get() = /* non-default */

	// JVM field = options:[Lkotlin/io/path/PathWalkOption;
	private val options: Array<out kotlin.io.path.PathWalkOption>

	// JVM field = start:Ljava/nio/file/Path;
	private val start: java.nio.file.Path


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/nio/file/Path;[Lkotlin/io/path/PathWalkOption;)V
	constructor(start: java.nio.file.Path, options: Array<out kotlin.io.path.PathWalkOption>)


	// *** FUNCTIONS ***

	// JVM method = bfsIterator()Ljava/util/Iterator;
	private fun bfsIterator(): Iterator<java.nio.file.Path>

	// JVM method = dfsIterator()Ljava/util/Iterator;
	private fun dfsIterator(): Iterator<java.nio.file.Path>

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<java.nio.file.Path>

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = yieldIfNeeded(Lkotlin/sequences/SequenceScope;Lkotlin/io/path/PathNode;Lkotlin/io/path/DirectoryEntriesReader;Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	private suspend inline fun SequenceScope<java.nio.file.Path>.yieldIfNeeded(node: kotlin.io.path.PathNode, entriesReader: kotlin.io.path.DirectoryEntriesReader, entriesAction: (List<kotlin.io.path.PathNode>) -> Unit)
}

// ------------------------------------------------------------------------------------------------------

internal open class kotlin.internal.jdk8.JDK8PlatformImplementations : kotlin.internal.jdk7.JDK7PlatformImplementations {

	// *** NESTED TYPES ***

	class ReflectSdkVersion


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = defaultPlatformRandom()Lkotlin/random/Random;
	open fun defaultPlatformRandom(): kotlin.random.Random

	// JVM method = getMatchResultNamedGroup(Ljava/util/regex/MatchResult;Ljava/lang/String;)Lkotlin/text/MatchGroup;
	open fun getMatchResultNamedGroup(matchResult: java.util.regex.MatchResult, name: String): MatchGroup?

	// JVM method = sdkIsNullOrAtLeast(I)Z
	private fun sdkIsNullOrAtLeast(version: Int): Boolean
}

// ------------------------------------------------------------------------------------------------------

internal class kotlin.random.jdk8.PlatformThreadLocalRandom : kotlin.random.AbstractPlatformRandom {

	// *** PROPERTIES ***

	open val impl: java.util.Random
		// JVM method = getImpl()Ljava/util/Random;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()


	// *** FUNCTIONS ***

	// JVM method = nextDouble(D)D
	open fun nextDouble(until: Double): Double

	// JVM method = nextInt(II)I
	open fun nextInt(from: Int, until: Int): Int

	// JVM method = nextLong(J)J
	open fun nextLong(until: Long): Long

	// JVM method = nextLong(JJ)J
	open fun nextLong(from: Long, until: Long): Long
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

// anonymous object origin: SequencesKt__SequencesKt$Sequence$1
/* local */ class kotlin.sequences.SequencesKt__SequencesKt$Sequence$1 : Sequence<T#0> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<T#0>
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.KotlinVersion.Companion {

	// *** PROPERTIES ***

	// JVM field = CURRENT:Lkotlin/KotlinVersion;
	val CURRENT: KotlinVersion

	// JVM field = MAX_COMPONENT_VALUE:I
	const val MAX_COMPONENT_VALUE: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.KotlinVersionCurrentValue {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = get()Lkotlin/KotlinVersion;
	fun get(): KotlinVersion
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.Result.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = failure(Ljava/lang/Throwable;)Ljava/lang/Object;
	inline fun <T> failure(exception: Throwable): Result<T>

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = success(Ljava/lang/Object;)Ljava/lang/Object;
	inline fun <T> success(value: T): Result<T>
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.SafePublicationLazyImpl.Companion {

	// *** PROPERTIES ***

	// JVM field = valueUpdater:Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater;
	private val valueUpdater: java.util.concurrent.atomic.AtomicReferenceFieldUpdater<SafePublicationLazyImpl<*>!, Any!>!


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.UByte.Companion {

	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = MAX_VALUE:B
	const val MAX_VALUE: UByte

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = MIN_VALUE:B
	const val MIN_VALUE: UByte

	// JVM field = SIZE_BITS:I
	const val SIZE_BITS: Int

	// JVM field = SIZE_BYTES:I
	const val SIZE_BYTES: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.UInt.Companion {

	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = MAX_VALUE:I
	const val MAX_VALUE: UInt

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = MIN_VALUE:I
	const val MIN_VALUE: UInt

	// JVM field = SIZE_BITS:I
	const val SIZE_BITS: Int

	// JVM field = SIZE_BYTES:I
	const val SIZE_BYTES: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.ULong.Companion {

	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = MAX_VALUE:J
	const val MAX_VALUE: ULong

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = MIN_VALUE:J
	const val MIN_VALUE: ULong

	// JVM field = SIZE_BITS:I
	const val SIZE_BITS: Int

	// JVM field = SIZE_BYTES:I
	const val SIZE_BYTES: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.UNINITIALIZED_VALUE {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.UShort.Companion {

	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = MAX_VALUE:S
	const val MAX_VALUE: UShort

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = MIN_VALUE:S
	const val MIN_VALUE: UShort

	// JVM field = SIZE_BITS:I
	const val SIZE_BITS: Int

	// JVM field = SIZE_BYTES:I
	const val SIZE_BYTES: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

object kotlin.Unit {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin._Assertions {

	// *** PROPERTIES ***

	// JVM field = ENABLED:Z
	// JVM annotation-holding method = getENABLED$annotations()V
	internal val ENABLED: Boolean


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal companion object kotlin.collections.AbstractList.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = checkBoundsIndexes$kotlin_stdlib(III)V
	internal fun checkBoundsIndexes(startIndex: Int, endIndex: Int, size: Int)

	// JVM method = checkElementIndex$kotlin_stdlib(II)V
	internal fun checkElementIndex(index: Int, size: Int)

	// JVM method = checkPositionIndex$kotlin_stdlib(II)V
	internal fun checkPositionIndex(index: Int, size: Int)

	// JVM method = checkRangeIndexes$kotlin_stdlib(III)V
	internal fun checkRangeIndexes(fromIndex: Int, toIndex: Int, size: Int)

	// JVM method = orderedEquals$kotlin_stdlib(Ljava/util/Collection;Ljava/util/Collection;)Z
	internal fun orderedEquals(c: Collection<*>, other: Collection<*>): Boolean

	// JVM method = orderedHashCode$kotlin_stdlib(Ljava/util/Collection;)I
	internal fun orderedHashCode(c: Collection<*>): Int
}

// ------------------------------------------------------------------------------------------------------

internal companion object kotlin.collections.AbstractMap.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = entryEquals$kotlin_stdlib(Ljava/util/Map$Entry;Ljava/lang/Object;)Z
	internal fun entryEquals(e: Map.Entry<*, *>, other: Any?): Boolean

	// JVM method = entryHashCode$kotlin_stdlib(Ljava/util/Map$Entry;)I
	internal fun entryHashCode(e: Map.Entry<*, *>): Int

	// JVM method = entryToString$kotlin_stdlib(Ljava/util/Map$Entry;)Ljava/lang/String;
	internal fun entryToString(e: Map.Entry<*, *>): String
}

// ------------------------------------------------------------------------------------------------------

internal companion object kotlin.collections.AbstractSet.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = setEquals$kotlin_stdlib(Ljava/util/Set;Ljava/util/Set;)Z
	internal fun setEquals(c: Set<*>, other: Set<*>): Boolean

	// JVM method = unorderedHashCode$kotlin_stdlib(Ljava/util/Collection;)I
	internal fun unorderedHashCode(c: Collection<*>): Int
}

// ------------------------------------------------------------------------------------------------------

internal companion object kotlin.collections.ArrayDeque.Companion {

	// *** PROPERTIES ***

	// JVM field = defaultMinCapacity:I
	private const val defaultMinCapacity: Int

	// JVM field = emptyElementData:[Ljava/lang/Object;
	private val emptyElementData: Array<Any?>

	// JVM field = maxArraySize:I
	private const val maxArraySize: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = newCapacity$kotlin_stdlib(II)I
	internal fun newCapacity(oldCapacity: Int, minCapacity: Int): Int
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.collections.EmptyIterator : ListIterator<Nothing> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = hasNext()Z
	open operator fun hasNext(): Boolean

	// JVM method = hasPrevious()Z
	open fun hasPrevious(): Boolean

	// JVM method = next()Ljava/lang/Void;
	open operator fun next(): Nothing

	// JVM method = nextIndex()I
	open fun nextIndex(): Int

	// JVM method = previous()Ljava/lang/Void;
	open fun previous(): Nothing

	// JVM method = previousIndex()I
	open fun previousIndex(): Int
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.collections.EmptyList :
	List<Nothing>,
	Serializable /* = java.io.Serializable */,
	RandomAccess /* = java.util.RandomAccess */ {

	// *** PROPERTIES ***

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = contains(Ljava/lang/Void;)Z
	open operator fun contains(element: Nothing): Boolean

	// JVM method = containsAll(Ljava/util/Collection;)Z
	open fun containsAll(elements: Collection<Nothing>): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = get(I)Ljava/lang/Void;
	open operator fun get(index: Int): Nothing

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = indexOf(Ljava/lang/Void;)I
	open fun indexOf(element: Nothing): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<Nothing>

	// JVM method = lastIndexOf(Ljava/lang/Void;)I
	open fun lastIndexOf(element: Nothing): Int

	// JVM method = listIterator()Ljava/util/ListIterator;
	open fun listIterator(): ListIterator<Nothing>

	// JVM method = listIterator(I)Ljava/util/ListIterator;
	open fun listIterator(index: Int): ListIterator<Nothing>

	// JVM method = readResolve()Ljava/lang/Object;
	private fun readResolve(): Any

	// JVM method = subList(II)Ljava/util/List;
	open fun subList(fromIndex: Int, toIndex: Int): List<Nothing>

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.collections.EmptyMap : Map<Any?, Nothing>, Serializable /* = java.io.Serializable */ {

	// *** PROPERTIES ***

	open val entries: Set<Map.Entry<Any?, Nothing>>
		// JVM method = getEntries()Ljava/util/Set;
		get() = /* non-default */

	open val keys: Set<Any?>
		// JVM method = getKeys()Ljava/util/Set;
		get() = /* non-default */

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */

	open val values: Collection<Nothing>
		// JVM method = getValues()Ljava/util/Collection;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = containsKey(Ljava/lang/Object;)Z
	open fun containsKey(key: Any?): Boolean

	// JVM method = containsValue(Ljava/lang/Void;)Z
	open fun containsValue(value: Nothing): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = get(Ljava/lang/Object;)Ljava/lang/Void;
	open operator fun get(key: Any?): Nothing?

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = readResolve()Ljava/lang/Object;
	private fun readResolve(): Any

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.collections.EmptySet : Set<Nothing>, Serializable /* = java.io.Serializable */ {

	// *** PROPERTIES ***

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long

	open val size: Int
		// JVM method = getSize()I
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = contains(Ljava/lang/Void;)Z
	open operator fun contains(element: Nothing): Boolean

	// JVM method = containsAll(Ljava/util/Collection;)Z
	open fun containsAll(elements: Collection<Nothing>): Boolean

	// JVM method = equals(Ljava/lang/Object;)Z
	open operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<Nothing>

	// JVM method = readResolve()Ljava/lang/Object;
	private fun readResolve(): Any

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private companion object kotlin.collections.builders.MapBuilder.Companion {

	// *** PROPERTIES ***

	// JVM field = INITIAL_CAPACITY:I
	private const val INITIAL_CAPACITY: Int

	// JVM field = INITIAL_MAX_PROBE_DISTANCE:I
	private const val INITIAL_MAX_PROBE_DISTANCE: Int

	// JVM field = MAGIC:I
	private const val MAGIC: Int

	// JVM field = TOMBSTONE:I
	private const val TOMBSTONE: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = computeHashSize(I)I
	private fun computeHashSize(capacity: Int): Int

	// JVM method = computeShift(I)I
	private fun computeShift(hashSize: Int): Int
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.collections.builders.SerializedCollection.Companion {

	// *** PROPERTIES ***

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long

	// JVM field = tagList:I
	const val tagList: Int

	// JVM field = tagSet:I
	const val tagSet: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.collections.builders.SerializedMap.Companion {

	// *** PROPERTIES ***

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.comparisons.NaturalOrderComparator : Comparator<Comparable<Any>> /* = java.util.Comparator<Comparable<Any>> */ {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = compare(Ljava/lang/Comparable;Ljava/lang/Comparable;)I
	open fun compare(a: Comparable<Any>, b: Comparable<Any>): Int

	// JVM method = reversed()Ljava/util/Comparator;
	fun reversed(): Comparator<Comparable<Any>> /* = java.util.Comparator<Comparable<Any>> */
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.comparisons.ReverseOrderComparator : Comparator<Comparable<Any>> /* = java.util.Comparator<Comparable<Any>> */ {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = compare(Ljava/lang/Comparable;Ljava/lang/Comparable;)I
	open fun compare(a: Comparable<Any>, b: Comparable<Any>): Int

	// JVM method = reversed()Ljava/util/Comparator;
	fun reversed(): Comparator<Comparable<Any>> /* = java.util.Comparator<Comparable<Any>> */
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.coroutines.CombinedContext.Serialized.Companion {

	// *** PROPERTIES ***

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.coroutines.ContinuationInterceptor.Key : kotlin.coroutines.CoroutineContext.Key<kotlin.coroutines.ContinuationInterceptor> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

object kotlin.coroutines.EmptyCoroutineContext : kotlin.coroutines.CoroutineContext, Serializable /* = java.io.Serializable */ {

	// *** PROPERTIES ***

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = fold(Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
	open fun <R> fold(initial: R, operation: (R, kotlin.coroutines.CoroutineContext.Element) -> R): R

	// JVM method = get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;
	open operator fun <E : kotlin.coroutines.CoroutineContext.Element> get(key: kotlin.coroutines.CoroutineContext.Key<E : kotlin.coroutines.CoroutineContext.Element>): E : kotlin.coroutines.CoroutineContext.Element?

	// JVM method = hashCode()I
	open fun hashCode(): Int

	// JVM method = minusKey(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext;
	open fun minusKey(key: kotlin.coroutines.CoroutineContext.Key<*>): kotlin.coroutines.CoroutineContext

	// JVM method = plus(Lkotlin/coroutines/CoroutineContext;)Lkotlin/coroutines/CoroutineContext;
	open operator fun plus(context: kotlin.coroutines.CoroutineContext): kotlin.coroutines.CoroutineContext

	// JVM method = readResolve()Ljava/lang/Object;
	private fun readResolve(): Any

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private companion object kotlin.coroutines.SafeContinuation.Companion {

	// *** PROPERTIES ***

	// JVM field = RESULT:Ljava/util/concurrent/atomic/AtomicReferenceFieldUpdater;
	// JVM annotation-holding method = getRESULT$annotations()V
	private val RESULT: java.util.concurrent.atomic.AtomicReferenceFieldUpdater<kotlin.coroutines.SafeContinuation<*>!, Any!>!


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.coroutines.jvm.internal.CompletedContinuation : kotlin.coroutines.Continuation<Any?> {

	// *** PROPERTIES ***

	open val context: kotlin.coroutines.CoroutineContext
		// JVM method = getContext()Lkotlin/coroutines/CoroutineContext;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = resumeWith(Ljava/lang/Object;)V
	open fun resumeWith(result: Result<Any?>)

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.coroutines.jvm.internal.ModuleNameRetriever {

	// *** NESTED TYPES ***

	class Cache


	// *** PROPERTIES ***

	// JVM field = cache:Lkotlin/coroutines/jvm/internal/ModuleNameRetriever$Cache;
	private var cache: kotlin.coroutines.jvm.internal.ModuleNameRetriever.Cache?

	// JVM field = notOnJava9:Lkotlin/coroutines/jvm/internal/ModuleNameRetriever$Cache;
	private val notOnJava9: kotlin.coroutines.jvm.internal.ModuleNameRetriever.Cache


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = buildCache(Lkotlin/coroutines/jvm/internal/BaseContinuationImpl;)Lkotlin/coroutines/jvm/internal/ModuleNameRetriever$Cache;
	private fun buildCache(continuation: kotlin.coroutines.jvm.internal.BaseContinuationImpl): kotlin.coroutines.jvm.internal.ModuleNameRetriever.Cache

	// JVM method = getModuleName(Lkotlin/coroutines/jvm/internal/BaseContinuationImpl;)Ljava/lang/String;
	fun getModuleName(continuation: kotlin.coroutines.jvm.internal.BaseContinuationImpl): String?
}

// ------------------------------------------------------------------------------------------------------

private companion object kotlin.enums.EnumEntriesSerializationProxy.Companion {

	// *** PROPERTIES ***

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.internal.PlatformImplementations.ReflectThrowable {

	// *** PROPERTIES ***

	// JVM field = addSuppressed:Ljava/lang/reflect/Method;
	val addSuppressed: java.lang.reflect.Method?

	// JVM field = getSuppressed:Ljava/lang/reflect/Method;
	val getSuppressed: java.lang.reflect.Method?


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.io.LineReader {

	// *** PROPERTIES ***

	// JVM field = BUFFER_SIZE:I
	private const val BUFFER_SIZE: Int

	// JVM field = byteBuf:Ljava/nio/ByteBuffer;
	private val byteBuf: java.nio.ByteBuffer

	// JVM field = bytes:[B
	private val bytes: ByteArray

	// JVM field = charBuf:Ljava/nio/CharBuffer;
	private val charBuf: java.nio.CharBuffer

	// JVM field = chars:[C
	private val chars: CharArray

	// JVM field = decoder:Ljava/nio/charset/CharsetDecoder;
	private lateinit var decoder: java.nio.charset.CharsetDecoder

	// JVM field = directEOL:Z
	private var directEOL: Boolean

	// JVM field = sb:Ljava/lang/StringBuilder;
	private val sb: StringBuilder /* = java.lang.StringBuilder */


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = compactBytes()I
	private fun compactBytes(): Int

	// JVM method = decode(Z)I
	private fun decode(endOfInput: Boolean): Int

	// JVM method = decodeEndOfInput(II)I
	private fun decodeEndOfInput(nBytes: Int, nChars: Int): Int

	// JVM method = readLine(Ljava/io/InputStream;Ljava/nio/charset/Charset;)Ljava/lang/String;
	fun readLine(inputStream: java.io.InputStream, charset: java.nio.charset.Charset): String?

	// JVM method = resetAll()V
	private fun resetAll()

	// JVM method = trimStringBuilder()V
	private fun trimStringBuilder()

	// JVM method = updateCharset(Ljava/nio/charset/Charset;)V
	private fun updateCharset(charset: java.nio.charset.Charset)
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.io.encoding.Base64.Default : kotlin.io.encoding.Base64 {

	// *** PROPERTIES ***

	// JVM field = Mime:Lkotlin/io/encoding/Base64;
	val Mime: kotlin.io.encoding.Base64

	// JVM field = UrlSafe:Lkotlin/io/encoding/Base64;
	val UrlSafe: kotlin.io.encoding.Base64

	// JVM field = bitsPerByte:I
	private const val bitsPerByte: Int

	// JVM field = bitsPerSymbol:I
	private const val bitsPerSymbol: Int

	// JVM field = bytesPerGroup:I
	internal const val bytesPerGroup: Int

	// JVM field = mimeGroupsPerLine:I
	private const val mimeGroupsPerLine: Int

	// JVM field = mimeLineLength:I
	internal const val mimeLineLength: Int

	// JVM field = mimeLineSeparatorSymbols:[B
	internal val mimeLineSeparatorSymbols: ByteArray

	// JVM field = padSymbol:B
	internal const val padSymbol: Byte

	// JVM field = symbolsPerGroup:I
	internal const val symbolsPerGroup: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.jvm.internal.BooleanCompanionObject {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.jvm.internal.ByteCompanionObject {

	// *** PROPERTIES ***

	// JVM field = MAX_VALUE:B
	const val MAX_VALUE: Byte

	// JVM field = MIN_VALUE:B
	const val MIN_VALUE: Byte

	// JVM field = SIZE_BITS:I
	// JVM annotation-holding method = getSIZE_BITS$annotations()V
	const val SIZE_BITS: Int

	// JVM field = SIZE_BYTES:I
	// JVM annotation-holding method = getSIZE_BYTES$annotations()V
	const val SIZE_BYTES: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.jvm.internal.CharCompanionObject {

	// *** PROPERTIES ***

	// JVM field = MAX_HIGH_SURROGATE:C
	const val MAX_HIGH_SURROGATE: Char

	// JVM field = MAX_LOW_SURROGATE:C
	const val MAX_LOW_SURROGATE: Char

	// JVM field = MAX_SURROGATE:C
	const val MAX_SURROGATE: Char

	// JVM field = MAX_VALUE:C
	// JVM annotation-holding method = getMAX_VALUE$annotations()V
	const val MAX_VALUE: Char

	// JVM field = MIN_HIGH_SURROGATE:C
	const val MIN_HIGH_SURROGATE: Char

	// JVM field = MIN_LOW_SURROGATE:C
	const val MIN_LOW_SURROGATE: Char

	// JVM field = MIN_SURROGATE:C
	const val MIN_SURROGATE: Char

	// JVM field = MIN_VALUE:C
	// JVM annotation-holding method = getMIN_VALUE$annotations()V
	const val MIN_VALUE: Char

	// JVM field = SIZE_BITS:I
	// JVM annotation-holding method = getSIZE_BITS$annotations()V
	const val SIZE_BITS: Int

	// JVM field = SIZE_BYTES:I
	// JVM annotation-holding method = getSIZE_BYTES$annotations()V
	const val SIZE_BYTES: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.jvm.internal.ClassReference.Companion {

	// *** PROPERTIES ***

	// JVM field = FUNCTION_CLASSES:Ljava/util/Map;
	private val FUNCTION_CLASSES: Map<java.lang.Class<out Function<*>>, Int>

	// JVM field = classFqNames:Ljava/util/HashMap;
	private val classFqNames: HashMap<String, String> /* = java.util.HashMap<String, String> */

	// JVM field = primitiveFqNames:Ljava/util/HashMap;
	private val primitiveFqNames: HashMap<String, String> /* = java.util.HashMap<String, String> */

	// JVM field = primitiveWrapperFqNames:Ljava/util/HashMap;
	private val primitiveWrapperFqNames: HashMap<String, String> /* = java.util.HashMap<String, String> */

	// JVM field = simpleNames:Ljava/util/Map;
	private val simpleNames: Map<String, String>


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = getClassQualifiedName(Ljava/lang/Class;)Ljava/lang/String;
	fun getClassQualifiedName(jClass: java.lang.Class<*>): String?

	// JVM method = getClassSimpleName(Ljava/lang/Class;)Ljava/lang/String;
	fun getClassSimpleName(jClass: java.lang.Class<*>): String?

	// JVM method = isInstance(Ljava/lang/Object;Ljava/lang/Class;)Z
	fun isInstance(value: Any?, jClass: java.lang.Class<*>): Boolean
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.jvm.internal.DoubleCompanionObject {

	// *** PROPERTIES ***

	// JVM field = MAX_VALUE:D
	// JVM annotation-holding method = getMAX_VALUE$annotations()V
	const val MAX_VALUE: Double

	// JVM field = MIN_VALUE:D
	// JVM annotation-holding method = getMIN_VALUE$annotations()V
	const val MIN_VALUE: Double

	// JVM field = NEGATIVE_INFINITY:D
	// JVM annotation-holding method = getNEGATIVE_INFINITY$annotations()V
	const val NEGATIVE_INFINITY: Double

	// JVM field = NaN:D
	// JVM annotation-holding method = getNaN$annotations()V
	const val NaN: Double

	// JVM field = POSITIVE_INFINITY:D
	// JVM annotation-holding method = getPOSITIVE_INFINITY$annotations()V
	const val POSITIVE_INFINITY: Double

	// JVM field = SIZE_BITS:I
	// JVM annotation-holding method = getSIZE_BITS$annotations()V
	const val SIZE_BITS: Int

	// JVM field = SIZE_BYTES:I
	// JVM annotation-holding method = getSIZE_BYTES$annotations()V
	const val SIZE_BYTES: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = getMAX_VALUE()D
	fun getMAX_VALUE(): Double

	// JVM method = getMIN_VALUE()D
	fun getMIN_VALUE(): Double

	// JVM method = getNEGATIVE_INFINITY()D
	fun getNEGATIVE_INFINITY(): Double

	// JVM method = getNaN()D
	fun getNaN(): Double

	// JVM method = getPOSITIVE_INFINITY()D
	fun getPOSITIVE_INFINITY(): Double
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.jvm.internal.EnumCompanionObject {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.jvm.internal.FloatCompanionObject {

	// *** PROPERTIES ***

	// JVM field = MAX_VALUE:F
	// JVM annotation-holding method = getMAX_VALUE$annotations()V
	const val MAX_VALUE: Float

	// JVM field = MIN_VALUE:F
	// JVM annotation-holding method = getMIN_VALUE$annotations()V
	const val MIN_VALUE: Float

	// JVM field = NEGATIVE_INFINITY:F
	// JVM annotation-holding method = getNEGATIVE_INFINITY$annotations()V
	const val NEGATIVE_INFINITY: Float

	// JVM field = NaN:F
	// JVM annotation-holding method = getNaN$annotations()V
	const val NaN: Float

	// JVM field = POSITIVE_INFINITY:F
	// JVM annotation-holding method = getPOSITIVE_INFINITY$annotations()V
	const val POSITIVE_INFINITY: Float

	// JVM field = SIZE_BITS:I
	// JVM annotation-holding method = getSIZE_BITS$annotations()V
	const val SIZE_BITS: Int

	// JVM field = SIZE_BYTES:I
	// JVM annotation-holding method = getSIZE_BYTES$annotations()V
	const val SIZE_BYTES: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = getMAX_VALUE()F
	fun getMAX_VALUE(): Float

	// JVM method = getMIN_VALUE()F
	fun getMIN_VALUE(): Float

	// JVM method = getNEGATIVE_INFINITY()F
	fun getNEGATIVE_INFINITY(): Float

	// JVM method = getNaN()F
	fun getNaN(): Float

	// JVM method = getPOSITIVE_INFINITY()F
	fun getPOSITIVE_INFINITY(): Float
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.jvm.internal.IntCompanionObject {

	// *** PROPERTIES ***

	// JVM field = MAX_VALUE:I
	const val MAX_VALUE: Int

	// JVM field = MIN_VALUE:I
	const val MIN_VALUE: Int

	// JVM field = SIZE_BITS:I
	// JVM annotation-holding method = getSIZE_BITS$annotations()V
	const val SIZE_BITS: Int

	// JVM field = SIZE_BYTES:I
	// JVM annotation-holding method = getSIZE_BYTES$annotations()V
	const val SIZE_BYTES: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.jvm.internal.LongCompanionObject {

	// *** PROPERTIES ***

	// JVM field = MAX_VALUE:J
	const val MAX_VALUE: Long

	// JVM field = MIN_VALUE:J
	const val MIN_VALUE: Long

	// JVM field = SIZE_BITS:I
	// JVM annotation-holding method = getSIZE_BITS$annotations()V
	const val SIZE_BITS: Int

	// JVM field = SIZE_BYTES:I
	// JVM annotation-holding method = getSIZE_BYTES$annotations()V
	const val SIZE_BYTES: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.jvm.internal.ShortCompanionObject {

	// *** PROPERTIES ***

	// JVM field = MAX_VALUE:S
	const val MAX_VALUE: Short

	// JVM field = MIN_VALUE:S
	const val MIN_VALUE: Short

	// JVM field = SIZE_BITS:I
	// JVM annotation-holding method = getSIZE_BITS$annotations()V
	const val SIZE_BITS: Int

	// JVM field = SIZE_BYTES:I
	// JVM annotation-holding method = getSIZE_BYTES$annotations()V
	const val SIZE_BYTES: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.jvm.internal.StringCompanionObject {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.jvm.internal.TypeParameterReference.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = toString(Lkotlin/reflect/KTypeParameter;)Ljava/lang/String;
	fun toString(typeParameter: kotlin.reflect.KTypeParameter): String
}

// ------------------------------------------------------------------------------------------------------

internal companion object kotlin.jvm.internal.TypeReference.Companion {

	// *** PROPERTIES ***

	// JVM field = IS_MARKED_NULLABLE:I
	internal const val IS_MARKED_NULLABLE: Int

	// JVM field = IS_MUTABLE_COLLECTION_TYPE:I
	internal const val IS_MUTABLE_COLLECTION_TYPE: Int

	// JVM field = IS_NOTHING_TYPE:I
	internal const val IS_NOTHING_TYPE: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.math.Constants {

	// *** PROPERTIES ***

	// JVM field = LN2:D
	internal val LN2: Double

	// JVM field = epsilon:D
	internal val epsilon: Double

	// JVM field = taylor_2_bound:D
	internal val taylor_2_bound: Double

	// JVM field = taylor_n_bound:D
	internal val taylor_n_bound: Double

	// JVM field = upper_taylor_2_bound:D
	internal val upper_taylor_2_bound: Double

	// JVM field = upper_taylor_n_bound:D
	internal val upper_taylor_n_bound: Double


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

object kotlin.properties.Delegates {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = notNull()Lkotlin/properties/ReadWriteProperty;
	fun <T : Any> notNull(): kotlin.properties.ReadWriteProperty<Any?, T : Any>

	// requires compiler version >= 1.3.50, otherwise diagnostic error
	// JVM method = observable(Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Lkotlin/properties/ReadWriteProperty;
	inline fun <T> observable(initialValue: T, crossinline onChange: (@ParameterName(name = "property") kotlin.reflect.KProperty<*>, @ParameterName(name = "oldValue") T, @ParameterName(name = "newValue") T) -> Unit): kotlin.properties.ReadWriteProperty<Any?, T>

	// requires compiler version >= 1.3.50, otherwise diagnostic error
	// JVM method = vetoable(Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Lkotlin/properties/ReadWriteProperty;
	inline fun <T> vetoable(initialValue: T, crossinline onChange: (@ParameterName(name = "property") kotlin.reflect.KProperty<*>, @ParameterName(name = "oldValue") T, @ParameterName(name = "newValue") T) -> Boolean): kotlin.properties.ReadWriteProperty<Any?, T>
}

// ------------------------------------------------------------------------------------------------------

private companion object kotlin.random.KotlinRandom.Companion {

	// *** PROPERTIES ***

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

private companion object kotlin.random.PlatformRandom.Companion {

	// *** PROPERTIES ***

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.random.Random.Default.Serialized : Serializable /* = java.io.Serializable */ {

	// *** PROPERTIES ***

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = readResolve()Ljava/lang/Object;
	private fun readResolve(): Any
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.random.Random.Default : kotlin.random.Random, Serializable /* = java.io.Serializable */ {

	// *** NESTED TYPES ***

	class Serialized


	// *** PROPERTIES ***

	// JVM field = defaultRandom:Lkotlin/random/Random;
	private val defaultRandom: kotlin.random.Random


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = nextBits(I)I
	open fun nextBits(bitCount: Int): Int

	// JVM method = nextBoolean()Z
	open fun nextBoolean(): Boolean

	// JVM method = nextBytes([B)[B
	open fun nextBytes(array: ByteArray): ByteArray

	// JVM method = nextBytes([BII)[B
	open fun nextBytes(array: ByteArray, fromIndex: Int, toIndex: Int): ByteArray

	// JVM method = nextBytes(I)[B
	open fun nextBytes(size: Int): ByteArray

	// JVM method = nextDouble()D
	open fun nextDouble(): Double

	// JVM method = nextDouble(D)D
	open fun nextDouble(until: Double): Double

	// JVM method = nextDouble(DD)D
	open fun nextDouble(from: Double, until: Double): Double

	// JVM method = nextFloat()F
	open fun nextFloat(): Float

	// JVM method = nextInt()I
	open fun nextInt(): Int

	// JVM method = nextInt(I)I
	open fun nextInt(until: Int): Int

	// JVM method = nextInt(II)I
	open fun nextInt(from: Int, until: Int): Int

	// JVM method = nextLong()J
	open fun nextLong(): Long

	// JVM method = nextLong(J)J
	open fun nextLong(until: Long): Long

	// JVM method = nextLong(JJ)J
	open fun nextLong(from: Long, until: Long): Long

	// JVM method = writeReplace()Ljava/lang/Object;
	private fun writeReplace(): Any
}

// ------------------------------------------------------------------------------------------------------

private companion object kotlin.random.XorWowRandom.Companion {

	// *** PROPERTIES ***

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.ranges.CharProgression.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = fromClosedRange(CCI)Lkotlin/ranges/CharProgression;
	fun fromClosedRange(rangeStart: Char, rangeEnd: Char, step: Int): CharProgression
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.ranges.CharRange.Companion {

	// *** PROPERTIES ***

	// JVM field = EMPTY:Lkotlin/ranges/CharRange;
	val EMPTY: CharRange


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.ranges.IntProgression.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = fromClosedRange(III)Lkotlin/ranges/IntProgression;
	fun fromClosedRange(rangeStart: Int, rangeEnd: Int, step: Int): IntProgression
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.ranges.IntRange.Companion {

	// *** PROPERTIES ***

	// JVM field = EMPTY:Lkotlin/ranges/IntRange;
	val EMPTY: IntRange


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.ranges.LongProgression.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = fromClosedRange(JJJ)Lkotlin/ranges/LongProgression;
	fun fromClosedRange(rangeStart: Long, rangeEnd: Long, step: Long): LongProgression
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.ranges.LongRange.Companion {

	// *** PROPERTIES ***

	// JVM field = EMPTY:Lkotlin/ranges/LongRange;
	val EMPTY: LongRange


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.ranges.UIntProgression.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = fromClosedRange-Nkh28Cs(III)Lkotlin/ranges/UIntProgression;
	fun fromClosedRange(rangeStart: UInt, rangeEnd: UInt, step: Int): UIntProgression
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.ranges.UIntRange.Companion {

	// *** PROPERTIES ***

	// JVM field = EMPTY:Lkotlin/ranges/UIntRange;
	val EMPTY: UIntRange


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.ranges.ULongProgression.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = fromClosedRange-7ftBX0g(JJJ)Lkotlin/ranges/ULongProgression;
	fun fromClosedRange(rangeStart: ULong, rangeEnd: ULong, step: Long): ULongProgression
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.ranges.ULongRange.Companion {

	// *** PROPERTIES ***

	// JVM field = EMPTY:Lkotlin/ranges/ULongRange;
	val EMPTY: ULongRange


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.reflect.KTypeProjection.Companion {

	// *** PROPERTIES ***

	val STAR: kotlin.reflect.KTypeProjection
		// JVM method = getSTAR()Lkotlin/reflect/KTypeProjection;
		get() = /* non-default */

	// JVM field = star:Lkotlin/reflect/KTypeProjection;
	// JVM annotation-holding method = getStar$annotations()V
	internal val star: kotlin.reflect.KTypeProjection


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = contravariant(Lkotlin/reflect/KType;)Lkotlin/reflect/KTypeProjection;
	fun contravariant(type: kotlin.reflect.KType): kotlin.reflect.KTypeProjection

	// JVM method = covariant(Lkotlin/reflect/KType;)Lkotlin/reflect/KTypeProjection;
	fun covariant(type: kotlin.reflect.KType): kotlin.reflect.KTypeProjection

	// JVM method = invariant(Lkotlin/reflect/KType;)Lkotlin/reflect/KTypeProjection;
	fun invariant(type: kotlin.reflect.KType): kotlin.reflect.KTypeProjection
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.reflect.WildcardTypeImpl.Companion {

	// *** PROPERTIES ***

	// JVM field = STAR:Lkotlin/reflect/WildcardTypeImpl;
	val STAR: kotlin.reflect.WildcardTypeImpl


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.sequences.EmptySequence : Sequence<Nothing>, DropTakeSequence<Nothing> {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = drop(I)Lkotlin/sequences/EmptySequence;
	open fun drop(n: Int): EmptySequence

	// JVM method = iterator()Ljava/util/Iterator;
	open operator fun iterator(): Iterator<Nothing>

	// JVM method = take(I)Lkotlin/sequences/EmptySequence;
	open fun take(n: Int): EmptySequence
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.text.CharCategory.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = valueOf(I)Lkotlin/text/CharCategory;
	fun valueOf(category: Int): CharCategory
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.text.CharDirectionality.Companion {

	// *** PROPERTIES ***

	// JVM field = directionalityMap$delegate:Lkotlin/Lazy;
	private val directionalityMap: Map<Int, CharDirectionality> by <delegate>
		// JVM method = getDirectionalityMap()Ljava/util/Map;
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = valueOf(I)Lkotlin/text/CharDirectionality;
	fun valueOf(directionality: Int): CharDirectionality
}

// ------------------------------------------------------------------------------------------------------

object kotlin.text.Charsets {

	// *** PROPERTIES ***

	// JVM field = ISO_8859_1:Ljava/nio/charset/Charset;
	val ISO_8859_1: java.nio.charset.Charset

	// JVM field = US_ASCII:Ljava/nio/charset/Charset;
	val US_ASCII: java.nio.charset.Charset

	// JVM field = UTF_16:Ljava/nio/charset/Charset;
	val UTF_16: java.nio.charset.Charset

	// JVM field = UTF_16BE:Ljava/nio/charset/Charset;
	val UTF_16BE: java.nio.charset.Charset

	// JVM field = UTF_16LE:Ljava/nio/charset/Charset;
	val UTF_16LE: java.nio.charset.Charset

	val UTF_32: java.nio.charset.Charset
		// JVM method = UTF32()Ljava/nio/charset/Charset;
		get() = /* non-default */

	val UTF_32BE: java.nio.charset.Charset
		// JVM method = UTF32_BE()Ljava/nio/charset/Charset;
		get() = /* non-default */

	val UTF_32LE: java.nio.charset.Charset
		// JVM method = UTF32_LE()Ljava/nio/charset/Charset;
		get() = /* non-default */

	// JVM field = UTF_8:Ljava/nio/charset/Charset;
	val UTF_8: java.nio.charset.Charset

	// JVM field = utf_32:Ljava/nio/charset/Charset;
	private var utf_32: java.nio.charset.Charset?

	// JVM field = utf_32be:Ljava/nio/charset/Charset;
	private var utf_32be: java.nio.charset.Charset?

	// JVM field = utf_32le:Ljava/nio/charset/Charset;
	private var utf_32le: java.nio.charset.Charset?


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.text.Regex.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = ensureUnicodeCase(I)I
	private fun ensureUnicodeCase(flags: Int): Int

	// JVM method = escape(Ljava/lang/String;)Ljava/lang/String;
	fun escape(literal: String): String

	// JVM method = escapeReplacement(Ljava/lang/String;)Ljava/lang/String;
	fun escapeReplacement(literal: String): String

	// JVM method = fromLiteral(Ljava/lang/String;)Lkotlin/text/Regex;
	fun fromLiteral(literal: String): Regex
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.text.Regex.Serialized.Companion {

	// *** PROPERTIES ***

	// JVM field = serialVersionUID:J
	private const val serialVersionUID: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.text.ScreenFloatValueRegEx {

	// *** PROPERTIES ***

	// JVM field = value:Lkotlin/text/Regex;
	val value: Regex


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.text.SystemProperties {

	// *** PROPERTIES ***

	// JVM field = LINE_SEPARATOR:Ljava/lang/String;
	val LINE_SEPARATOR: String


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

object kotlin.text.Typography {

	// *** PROPERTIES ***

	// JVM field = almostEqual:C
	const val almostEqual: Char

	// JVM field = amp:C
	const val amp: Char

	// JVM field = bullet:C
	const val bullet: Char

	// JVM field = cent:C
	const val cent: Char

	// JVM field = copyright:C
	const val copyright: Char

	// JVM field = dagger:C
	const val dagger: Char

	// JVM field = degree:C
	const val degree: Char

	// JVM field = dollar:C
	const val dollar: Char

	// JVM field = doubleDagger:C
	const val doubleDagger: Char

	// JVM field = doublePrime:C
	const val doublePrime: Char

	// JVM field = ellipsis:C
	const val ellipsis: Char

	// JVM field = euro:C
	const val euro: Char

	// JVM field = greater:C
	const val greater: Char

	// JVM field = greaterOrEqual:C
	const val greaterOrEqual: Char

	// JVM field = half:C
	const val half: Char

	// JVM field = leftDoubleQuote:C
	const val leftDoubleQuote: Char

	// JVM field = leftGuillemet:C
	// JVM annotation-holding method = getLeftGuillemet$annotations()V
	const val leftGuillemet: Char

	// JVM field = leftGuillemete:C
	// JVM annotation-holding method = getLeftGuillemete$annotations()V
	const val leftGuillemete: Char

	// JVM field = leftSingleQuote:C
	const val leftSingleQuote: Char

	// JVM field = less:C
	const val less: Char

	// JVM field = lessOrEqual:C
	const val lessOrEqual: Char

	// JVM field = lowDoubleQuote:C
	const val lowDoubleQuote: Char

	// JVM field = lowSingleQuote:C
	const val lowSingleQuote: Char

	// JVM field = mdash:C
	const val mdash: Char

	// JVM field = middleDot:C
	const val middleDot: Char

	// JVM field = nbsp:C
	const val nbsp: Char

	// JVM field = ndash:C
	const val ndash: Char

	// JVM field = notEqual:C
	const val notEqual: Char

	// JVM field = paragraph:C
	const val paragraph: Char

	// JVM field = plusMinus:C
	const val plusMinus: Char

	// JVM field = pound:C
	const val pound: Char

	// JVM field = prime:C
	const val prime: Char

	// JVM field = quote:C
	const val quote: Char

	// JVM field = registered:C
	const val registered: Char

	// JVM field = rightDoubleQuote:C
	const val rightDoubleQuote: Char

	// JVM field = rightGuillemet:C
	// JVM annotation-holding method = getRightGuillemet$annotations()V
	const val rightGuillemet: Char

	// JVM field = rightGuillemete:C
	// JVM annotation-holding method = getRightGuillemete$annotations()V
	const val rightGuillemete: Char

	// JVM field = rightSingleQuote:C
	const val rightSingleQuote: Char

	// JVM field = section:C
	const val section: Char

	// JVM field = times:C
	const val times: Char

	// JVM field = tm:C
	const val tm: Char


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.time.Duration.Companion {

	// *** PROPERTIES ***

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = INFINITE:J
	val INFINITE: kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = NEG_INFINITE:J
	internal val NEG_INFINITE: kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM field = ZERO:J
	val ZERO: kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getDays-UwyO8pc$annotations(D)V
	inline val Double.days: kotlin.time.Duration
		// JVM method = getDays-UwyO8pc(D)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getDays-UwyO8pc$annotations(I)V
	inline val Int.days: kotlin.time.Duration
		// JVM method = getDays-UwyO8pc(I)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getDays-UwyO8pc$annotations(J)V
	inline val Long.days: kotlin.time.Duration
		// JVM method = getDays-UwyO8pc(J)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getHours-UwyO8pc$annotations(D)V
	inline val Double.hours: kotlin.time.Duration
		// JVM method = getHours-UwyO8pc(D)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getHours-UwyO8pc$annotations(I)V
	inline val Int.hours: kotlin.time.Duration
		// JVM method = getHours-UwyO8pc(I)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getHours-UwyO8pc$annotations(J)V
	inline val Long.hours: kotlin.time.Duration
		// JVM method = getHours-UwyO8pc(J)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getMicroseconds-UwyO8pc$annotations(D)V
	inline val Double.microseconds: kotlin.time.Duration
		// JVM method = getMicroseconds-UwyO8pc(D)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getMicroseconds-UwyO8pc$annotations(I)V
	inline val Int.microseconds: kotlin.time.Duration
		// JVM method = getMicroseconds-UwyO8pc(I)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getMicroseconds-UwyO8pc$annotations(J)V
	inline val Long.microseconds: kotlin.time.Duration
		// JVM method = getMicroseconds-UwyO8pc(J)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getMilliseconds-UwyO8pc$annotations(D)V
	inline val Double.milliseconds: kotlin.time.Duration
		// JVM method = getMilliseconds-UwyO8pc(D)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getMilliseconds-UwyO8pc$annotations(I)V
	inline val Int.milliseconds: kotlin.time.Duration
		// JVM method = getMilliseconds-UwyO8pc(I)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getMilliseconds-UwyO8pc$annotations(J)V
	inline val Long.milliseconds: kotlin.time.Duration
		// JVM method = getMilliseconds-UwyO8pc(J)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getMinutes-UwyO8pc$annotations(D)V
	inline val Double.minutes: kotlin.time.Duration
		// JVM method = getMinutes-UwyO8pc(D)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getMinutes-UwyO8pc$annotations(I)V
	inline val Int.minutes: kotlin.time.Duration
		// JVM method = getMinutes-UwyO8pc(I)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getMinutes-UwyO8pc$annotations(J)V
	inline val Long.minutes: kotlin.time.Duration
		// JVM method = getMinutes-UwyO8pc(J)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getNanoseconds-UwyO8pc$annotations(D)V
	inline val Double.nanoseconds: kotlin.time.Duration
		// JVM method = getNanoseconds-UwyO8pc(D)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getNanoseconds-UwyO8pc$annotations(I)V
	inline val Int.nanoseconds: kotlin.time.Duration
		// JVM method = getNanoseconds-UwyO8pc(I)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getNanoseconds-UwyO8pc$annotations(J)V
	inline val Long.nanoseconds: kotlin.time.Duration
		// JVM method = getNanoseconds-UwyO8pc(J)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getSeconds-UwyO8pc$annotations(D)V
	inline val Double.seconds: kotlin.time.Duration
		// JVM method = getSeconds-UwyO8pc(D)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getSeconds-UwyO8pc$annotations(I)V
	inline val Int.seconds: kotlin.time.Duration
		// JVM method = getSeconds-UwyO8pc(I)J
		get() = /* non-default */

	// requires language version >= 1.3, otherwise diagnostic error
	// requires language version >= 1.4, otherwise diagnostic error
	// JVM annotation-holding method = getSeconds-UwyO8pc$annotations(J)V
	inline val Long.seconds: kotlin.time.Duration
		// JVM method = getSeconds-UwyO8pc(J)J
		get() = /* non-default */


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = convert(DLkotlin/time/DurationUnit;Lkotlin/time/DurationUnit;)D
	fun convert(value: Double, sourceUnit: kotlin.time.DurationUnit, targetUnit: kotlin.time.DurationUnit): Double

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = days-UwyO8pc(D)J
	fun days(value: Double): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = days-UwyO8pc(I)J
	fun days(value: Int): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = days-UwyO8pc(J)J
	fun days(value: Long): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = hours-UwyO8pc(D)J
	fun hours(value: Double): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = hours-UwyO8pc(I)J
	fun hours(value: Int): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = hours-UwyO8pc(J)J
	fun hours(value: Long): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = microseconds-UwyO8pc(D)J
	fun microseconds(value: Double): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = microseconds-UwyO8pc(I)J
	fun microseconds(value: Int): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = microseconds-UwyO8pc(J)J
	fun microseconds(value: Long): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = milliseconds-UwyO8pc(D)J
	fun milliseconds(value: Double): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = milliseconds-UwyO8pc(I)J
	fun milliseconds(value: Int): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = milliseconds-UwyO8pc(J)J
	fun milliseconds(value: Long): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minutes-UwyO8pc(D)J
	fun minutes(value: Double): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minutes-UwyO8pc(I)J
	fun minutes(value: Int): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minutes-UwyO8pc(J)J
	fun minutes(value: Long): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = nanoseconds-UwyO8pc(D)J
	fun nanoseconds(value: Double): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = nanoseconds-UwyO8pc(I)J
	fun nanoseconds(value: Int): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = nanoseconds-UwyO8pc(J)J
	fun nanoseconds(value: Long): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = parse-UwyO8pc(Ljava/lang/String;)J
	fun parse(value: String): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = parseIsoString-UwyO8pc(Ljava/lang/String;)J
	fun parseIsoString(value: String): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = parseIsoStringOrNull-FghU774(Ljava/lang/String;)Lkotlin/time/Duration;
	fun parseIsoStringOrNull(value: String): kotlin.time.Duration?

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = parseOrNull-FghU774(Ljava/lang/String;)Lkotlin/time/Duration;
	fun parseOrNull(value: String): kotlin.time.Duration?

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = seconds-UwyO8pc(D)J
	fun seconds(value: Double): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = seconds-UwyO8pc(I)J
	fun seconds(value: Int): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = seconds-UwyO8pc(J)J
	fun seconds(value: Long): kotlin.time.Duration
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.time.MonotonicTimeSource : kotlin.time.TimeSource.WithComparableMarks {

	// *** PROPERTIES ***

	// JVM field = zero:J
	private val zero: Long


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = adjustReading-6QKq23U(JJ)J
	fun adjustReading(timeMark: kotlin.time.TimeSource.Monotonic.ValueTimeMark, duration: kotlin.time.Duration): kotlin.time.TimeSource.Monotonic.ValueTimeMark

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = differenceBetween-fRLX17w(JJ)J
	fun differenceBetween(one: kotlin.time.TimeSource.Monotonic.ValueTimeMark, another: kotlin.time.TimeSource.Monotonic.ValueTimeMark): kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = elapsedFrom-6eNON_k(J)J
	fun elapsedFrom(timeMark: kotlin.time.TimeSource.Monotonic.ValueTimeMark): kotlin.time.Duration

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = markNow-z9LOYto()J
	open fun markNow(): kotlin.time.TimeSource.Monotonic.ValueTimeMark

	// JVM method = read()J
	private fun read(): Long

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

companion object kotlin.time.TimeSource.Companion {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

object kotlin.time.TimeSource.Monotonic : kotlin.time.TimeSource.WithComparableMarks {

	// *** NESTED TYPES ***

	class ValueTimeMark


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = markNow-z9LOYto()J
	open fun markNow(): kotlin.time.TimeSource.Monotonic.ValueTimeMark

	// JVM method = toString()Ljava/lang/String;
	open fun toString(): String
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.internal.jdk7.JDK7PlatformImplementations.ReflectSdkVersion {

	// *** PROPERTIES ***

	// JVM field = sdkVersion:Ljava/lang/Integer;
	val sdkVersion: Int?


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.io.path.DefaultCopyActionContext : kotlin.io.path.CopyActionContext {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = copyToIgnoringExistingDirectory(Ljava/nio/file/Path;Ljava/nio/file/Path;Z)Lkotlin/io/path/CopyActionResult;
	open fun java.nio.file.Path.copyToIgnoringExistingDirectory(target: java.nio.file.Path, followLinks: Boolean): kotlin.io.path.CopyActionResult
}

// ------------------------------------------------------------------------------------------------------

internal object kotlin.io.path.LinkFollowing {

	// *** PROPERTIES ***

	// JVM field = followLinkOption:[Ljava/nio/file/LinkOption;
	private val followLinkOption: Array<java.nio.file.LinkOption>

	// JVM field = followVisitOption:Ljava/util/Set;
	private val followVisitOption: Set<java.nio.file.FileVisitOption>

	// JVM field = nofollowLinkOption:[Ljava/nio/file/LinkOption;
	private val nofollowLinkOption: Array<java.nio.file.LinkOption>

	// JVM field = nofollowVisitOption:Ljava/util/Set;
	private val nofollowVisitOption: Set<java.nio.file.FileVisitOption>


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = toLinkOptions(Z)[Ljava/nio/file/LinkOption;
	fun toLinkOptions(followLinks: Boolean): Array<java.nio.file.LinkOption>

	// JVM method = toVisitOptions(Z)Ljava/util/Set;
	fun toVisitOptions(followLinks: Boolean): Set<java.nio.file.FileVisitOption>
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.io.path.PathRelativizer {

	// *** PROPERTIES ***

	// JVM field = emptyPath:Ljava/nio/file/Path;
	private val emptyPath: java.nio.file.Path!

	// JVM field = parentPath:Ljava/nio/file/Path;
	private val parentPath: java.nio.file.Path!


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()


	// *** FUNCTIONS ***

	// JVM method = tryRelativeTo(Ljava/nio/file/Path;Ljava/nio/file/Path;)Ljava/nio/file/Path;
	fun tryRelativeTo(path: java.nio.file.Path, base: java.nio.file.Path): java.nio.file.Path
}

// ------------------------------------------------------------------------------------------------------

private object kotlin.internal.jdk8.JDK8PlatformImplementations.ReflectSdkVersion {

	// *** PROPERTIES ***

	// JVM field = sdkVersion:Ljava/lang/Integer;
	val sdkVersion: Int?


	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.Function<out R>

// ------------------------------------------------------------------------------------------------------

interface kotlin.Lazy<out T> {

	// *** PROPERTIES ***

	abstract val value: out T


	// *** FUNCTIONS ***

	// JVM method = isInitialized()Z
	abstract fun isInitialized(): Boolean
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.collections.Grouping<T, out K> {

	// *** FUNCTIONS ***

	// JVM method = keyOf(Ljava/lang/Object;)Ljava/lang/Object;
	abstract fun keyOf(element: T): out K

	// JVM method = sourceIterator()Ljava/util/Iterator;
	abstract fun sourceIterator(): Iterator<T>
}

// ------------------------------------------------------------------------------------------------------

private interface kotlin.collections.MapWithDefault<K, out V> : Map<K, out V> {

	// *** PROPERTIES ***

	abstract val map: Map<K, out V>


	// *** FUNCTIONS ***

	// JVM method = getOrImplicitDefault(Ljava/lang/Object;)Ljava/lang/Object;
	abstract fun getOrImplicitDefault(key: K): out V
}

// ------------------------------------------------------------------------------------------------------

private interface kotlin.collections.MutableMapWithDefault<K, V> : MutableMap<K, V>, MapWithDefault<K, V> {

	// *** PROPERTIES ***

	abstract val map: MutableMap<K, V>
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.contracts.CallsInPlace : kotlin.contracts.Effect

// ------------------------------------------------------------------------------------------------------

interface kotlin.contracts.ConditionalEffect : kotlin.contracts.Effect

// ------------------------------------------------------------------------------------------------------

interface kotlin.contracts.ContractBuilder {

	// *** FUNCTIONS ***

	// JVM method = callsInPlace(Lkotlin/Function;Lkotlin/contracts/InvocationKind;)Lkotlin/contracts/CallsInPlace;
	abstract fun <R> callsInPlace(lambda: Function<R>, kind: kotlin.contracts.InvocationKind /* = default */): kotlin.contracts.CallsInPlace

	// JVM method = returns()Lkotlin/contracts/Returns;
	abstract fun returns(): kotlin.contracts.Returns

	// JVM method = returns(Ljava/lang/Object;)Lkotlin/contracts/Returns;
	abstract fun returns(value: Any?): kotlin.contracts.Returns

	// JVM method = returnsNotNull()Lkotlin/contracts/ReturnsNotNull;
	abstract fun returnsNotNull(): kotlin.contracts.ReturnsNotNull
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.contracts.Effect

// ------------------------------------------------------------------------------------------------------

interface kotlin.contracts.Returns : kotlin.contracts.SimpleEffect

// ------------------------------------------------------------------------------------------------------

interface kotlin.contracts.ReturnsNotNull : kotlin.contracts.SimpleEffect

// ------------------------------------------------------------------------------------------------------

interface kotlin.contracts.SimpleEffect : kotlin.contracts.Effect {

	// *** FUNCTIONS ***

	// JVM method = implies(Z)Lkotlin/contracts/ConditionalEffect;
	abstract infix fun implies(booleanExpression: Boolean): kotlin.contracts.ConditionalEffect
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.coroutines.Continuation<in T> {

	// *** PROPERTIES ***

	abstract val context: kotlin.coroutines.CoroutineContext


	// *** FUNCTIONS ***

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = resumeWith(Ljava/lang/Object;)V
	abstract fun resumeWith(result: Result<in T>)
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.coroutines.ContinuationInterceptor : kotlin.coroutines.CoroutineContext.Element {

	// *** NESTED TYPES ***

	companion object Key


	// *** FUNCTIONS ***

	// JVM method = get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;
	open operator fun <E : kotlin.coroutines.CoroutineContext.Element> get(key: kotlin.coroutines.CoroutineContext.Key<E : kotlin.coroutines.CoroutineContext.Element>): E : kotlin.coroutines.CoroutineContext.Element?

	// JVM method = interceptContinuation(Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation;
	abstract fun <T> interceptContinuation(continuation: kotlin.coroutines.Continuation<T>): kotlin.coroutines.Continuation<T>

	// JVM method = minusKey(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext;
	open fun minusKey(key: kotlin.coroutines.CoroutineContext.Key<*>): kotlin.coroutines.CoroutineContext

	// JVM method = releaseInterceptedContinuation(Lkotlin/coroutines/Continuation;)V
	open fun releaseInterceptedContinuation(continuation: kotlin.coroutines.Continuation<*>)
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.coroutines.CoroutineContext.Element : kotlin.coroutines.CoroutineContext {

	// *** PROPERTIES ***

	abstract val key: kotlin.coroutines.CoroutineContext.Key<*>


	// *** FUNCTIONS ***

	// JVM method = fold(Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
	open fun <R> fold(initial: R, operation: (R, kotlin.coroutines.CoroutineContext.Element) -> R): R

	// JVM method = get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;
	open operator fun <E : kotlin.coroutines.CoroutineContext.Element> get(key: kotlin.coroutines.CoroutineContext.Key<E : kotlin.coroutines.CoroutineContext.Element>): E : kotlin.coroutines.CoroutineContext.Element?

	// JVM method = minusKey(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext;
	open fun minusKey(key: kotlin.coroutines.CoroutineContext.Key<*>): kotlin.coroutines.CoroutineContext
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.coroutines.CoroutineContext.Key<E : kotlin.coroutines.CoroutineContext.Element>

// ------------------------------------------------------------------------------------------------------

interface kotlin.coroutines.CoroutineContext {

	// *** NESTED TYPES ***

	class Element
	class Key


	// *** FUNCTIONS ***

	// JVM method = fold(Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
	abstract fun <R> fold(initial: R, operation: (R, kotlin.coroutines.CoroutineContext.Element) -> R): R

	// JVM method = get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;
	abstract operator fun <E : kotlin.coroutines.CoroutineContext.Element> get(key: kotlin.coroutines.CoroutineContext.Key<E : kotlin.coroutines.CoroutineContext.Element>): E : kotlin.coroutines.CoroutineContext.Element?

	// JVM method = minusKey(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext;
	abstract fun minusKey(key: kotlin.coroutines.CoroutineContext.Key<*>): kotlin.coroutines.CoroutineContext

	// JVM method = plus(Lkotlin/coroutines/CoroutineContext;)Lkotlin/coroutines/CoroutineContext;
	open operator fun plus(context: kotlin.coroutines.CoroutineContext): kotlin.coroutines.CoroutineContext
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.coroutines.jvm.internal.CoroutineStackFrame {

	// *** PROPERTIES ***

	abstract val callerFrame: kotlin.coroutines.jvm.internal.CoroutineStackFrame?


	// *** FUNCTIONS ***

	// JVM method = getStackTraceElement()Ljava/lang/StackTraceElement;
	abstract fun getStackTraceElement(): java.lang.StackTraceElement?
}

// ------------------------------------------------------------------------------------------------------

internal interface kotlin.coroutines.jvm.internal.SuspendFunction

// ------------------------------------------------------------------------------------------------------

interface kotlin.enums.EnumEntries<E : Enum<E>> : List<E : Enum<E>>

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function0<out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke()Ljava/lang/Object;
	abstract operator fun invoke(): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function1<in P1, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function10<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function11<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10, p11: in P11): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function12<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10, p11: in P11, p12: in P12): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function13<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10, p11: in P11, p12: in P12, p13: in P13): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function14<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10, p11: in P11, p12: in P12, p13: in P13, p14: in P14): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function15<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10, p11: in P11, p12: in P12, p13: in P13, p14: in P14, p15: in P15): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function16<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, in P16, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10, p11: in P11, p12: in P12, p13: in P13, p14: in P14, p15: in P15, p16: in P16): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function17<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, in P16, in P17, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10, p11: in P11, p12: in P12, p13: in P13, p14: in P14, p15: in P15, p16: in P16, p17: in P17): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function18<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, in P16, in P17, in P18, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10, p11: in P11, p12: in P12, p13: in P13, p14: in P14, p15: in P15, p16: in P16, p17: in P17, p18: in P18): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function19<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, in P16, in P17, in P18, in P19, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10, p11: in P11, p12: in P12, p13: in P13, p14: in P14, p15: in P15, p16: in P16, p17: in P17, p18: in P18, p19: in P19): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function2<in P1, in P2, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function20<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, in P16, in P17, in P18, in P19, in P20, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10, p11: in P11, p12: in P12, p13: in P13, p14: in P14, p15: in P15, p16: in P16, p17: in P17, p18: in P18, p19: in P19, p20: in P20): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function21<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, in P16, in P17, in P18, in P19, in P20, in P21, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10, p11: in P11, p12: in P12, p13: in P13, p14: in P14, p15: in P15, p16: in P16, p17: in P17, p18: in P18, p19: in P19, p20: in P20, p21: in P21): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function22<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, in P16, in P17, in P18, in P19, in P20, in P21, in P22, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9, p10: in P10, p11: in P11, p12: in P12, p13: in P13, p14: in P14, p15: in P15, p16: in P16, p17: in P17, p18: in P18, p19: in P19, p20: in P20, p21: in P21, p22: in P22): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function3<in P1, in P2, in P3, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function4<in P1, in P2, in P3, in P4, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function5<in P1, in P2, in P3, in P4, in P5, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function6<in P1, in P2, in P3, in P4, in P5, in P6, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function7<in P1, in P2, in P3, in P4, in P5, in P6, in P7, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function8<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.Function9<in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, out R> : Function<out R> {

	// *** FUNCTIONS ***

	// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(p1: in P1, p2: in P2, p3: in P3, p4: in P4, p5: in P5, p6: in P6, p7: in P7, p8: in P8, p9: in P9): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.functions.FunctionN<out R> : Function<out R>, kotlin.jvm.internal.FunctionBase<out R> {

	// *** PROPERTIES ***

	abstract val arity: Int


	// *** FUNCTIONS ***

	// JVM method = invoke([Ljava/lang/Object;)Ljava/lang/Object;
	abstract operator fun invoke(vararg args: Any? /* Array<out Any?> */): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.internal.ClassBasedDeclarationContainer : kotlin.reflect.KDeclarationContainer {

	// *** PROPERTIES ***

	abstract val jClass: java.lang.Class<*>
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.internal.FunctionBase<out R> : Function<out R> {

	// *** PROPERTIES ***

	abstract val arity: Int
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.internal.KTypeBase : kotlin.reflect.KType {

	// *** PROPERTIES ***

	abstract val javaType: java.lang.reflect.Type?
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.internal.markers.KMappedMarker

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.internal.markers.KMutableCollection : kotlin.jvm.internal.markers.KMutableIterable

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.internal.markers.KMutableIterable : kotlin.jvm.internal.markers.KMappedMarker

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.internal.markers.KMutableIterator : kotlin.jvm.internal.markers.KMappedMarker

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.internal.markers.KMutableList : kotlin.jvm.internal.markers.KMutableCollection

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.internal.markers.KMutableListIterator : kotlin.jvm.internal.markers.KMutableIterator

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.internal.markers.KMutableMap.Entry : kotlin.jvm.internal.markers.KMappedMarker

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.internal.markers.KMutableMap : kotlin.jvm.internal.markers.KMappedMarker {

	// *** NESTED TYPES ***

	class Entry
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.jvm.internal.markers.KMutableSet : kotlin.jvm.internal.markers.KMutableCollection

// ------------------------------------------------------------------------------------------------------

fun interface kotlin.properties.PropertyDelegateProvider<in T, out D> {

	// *** FUNCTIONS ***

	// JVM method = provideDelegate(Ljava/lang/Object;Lkotlin/reflect/KProperty;)Ljava/lang/Object;
	abstract operator fun provideDelegate(thisRef: in T, property: kotlin.reflect.KProperty<*>): out D
}

// ------------------------------------------------------------------------------------------------------

fun interface kotlin.properties.ReadOnlyProperty<in T, out V> {

	// *** FUNCTIONS ***

	// JVM method = getValue(Ljava/lang/Object;Lkotlin/reflect/KProperty;)Ljava/lang/Object;
	abstract operator fun getValue(thisRef: in T, property: kotlin.reflect.KProperty<*>): out V
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.properties.ReadWriteProperty<in T, V> : kotlin.properties.ReadOnlyProperty<in T, V> {

	// *** FUNCTIONS ***

	// JVM method = getValue(Ljava/lang/Object;Lkotlin/reflect/KProperty;)Ljava/lang/Object;
	abstract operator fun getValue(thisRef: in T, property: kotlin.reflect.KProperty<*>): V

	// JVM method = setValue(Ljava/lang/Object;Lkotlin/reflect/KProperty;Ljava/lang/Object;)V
	abstract operator fun setValue(thisRef: in T, property: kotlin.reflect.KProperty<*>, value: V)
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.ranges.ClosedFloatingPointRange<T : Comparable<T>> : ClosedRange<T : Comparable<T>> {

	// *** FUNCTIONS ***

	// JVM method = contains(Ljava/lang/Comparable;)Z
	open operator fun contains(value: T : Comparable<T>): Boolean

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean

	// JVM method = lessThanOrEquals(Ljava/lang/Comparable;Ljava/lang/Comparable;)Z
	abstract fun lessThanOrEquals(a: T : Comparable<T>, b: T : Comparable<T>): Boolean
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.ranges.ClosedRange<T : Comparable<T>> {

	// *** PROPERTIES ***

	abstract val endInclusive: T : Comparable<T>

	abstract val start: T : Comparable<T>


	// *** FUNCTIONS ***

	// JVM method = contains(Ljava/lang/Comparable;)Z
	open operator fun contains(value: T : Comparable<T>): Boolean

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.ranges.OpenEndRange<T : Comparable<T>> {

	// *** PROPERTIES ***

	abstract val endExclusive: T : Comparable<T>

	abstract val start: T : Comparable<T>


	// *** FUNCTIONS ***

	// JVM method = contains(Ljava/lang/Comparable;)Z
	open operator fun contains(value: T : Comparable<T>): Boolean

	// JVM method = isEmpty()Z
	open fun isEmpty(): Boolean
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KAnnotatedElement {

	// *** PROPERTIES ***

	abstract val annotations: List<Annotation>
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KCallable<out R> : kotlin.reflect.KAnnotatedElement {

	// *** PROPERTIES ***

	// JVM annotation-holding method = isAbstract$annotations()V
	abstract val isAbstract: Boolean

	// JVM annotation-holding method = isFinal$annotations()V
	abstract val isFinal: Boolean

	// JVM annotation-holding method = isOpen$annotations()V
	abstract val isOpen: Boolean

	// JVM annotation-holding method = isSuspend$annotations()V
	abstract val isSuspend: Boolean

	// JVM annotation-holding method = getName$annotations()V
	abstract val name: String

	abstract val parameters: List<kotlin.reflect.KParameter>

	abstract val returnType: kotlin.reflect.KType

	// JVM annotation-holding method = getTypeParameters$annotations()V
	abstract val typeParameters: List<kotlin.reflect.KTypeParameter>

	// JVM annotation-holding method = getVisibility$annotations()V
	abstract val visibility: kotlin.reflect.KVisibility?


	// *** FUNCTIONS ***

	// JVM method = call([Ljava/lang/Object;)Ljava/lang/Object;
	abstract fun call(vararg args: Any? /* Array<out Any?> */): out R

	// JVM method = callBy(Ljava/util/Map;)Ljava/lang/Object;
	abstract fun callBy(args: Map<kotlin.reflect.KParameter, Any?>): out R
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KClass<T : Any> :
	kotlin.reflect.KDeclarationContainer,
	kotlin.reflect.KAnnotatedElement,
	kotlin.reflect.KClassifier {

	// *** PROPERTIES ***

	abstract val constructors: Collection<kotlin.reflect.KFunction<T : Any>>

	// JVM annotation-holding method = isAbstract$annotations()V
	abstract val isAbstract: Boolean

	// JVM annotation-holding method = isCompanion$annotations()V
	abstract val isCompanion: Boolean

	// JVM annotation-holding method = isData$annotations()V
	abstract val isData: Boolean

	// JVM annotation-holding method = isFinal$annotations()V
	abstract val isFinal: Boolean

	// JVM annotation-holding method = isFun$annotations()V
	abstract val isFun: Boolean

	// JVM annotation-holding method = isInner$annotations()V
	abstract val isInner: Boolean

	// JVM annotation-holding method = isOpen$annotations()V
	abstract val isOpen: Boolean

	// JVM annotation-holding method = isSealed$annotations()V
	abstract val isSealed: Boolean

	// JVM annotation-holding method = isValue$annotations()V
	abstract val isValue: Boolean

	abstract val members: Collection<kotlin.reflect.KCallable<*>>

	abstract val nestedClasses: Collection<kotlin.reflect.KClass<*>>

	abstract val objectInstance: T : Any?

	abstract val qualifiedName: String?

	// JVM annotation-holding method = getSealedSubclasses$annotations()V
	abstract val sealedSubclasses: List<kotlin.reflect.KClass<out T : Any>>

	abstract val simpleName: String?

	// JVM annotation-holding method = getSupertypes$annotations()V
	abstract val supertypes: List<kotlin.reflect.KType>

	// JVM annotation-holding method = getTypeParameters$annotations()V
	abstract val typeParameters: List<kotlin.reflect.KTypeParameter>

	// JVM annotation-holding method = getVisibility$annotations()V
	abstract val visibility: kotlin.reflect.KVisibility?


	// *** FUNCTIONS ***

	// JVM method = equals(Ljava/lang/Object;)Z
	abstract operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	abstract fun hashCode(): Int

	// JVM method = isInstance(Ljava/lang/Object;)Z
	abstract fun isInstance(value: Any?): Boolean
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KClassifier

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KDeclarationContainer {

	// *** PROPERTIES ***

	abstract val members: Collection<kotlin.reflect.KCallable<*>>
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KFunction<out R> : kotlin.reflect.KCallable<out R>, Function<out R> {

	// *** PROPERTIES ***

	// JVM annotation-holding method = isExternal$annotations()V
	abstract val isExternal: Boolean

	// JVM annotation-holding method = isInfix$annotations()V
	abstract val isInfix: Boolean

	// JVM annotation-holding method = isInline$annotations()V
	abstract val isInline: Boolean

	// JVM annotation-holding method = isOperator$annotations()V
	abstract val isOperator: Boolean

	// JVM annotation-holding method = isSuspend$annotations()V
	abstract val isSuspend: Boolean
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KMutableProperty.Setter<V> : kotlin.reflect.KProperty.Accessor<V>, kotlin.reflect.KFunction<Unit>

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KMutableProperty<V> : kotlin.reflect.KProperty<V> {

	// *** NESTED TYPES ***

	class Setter


	// *** PROPERTIES ***

	abstract val setter: kotlin.reflect.KMutableProperty.Setter<V>
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KMutableProperty0.Setter<V> : kotlin.reflect.KMutableProperty.Setter<V>, (V) -> Unit

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KMutableProperty0<V> : kotlin.reflect.KProperty0<V>, kotlin.reflect.KMutableProperty<V> {

	// *** NESTED TYPES ***

	class Setter


	// *** PROPERTIES ***

	abstract val setter: kotlin.reflect.KMutableProperty0.Setter<V>


	// *** FUNCTIONS ***

	// JVM method = set(Ljava/lang/Object;)V
	abstract fun set(value: V)
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KMutableProperty1.Setter<T, V> : kotlin.reflect.KMutableProperty.Setter<V>, (T, V) -> Unit

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KMutableProperty1<T, V> : kotlin.reflect.KProperty1<T, V>, kotlin.reflect.KMutableProperty<V> {

	// *** NESTED TYPES ***

	class Setter


	// *** PROPERTIES ***

	abstract val setter: kotlin.reflect.KMutableProperty1.Setter<T, V>


	// *** FUNCTIONS ***

	// JVM method = set(Ljava/lang/Object;Ljava/lang/Object;)V
	abstract fun set(receiver: T, value: V)
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KMutableProperty2.Setter<D, E, V> : kotlin.reflect.KMutableProperty.Setter<V>, (D, E, V) -> Unit

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KMutableProperty2<D, E, V> : kotlin.reflect.KProperty2<D, E, V>, kotlin.reflect.KMutableProperty<V> {

	// *** NESTED TYPES ***

	class Setter


	// *** PROPERTIES ***

	abstract val setter: kotlin.reflect.KMutableProperty2.Setter<D, E, V>


	// *** FUNCTIONS ***

	// JVM method = set(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)V
	abstract fun set(receiver1: D, receiver2: E, value: V)
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KParameter : kotlin.reflect.KAnnotatedElement {

	// *** NESTED TYPES ***

	class Kind


	// *** PROPERTIES ***

	abstract val index: Int

	abstract val isOptional: Boolean

	// JVM annotation-holding method = isVararg$annotations()V
	abstract val isVararg: Boolean

	abstract val kind: kotlin.reflect.KParameter.Kind

	abstract val name: String?

	abstract val type: kotlin.reflect.KType
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KProperty.Accessor<out V> {

	// *** PROPERTIES ***

	abstract val property: kotlin.reflect.KProperty<out V>
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KProperty.Getter<out V> : kotlin.reflect.KProperty.Accessor<out V>, kotlin.reflect.KFunction<out V>

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KProperty<out V> : kotlin.reflect.KCallable<out V> {

	// *** NESTED TYPES ***

	class Accessor
	class Getter


	// *** PROPERTIES ***

	abstract val getter: kotlin.reflect.KProperty.Getter<out V>

	// JVM annotation-holding method = isConst$annotations()V
	abstract val isConst: Boolean

	// JVM annotation-holding method = isLateinit$annotations()V
	abstract val isLateinit: Boolean
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KProperty0.Getter<out V> : kotlin.reflect.KProperty.Getter<out V>, () -> out V

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KProperty0<out V> : kotlin.reflect.KProperty<out V>, () -> out V {

	// *** NESTED TYPES ***

	class Getter


	// *** PROPERTIES ***

	abstract val getter: kotlin.reflect.KProperty0.Getter<out V>


	// *** FUNCTIONS ***

	// JVM method = get()Ljava/lang/Object;
	abstract fun get(): out V

	// JVM method = getDelegate()Ljava/lang/Object;
	abstract fun getDelegate(): Any?
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KProperty1.Getter<T, out V> : kotlin.reflect.KProperty.Getter<out V>, (T) -> out V

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KProperty1<T, out V> : kotlin.reflect.KProperty<out V>, (T) -> out V {

	// *** NESTED TYPES ***

	class Getter


	// *** PROPERTIES ***

	abstract val getter: kotlin.reflect.KProperty1.Getter<T, out V>


	// *** FUNCTIONS ***

	// JVM method = get(Ljava/lang/Object;)Ljava/lang/Object;
	abstract fun get(receiver: T): out V

	// JVM method = getDelegate(Ljava/lang/Object;)Ljava/lang/Object;
	abstract fun getDelegate(receiver: T): Any?
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KProperty2.Getter<D, E, out V> : kotlin.reflect.KProperty.Getter<out V>, (D, E) -> out V

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KProperty2<D, E, out V> : kotlin.reflect.KProperty<out V>, (D, E) -> out V {

	// *** NESTED TYPES ***

	class Getter


	// *** PROPERTIES ***

	abstract val getter: kotlin.reflect.KProperty2.Getter<D, E, out V>


	// *** FUNCTIONS ***

	// JVM method = get(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract fun get(receiver1: D, receiver2: E): out V

	// JVM method = getDelegate(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
	abstract fun getDelegate(receiver1: D, receiver2: E): Any?
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KType : kotlin.reflect.KAnnotatedElement {

	// *** PROPERTIES ***

	// JVM annotation-holding method = getArguments$annotations()V
	abstract val arguments: List<kotlin.reflect.KTypeProjection>

	// JVM annotation-holding method = getClassifier$annotations()V
	abstract val classifier: kotlin.reflect.KClassifier?

	abstract val isMarkedNullable: Boolean
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.reflect.KTypeParameter : kotlin.reflect.KClassifier {

	// *** PROPERTIES ***

	abstract val isReified: Boolean

	abstract val name: String

	abstract val upperBounds: List<kotlin.reflect.KType>

	abstract val variance: kotlin.reflect.KVariance
}

// ------------------------------------------------------------------------------------------------------

private interface kotlin.reflect.TypeImpl : java.lang.reflect.Type {

	// *** FUNCTIONS ***

	// JVM method = getTypeName()Ljava/lang/String;
	abstract fun getTypeName(): String
}

// ------------------------------------------------------------------------------------------------------

internal interface kotlin.sequences.DropTakeSequence<T> : Sequence<T> {

	// *** FUNCTIONS ***

	// JVM method = drop(I)Lkotlin/sequences/Sequence;
	abstract fun drop(n: Int): Sequence<T>

	// JVM method = take(I)Lkotlin/sequences/Sequence;
	abstract fun take(n: Int): Sequence<T>
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.sequences.Sequence<out T> {

	// *** FUNCTIONS ***

	// JVM method = iterator()Ljava/util/Iterator;
	abstract operator fun iterator(): Iterator<out T>
}

// ------------------------------------------------------------------------------------------------------

private interface kotlin.text.FlagEnum {

	// *** PROPERTIES ***

	abstract val mask: Int

	abstract val value: Int
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.text.MatchGroupCollection : Collection<MatchGroup?> {

	// *** FUNCTIONS ***

	// JVM method = get(I)Lkotlin/text/MatchGroup;
	abstract operator fun get(index: Int): MatchGroup?
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.text.MatchNamedGroupCollection : MatchGroupCollection {

	// *** FUNCTIONS ***

	// JVM method = get(Ljava/lang/String;)Lkotlin/text/MatchGroup;
	abstract operator fun get(name: String): MatchGroup?
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.text.MatchResult {

	// *** NESTED TYPES ***

	class Destructured


	// *** PROPERTIES ***

	open val destructured: MatchResult.Destructured
		// JVM method = getDestructured()Lkotlin/text/MatchResult$Destructured;
		get() = /* non-default */

	abstract val groupValues: List<String>

	abstract val groups: MatchGroupCollection

	abstract val range: IntRange

	abstract val value: String


	// *** FUNCTIONS ***

	// JVM method = next()Lkotlin/text/MatchResult;
	abstract fun next(): MatchResult?
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.time.ComparableTimeMark : kotlin.time.TimeMark, Comparable<kotlin.time.ComparableTimeMark> {

	// *** FUNCTIONS ***

	// JVM method = compareTo(Lkotlin/time/ComparableTimeMark;)I
	open operator fun compareTo(other: kotlin.time.ComparableTimeMark): Int

	// JVM method = equals(Ljava/lang/Object;)Z
	abstract operator fun equals(other: Any?): Boolean

	// JVM method = hashCode()I
	abstract fun hashCode(): Int

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-UwyO8pc(Lkotlin/time/ComparableTimeMark;)J
	abstract operator fun minus(other: kotlin.time.ComparableTimeMark): kotlin.time.Duration

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-LRDsOJo(J)Lkotlin/time/ComparableTimeMark;
	open operator fun minus(duration: kotlin.time.Duration): kotlin.time.ComparableTimeMark

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-LRDsOJo(J)Lkotlin/time/ComparableTimeMark;
	abstract operator fun plus(duration: kotlin.time.Duration): kotlin.time.ComparableTimeMark
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.time.TimeMark {

	// *** FUNCTIONS ***

	// requires language version >= 1.4, otherwise diagnostic error
	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = elapsedNow-UwyO8pc()J
	abstract fun elapsedNow(): kotlin.time.Duration

	// JVM method = hasNotPassedNow()Z
	open fun hasNotPassedNow(): Boolean

	// JVM method = hasPassedNow()Z
	open fun hasPassedNow(): Boolean

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = minus-LRDsOJo(J)Lkotlin/time/TimeMark;
	open operator fun minus(duration: kotlin.time.Duration): kotlin.time.TimeMark

	// requires language version >= 1.3, otherwise diagnostic error
	// JVM method = plus-LRDsOJo(J)Lkotlin/time/TimeMark;
	open operator fun plus(duration: kotlin.time.Duration): kotlin.time.TimeMark
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.time.TimeSource.WithComparableMarks : kotlin.time.TimeSource {

	// *** FUNCTIONS ***

	// JVM method = markNow()Lkotlin/time/ComparableTimeMark;
	abstract fun markNow(): kotlin.time.ComparableTimeMark
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.time.TimeSource {

	// *** NESTED TYPES ***

	companion object
	class Monotonic
	class WithComparableMarks


	// *** FUNCTIONS ***

	// JVM method = markNow()Lkotlin/time/TimeMark;
	abstract fun markNow(): kotlin.time.TimeMark
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.io.path.CopyActionContext {

	// *** FUNCTIONS ***

	// JVM method = copyToIgnoringExistingDirectory(Ljava/nio/file/Path;Ljava/nio/file/Path;Z)Lkotlin/io/path/CopyActionResult;
	abstract fun java.nio.file.Path.copyToIgnoringExistingDirectory(target: java.nio.file.Path, followLinks: Boolean): kotlin.io.path.CopyActionResult
}

// ------------------------------------------------------------------------------------------------------

interface kotlin.io.path.FileVisitorBuilder {

	// *** FUNCTIONS ***

	// JVM method = onPostVisitDirectory(Lkotlin/jvm/functions/Function2;)V
	abstract fun onPostVisitDirectory(function: (@ParameterName(name = "directory") java.nio.file.Path, @ParameterName(name = "exception") java.io.IOException?) -> java.nio.file.FileVisitResult)

	// JVM method = onPreVisitDirectory(Lkotlin/jvm/functions/Function2;)V
	abstract fun onPreVisitDirectory(function: (@ParameterName(name = "directory") java.nio.file.Path, @ParameterName(name = "attributes") java.nio.file.attribute.BasicFileAttributes) -> java.nio.file.FileVisitResult)

	// JVM method = onVisitFile(Lkotlin/jvm/functions/Function2;)V
	abstract fun onVisitFile(function: (@ParameterName(name = "file") java.nio.file.Path, @ParameterName(name = "attributes") java.nio.file.attribute.BasicFileAttributes) -> java.nio.file.FileVisitResult)

	// JVM method = onVisitFileFailed(Lkotlin/jvm/functions/Function2;)V
	abstract fun onVisitFileFailed(function: (@ParameterName(name = "file") java.nio.file.Path, @ParameterName(name = "exception") java.io.IOException) -> java.nio.file.FileVisitResult)
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.DeprecationLevel {

	// *** ENUM ENTRIES ***
	WARNING,
	ERROR,
	HIDDEN;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.LazyThreadSafetyMode {

	// *** ENUM ENTRIES ***
	SYNCHRONIZED,
	PUBLICATION,
	NONE;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.RequiresOptIn.Level {

	// *** ENUM ENTRIES ***
	WARNING,
	ERROR;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.annotation.AnnotationRetention {

	// *** ENUM ENTRIES ***
	SOURCE,
	BINARY,
	RUNTIME;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.annotation.AnnotationTarget {

	// *** ENUM ENTRIES ***
	CLASS,
	ANNOTATION_CLASS,
	TYPE_PARAMETER,
	PROPERTY,
	FIELD,
	LOCAL_VARIABLE,
	VALUE_PARAMETER,
	CONSTRUCTOR,
	FUNCTION,
	PROPERTY_GETTER,
	PROPERTY_SETTER,
	TYPE,
	EXPRESSION,
	FILE,
	TYPEALIAS;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

private enum class kotlin.collections.State {

	// *** ENUM ENTRIES ***
	Ready,
	NotReady,
	Done,
	Failed;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.contracts.InvocationKind {

	// *** ENUM ENTRIES ***
	AT_MOST_ONCE,
	AT_LEAST_ONCE,
	EXACTLY_ONCE,
	UNKNOWN;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal enum class kotlin.coroutines.intrinsics.CoroutineSingletons {

	// *** ENUM ENTRIES ***
	COROUTINE_SUSPENDED,
	UNDECIDED,
	RESUMED;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

internal enum class kotlin.internal.RequireKotlinVersionKind {

	// *** ENUM ENTRIES ***
	LANGUAGE_VERSION,
	COMPILER_VERSION,
	API_VERSION;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.io.FileWalkDirection {

	// *** ENUM ENTRIES ***
	TOP_DOWN,
	BOTTOM_UP;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.io.OnErrorAction {

	// *** ENUM ENTRIES ***
	SKIP,
	TERMINATE;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.reflect.KParameter.Kind {

	// *** ENUM ENTRIES ***
	INSTANCE,
	EXTENSION_RECEIVER,
	VALUE;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.reflect.KVariance {

	// *** ENUM ENTRIES ***
	INVARIANT,
	IN,
	OUT;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.reflect.KVisibility {

	// *** ENUM ENTRIES ***
	PUBLIC,
	PROTECTED,
	INTERNAL,
	PRIVATE;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.text.CharCategory {

	// *** ENUM ENTRIES ***
	UNASSIGNED,
	UPPERCASE_LETTER,
	LOWERCASE_LETTER,
	TITLECASE_LETTER,
	MODIFIER_LETTER,
	OTHER_LETTER,
	NON_SPACING_MARK,
	ENCLOSING_MARK,
	COMBINING_SPACING_MARK,
	DECIMAL_DIGIT_NUMBER,
	LETTER_NUMBER,
	OTHER_NUMBER,
	SPACE_SEPARATOR,
	LINE_SEPARATOR,
	PARAGRAPH_SEPARATOR,
	CONTROL,
	FORMAT,
	PRIVATE_USE,
	SURROGATE,
	DASH_PUNCTUATION,
	START_PUNCTUATION,
	END_PUNCTUATION,
	CONNECTOR_PUNCTUATION,
	OTHER_PUNCTUATION,
	MATH_SYMBOL,
	CURRENCY_SYMBOL,
	MODIFIER_SYMBOL,
	OTHER_SYMBOL,
	INITIAL_QUOTE_PUNCTUATION,
	FINAL_QUOTE_PUNCTUATION;


	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = code:Ljava/lang/String;
	val code: String

	// JVM field = value:I
	val value: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;IILjava/lang/String;)V
	private constructor(value: Int, code: String)


	// *** FUNCTIONS ***

	// JVM method = contains(C)Z
	operator fun contains(char: Char): Boolean
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.text.CharDirectionality {

	// *** ENUM ENTRIES ***
	UNDEFINED,
	LEFT_TO_RIGHT,
	RIGHT_TO_LEFT,
	RIGHT_TO_LEFT_ARABIC,
	EUROPEAN_NUMBER,
	EUROPEAN_NUMBER_SEPARATOR,
	EUROPEAN_NUMBER_TERMINATOR,
	ARABIC_NUMBER,
	COMMON_NUMBER_SEPARATOR,
	NONSPACING_MARK,
	BOUNDARY_NEUTRAL,
	PARAGRAPH_SEPARATOR,
	SEGMENT_SEPARATOR,
	WHITESPACE,
	OTHER_NEUTRALS,
	LEFT_TO_RIGHT_EMBEDDING,
	LEFT_TO_RIGHT_OVERRIDE,
	RIGHT_TO_LEFT_EMBEDDING,
	RIGHT_TO_LEFT_OVERRIDE,
	POP_DIRECTIONAL_FORMAT;


	// *** NESTED TYPES ***

	companion object


	// *** PROPERTIES ***

	// JVM field = value:I
	val value: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;II)V
	private constructor(value: Int)
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.text.RegexOption : FlagEnum {

	// *** ENUM ENTRIES ***
	IGNORE_CASE,
	MULTILINE,
	LITERAL,
	UNIX_LINES,
	COMMENTS,
	DOT_MATCHES_ALL,
	CANON_EQ;


	// *** PROPERTIES ***

	// JVM field = mask:I
	open val mask: Int

	// JVM field = value:I
	open val value: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;III)V
	private constructor(value: Int, mask: Int /* = default */)
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.time.DurationUnit {

	// *** ENUM ENTRIES ***
	NANOSECONDS,
	MICROSECONDS,
	MILLISECONDS,
	SECONDS,
	MINUTES,
	HOURS,
	DAYS;


	// *** PROPERTIES ***

	// JVM field = timeUnit:Ljava/util/concurrent/TimeUnit;
	internal val timeUnit: java.util.concurrent.TimeUnit


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;ILjava/util/concurrent/TimeUnit;)V
	private constructor(timeUnit: java.util.concurrent.TimeUnit)
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.io.path.CopyActionResult {

	// *** ENUM ENTRIES ***
	CONTINUE,
	SKIP_SUBTREE,
	TERMINATE;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.io.path.OnErrorResult {

	// *** ENUM ENTRIES ***
	SKIP_SUBTREE,
	TERMINATE;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

enum class kotlin.io.path.PathWalkOption {

	// *** ENUM ENTRIES ***
	INCLUDE_DIRECTORIES,
	BREADTH_FIRST,
	FOLLOW_LINKS;


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;I)V
	private constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.BuilderInference {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.ContextFunctionTypeParams {

	// *** PROPERTIES ***

	val count: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I)V
	constructor(count: Int)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.Deprecated {

	// *** PROPERTIES ***

	val level: DeprecationLevel

	val message: String

	val replaceWith: ReplaceWith


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;Lkotlin/ReplaceWith;Lkotlin/DeprecationLevel;)V
	constructor(message: String, replaceWith: ReplaceWith /* = default */, level: DeprecationLevel /* = default */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.DeprecatedSinceKotlin {

	// *** PROPERTIES ***

	val errorSince: String

	val hiddenSince: String

	val warningSince: String


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V
	constructor(warningSince: String /* = default */, errorSince: String /* = default */, hiddenSince: String /* = default */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.DslMarker {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.ExperimentalMultiplatform {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.ExperimentalStdlibApi {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.ExperimentalSubclassOptIn {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.ExperimentalUnsignedTypes {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.ExtensionFunctionType {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.Metadata {

	// *** PROPERTIES ***

	// JVM annotation-holding method = bv$annotations()V
	val bytecodeVersion: IntArray

	val data1: Array<String>

	val data2: Array<String>

	// JVM annotation-holding method = xi$annotations()V
	val extraInt: Int

	val extraString: String

	val kind: Int

	val metadataVersion: IntArray

	// JVM annotation-holding method = pn$annotations()V
	val packageName: String


	// *** CONSTRUCTORS ***

	// JVM method = <init>(I[I[ILkotlin/Array;Lkotlin/Array;Ljava/lang/String;Ljava/lang/String;I)V
	constructor(kind: Int /* = default */, metadataVersion: IntArray /* = default */, bytecodeVersion: IntArray /* = default */, data1: Array<String> /* = default */, data2: Array<String> /* = default */, extraString: String /* = default */, packageName: String /* = default */, extraInt: Int /* = default */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.OptIn {

	// *** PROPERTIES ***

	val markerClass: Array<out kotlin.reflect.KClass<out Annotation>>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/Array;)V
	constructor(vararg markerClass: kotlin.reflect.KClass<out Annotation> /* Array<out kotlin.reflect.KClass<out Annotation>> */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.OptionalExpectation {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.OverloadResolutionByLambdaReturnType {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.ParameterName {

	// *** PROPERTIES ***

	val name: String


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;)V
	constructor(name: String)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.PublishedApi {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.ReplaceWith {

	// *** PROPERTIES ***

	val expression: String

	val imports: Array<out String>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;Lkotlin/Array;)V
	constructor(expression: String, vararg imports: String /* Array<out String> */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.RequiresOptIn {

	// *** NESTED TYPES ***

	class Level


	// *** PROPERTIES ***

	val level: RequiresOptIn.Level

	val message: String


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;Lkotlin/RequiresOptIn$Level;)V
	constructor(message: String /* = default */, level: RequiresOptIn.Level /* = default */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.SinceKotlin {

	// *** PROPERTIES ***

	val version: String


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;)V
	constructor(version: String)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.SubclassOptInRequired {

	// *** PROPERTIES ***

	val markerClass: kotlin.reflect.KClass<out Annotation>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/reflect/KClass;)V
	constructor(markerClass: kotlin.reflect.KClass<out Annotation>)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.Suppress {

	// *** PROPERTIES ***

	val names: Array<out String>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/Array;)V
	constructor(vararg names: String /* Array<out String> */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.UnsafeVariance {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.WasExperimental {

	// *** PROPERTIES ***

	val markerClass: Array<out kotlin.reflect.KClass<out Annotation>>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/Array;)V
	constructor(vararg markerClass: kotlin.reflect.KClass<out Annotation> /* Array<out kotlin.reflect.KClass<out Annotation>> */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.annotation.MustBeDocumented {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.annotation.Repeatable {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.annotation.Retention {

	// *** PROPERTIES ***

	val value: kotlin.annotation.AnnotationRetention


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/annotation/AnnotationRetention;)V
	constructor(value: kotlin.annotation.AnnotationRetention /* = default */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.annotation.Target {

	// *** PROPERTIES ***

	val allowedTargets: Array<out kotlin.annotation.AnnotationTarget>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/Array;)V
	constructor(vararg allowedTargets: kotlin.annotation.AnnotationTarget /* Array<out kotlin.annotation.AnnotationTarget> */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.contracts.ExperimentalContracts {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.coroutines.RestrictsSuspension {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.coroutines.jvm.internal.DebugMetadata {

	// *** PROPERTIES ***

	val className: String

	val indexToLabel: IntArray

	val lineNumbers: IntArray

	val localNames: Array<String>

	val methodName: String

	val sourceFile: String

	val spilled: Array<String>

	val version: Int


	// *** CONSTRUCTORS ***

	// JVM method = <init>(ILjava/lang/String;[ILkotlin/Array;Lkotlin/Array;[ILjava/lang/String;Ljava/lang/String;)V
	constructor(version: Int /* = default */, sourceFile: String /* = default */, lineNumbers: IntArray /* = default */, localNames: Array<String> /* = default */, spilled: Array<String> /* = default */, indexToLabel: IntArray /* = default */, methodName: String /* = default */, className: String /* = default */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.experimental.ExperimentalObjCName {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.experimental.ExperimentalObjCRefinement {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.experimental.ExperimentalTypeInference {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.AccessibleLateinitPropertyLiteral {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.ContractsDsl {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.DynamicExtension {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.Exact {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.HidesMembers {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.InlineOnly {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.IntrinsicConstEvaluation {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.LowPriorityInOverloadResolution {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.NoInfer {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.OnlyInputTypes {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.PlatformDependent {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.PureReifiable {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.internal.RequireKotlin {

	// *** PROPERTIES ***

	val errorCode: Int

	val level: DeprecationLevel

	val message: String

	val version: String

	val versionKind: kotlin.internal.RequireKotlinVersionKind


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;Ljava/lang/String;Lkotlin/DeprecationLevel;Lkotlin/internal/RequireKotlinVersionKind;I)V
	constructor(version: String, message: String /* = default */, level: DeprecationLevel /* = default */, versionKind: kotlin.internal.RequireKotlinVersionKind /* = default */, errorCode: Int /* = default */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.io.encoding.ExperimentalEncodingApi {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.js.ExperimentalJsExport {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmDefault {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

// requires compiler version >= 1.6, otherwise diagnostic error
annotation class kotlin.jvm.JvmDefaultWithCompatibility {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmDefaultWithoutCompatibility {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmField {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmInline {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmMultifileClass {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmName {

	// *** PROPERTIES ***

	val name: String


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;)V
	constructor(name: String)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmOverloads {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

internal annotation class kotlin.jvm.JvmPackageName {

	// *** PROPERTIES ***

	val name: String


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;)V
	constructor(name: String)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmRecord {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmSerializableLambda {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmStatic {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmSuppressWildcards {

	// *** PROPERTIES ***

	val suppress: Boolean


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Z)V
	constructor(suppress: Boolean /* = default */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmSynthetic {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.JvmWildcard {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.PurelyImplements {

	// *** PROPERTIES ***

	val value: String


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Ljava/lang/String;)V
	constructor(value: String)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.Strictfp {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.Synchronized {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.Throws {

	// *** PROPERTIES ***

	val exceptionClasses: Array<out kotlin.reflect.KClass<out Throwable>>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/Array;)V
	constructor(vararg exceptionClasses: kotlin.reflect.KClass<out Throwable> /* Array<out kotlin.reflect.KClass<out Throwable>> */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.Transient {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.Volatile {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.internal.SerializedIr {

	// *** PROPERTIES ***

	val bytes: Array<String>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/Array;)V
	constructor(bytes: Array<String> /* = default */)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.jvm.internal.SourceDebugExtension {

	// *** PROPERTIES ***

	val value: Array<String>


	// *** CONSTRUCTORS ***

	// JVM method = <init>(Lkotlin/Array;)V
	constructor(value: Array<String>)
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.time.ExperimentalTime {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

annotation class kotlin.io.path.ExperimentalPathApi {

	// *** CONSTRUCTORS ***

	// JVM method = <init>()V
	constructor()
}

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/CharSequence;
/* local */ fun <out E> (it: out E): CharSequence

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/util/Map$Entry;)Ljava/lang/CharSequence;
/* local */ fun <K, out V> (it: Map.Entry<K, out V>): CharSequence

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun <T> (): Iterator<T>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<Byte>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<Short>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<Int>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<Long>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<Float>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<Double>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<Boolean>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<Char>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Integer;
/* local */ fun <T, K : Comparable<K>> (it: T): Int

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(I)Ljava/lang/Object;
/* local */ fun <T> (it: Int): T

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun <T> (): Iterator<T>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = <anonymous>(Lkotlin/sequences/SequenceScope;)V
/* local */ suspend fun <T> SequenceScope<List<T>>.()

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<UInt>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<ULong>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<UByte>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<UShort>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = compare(Ljava/lang/Object;Ljava/lang/Object;)I
/* local */ fun <T> (a: T!, b: T!): Int

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = compare(Ljava/lang/Object;Ljava/lang/Object;)I
/* local */ fun <T, K> (a: T!, b: T!): Int

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = compare(Ljava/lang/Object;Ljava/lang/Object;)I
/* local */ fun <T> (a: T!, b: T!): Int

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = compare(Ljava/lang/Object;Ljava/lang/Object;)I
/* local */ fun <T, K> (a: T!, b: T!): Int

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = compare(Ljava/lang/Object;Ljava/lang/Object;)I
/* local */ fun <T> (a: T!, b: T!): Int

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = compare(Ljava/lang/Object;Ljava/lang/Object;)I
/* local */ fun <T, K> (a: T!, b: T!): Int

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = compare(Ljava/lang/Object;Ljava/lang/Object;)I
/* local */ fun <T> (a: T!, b: T!): Int

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = compare(Ljava/lang/Object;Ljava/lang/Object;)I
/* local */ fun <T, K> (a: T!, b: T!): Int

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = compare(Ljava/lang/Object;Ljava/lang/Object;)I
/* local */ fun <T> (a: T!, b: T!): Int

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/String;Lkotlin/coroutines/CoroutineContext$Element;)Ljava/lang/String;
/* local */ fun (acc: String, element: kotlin.coroutines.CoroutineContext.Element): String

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Lkotlin/Unit;Lkotlin/coroutines/CoroutineContext$Element;)V
/* local */ fun (_: Unit, element: kotlin.coroutines.CoroutineContext.Element)

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Lkotlin/coroutines/CoroutineContext;Lkotlin/coroutines/CoroutineContext$Element;)Lkotlin/coroutines/CoroutineContext;
/* local */ fun (acc: kotlin.coroutines.CoroutineContext, element: kotlin.coroutines.CoroutineContext.Element): kotlin.coroutines.CoroutineContext

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()[Ljava/lang/Enum;
/* local */ fun <E : Enum<E>> (): Array<E : Enum<E>>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/String;)V
/* local */ fun (it: String)

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/io/File;Ljava/io/IOException;)Ljava/lang/Void;
/* local */ fun (_: java.io.File, exception: java.io.IOException): Nothing

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/io/File;Ljava/io/IOException;)V
/* local */ fun (f: java.io.File, e: java.io.IOException)

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/String;)V
/* local */ fun (it: String)

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Lkotlin/reflect/KTypeProjection;)Ljava/lang/CharSequence;
/* local */ fun (it: kotlin.reflect.KTypeProjection): CharSequence

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = <anonymous>(Lkotlin/sequences/SequenceScope;)V
/* local */ suspend fun <T, C, R> SequenceScope<R>.()

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Lkotlin/sequences/Sequence;)Ljava/util/Iterator;
/* local */ fun <T> (it: Sequence<T>): Iterator<T>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Iterable;)Ljava/util/Iterator;
/* local */ fun <T> (it: Iterable<T>): Iterator<T>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Object;
/* local */ fun <T, R> (it: T): T

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Object;
/* local */ fun <T : Any> (it: T : Any): T : Any?

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/lang/Object;
/* local */ fun <T : Any> (): T : Any?

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = <anonymous>(Lkotlin/sequences/SequenceScope;)V
/* local */ suspend fun <T> SequenceScope<T>.()

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = <anonymous>(Lkotlin/sequences/SequenceScope;)V
/* local */ suspend fun <T> SequenceScope<T>.()

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Boolean;
/* local */ fun <R> (it: Any?): Boolean

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Object;
/* local */ fun <T> (it: T): T

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(I)Ljava/lang/Object;
/* local */ fun <T> (it: Int): T

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Lkotlin/collections/IndexedValue;)Ljava/lang/Boolean;
/* local */ fun <T> (it: IndexedValue<T>): Boolean

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Lkotlin/collections/IndexedValue;)Ljava/lang/Object;
/* local */ fun <T> (it: IndexedValue<T>): T

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Boolean;
/* local */ fun <reified R> (it: Any?): Boolean

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Boolean;
/* local */ fun <T : Any> (it: T : Any?): Boolean

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Boolean;
/* local */ fun <T> (it: T): Boolean

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Boolean;
/* local */ fun <T> (it: T): Boolean

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Boolean;
/* local */ fun <T> (it: T): Boolean

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Boolean;
/* local */ fun <T> (it: T): Boolean

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Object;
/* local */ fun <T> (it: T): T

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(ILjava/lang/Object;)Ljava/lang/Object;
/* local */ fun <T> (index: Int, element: T): T

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;)Ljava/lang/Object;
/* local */ fun <T : Any> (it: T : Any?): T : Any

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = <anonymous>(Lkotlin/sequences/SequenceScope;)V
/* local */ suspend fun <T, R> SequenceScope<R>.()

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = <anonymous>(Lkotlin/sequences/SequenceScope;)V
/* local */ suspend fun <T, R> SequenceScope<R>.()

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = <anonymous>(Lkotlin/sequences/SequenceScope;)V
/* local */ suspend fun <S, T : S> SequenceScope<S>.()

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = <anonymous>(Lkotlin/sequences/SequenceScope;)V
/* local */ suspend fun <S, T : S> SequenceScope<S>.()

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;)Lkotlin/Pair;
/* local */ fun <T, R> (t1: T, t2: R): Pair<T, R>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Object;Ljava/lang/Object;)Lkotlin/Pair;
/* local */ fun <T> (a: T, b: T): Pair<T, T>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = <anonymous>(Lkotlin/sequences/SequenceScope;)V
/* local */ suspend fun <T, R> SequenceScope<R>.()

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Map;
/* local */ fun (): Map<Int, CharDirectionality>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(I)Lkotlin/text/MatchGroup;
/* local */ fun (it: Int): MatchGroup?

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Lkotlin/text/MatchResult;
/* local */ fun (): MatchResult?

// ------------------------------------------------------------------------------------------------------

/* lambda */

// lambda class origin: RegexKt$fromInt$1$1
// JVM method = invoke(Ljava/lang/Enum;)Ljava/lang/Boolean;
/* local */ fun <reified T> (it: reified T!): Boolean where
	T : FlagEnum,
	T : Enum<reified T>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = <anonymous>(Lkotlin/sequences/SequenceScope;)V
/* local */ suspend fun SequenceScope<String>.()

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/Enum;)Ljava/lang/Boolean;
/* local */ fun <reified T> (it: reified T!): Boolean where
	T : FlagEnum,
	T : Enum<reified T>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/String;)Ljava/lang/String;
/* local */ fun (line: String): String

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/String;)Ljava/lang/String;
/* local */ fun (line: String): String

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/String;)Ljava/lang/String;
/* local */ fun (it: String): String

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/CharSequence;I)Lkotlin/Pair;
/* local */ fun CharSequence.(currentIndex: Int): Pair<Int, Int>?

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/CharSequence;I)Lkotlin/Pair;
/* local */ fun CharSequence.(currentIndex: Int): Pair<Int, Int>?

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Lkotlin/ranges/IntRange;)Ljava/lang/String;
/* local */ fun (it: IntRange): String

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Lkotlin/ranges/IntRange;)Ljava/lang/String;
/* local */ fun (it: IntRange): String

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/CharSequence;)Ljava/lang/String;
/* local */ fun (it: CharSequence): String

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/CharSequence;)Ljava/lang/String;
/* local */ fun (it: CharSequence): String

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/lang/CharSequence;)Ljava/lang/String;
/* local */ fun (it: CharSequence): String

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(I)Ljava/lang/Object;
/* local */ fun <R> (index: Int): R

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke()Ljava/util/Iterator;
/* local */ fun (): Iterator<Char>

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = <anonymous>(Lkotlin/sequences/SequenceScope;)V
/* local */ suspend fun SequenceScope<java.nio.file.Path>.()

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = <anonymous>(Lkotlin/sequences/SequenceScope;)V
/* local */ suspend fun SequenceScope<java.nio.file.Path>.()

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/nio/file/Path;Ljava/nio/file/Path;Ljava/lang/Exception;)Ljava/lang/Void;
/* local */ fun (_: java.nio.file.Path, _: java.nio.file.Path, exception: Exception /* = java.lang.Exception */): Nothing

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Lkotlin/io/path/CopyActionContext;Ljava/nio/file/Path;Ljava/nio/file/Path;)Lkotlin/io/path/CopyActionResult;
/* local */ fun kotlin.io.path.CopyActionContext.(src: java.nio.file.Path, dst: java.nio.file.Path): kotlin.io.path.CopyActionResult

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/nio/file/Path;Ljava/nio/file/Path;Ljava/lang/Exception;)Ljava/lang/Void;
/* local */ fun (_: java.nio.file.Path, _: java.nio.file.Path, exception: Exception /* = java.lang.Exception */): Nothing

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Lkotlin/io/path/CopyActionContext;Ljava/nio/file/Path;Ljava/nio/file/Path;)Lkotlin/io/path/CopyActionResult;
/* local */ fun kotlin.io.path.CopyActionContext.(src: java.nio.file.Path, dst: java.nio.file.Path): kotlin.io.path.CopyActionResult

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Ljava/nio/file/Path;Ljava/io/IOException;)Ljava/nio/file/FileVisitResult;
/* local */ fun (directory: java.nio.file.Path, exception: java.io.IOException?): java.nio.file.FileVisitResult

// ------------------------------------------------------------------------------------------------------

/* lambda */

// JVM method = invoke(Lkotlin/io/path/FileVisitorBuilder;)V
/* local */ fun kotlin.io.path.FileVisitorBuilder.()

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.ArrayIntrinsicsKt


// *** FUNCTIONS ***

// JVM method = emptyArray()[Ljava/lang/Object;
inline fun <@kotlin.internal.PureReifiable reified T> emptyArray(): Array<@kotlin.internal.PureReifiable reified T>

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.CharCodeJVMKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = Char-xj2QHRw(S)C
inline fun Char(code: UShort): Char

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.CharCodeKt


// *** PROPERTIES ***

// JVM annotation-holding method = getCode$annotations(C)V
inline val Char.code: Int
	// JVM method = getCode(C)I
	get() = /* non-default */


// *** FUNCTIONS ***

// JVM method = Char(I)C
inline fun Char(code: Int): Char

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.CompareToKt


// *** FUNCTIONS ***

// JVM method = compareTo(Ljava/lang/Comparable;Ljava/lang/Object;)I
inline infix fun <T> Comparable<T>.compareTo(other: T): Int

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.DeepRecursiveKt


// *** TYPE ALIASES ***

private typealias DeepRecursiveFunctionBlock = suspend DeepRecursiveScope<*, *>.(Any?) -> Any?


// *** PROPERTIES ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM field = UNDEFINED_RESULT:Ljava/lang/Object;
// JVM annotation-holding method = getUNDEFINED_RESULT$annotations()V
private val UNDEFINED_RESULT: Result<Any>


// *** FUNCTIONS ***

// JVM method = invoke(Lkotlin/DeepRecursiveFunction;Ljava/lang/Object;)Ljava/lang/Object;
operator fun <T, R> DeepRecursiveFunction<T, R>.invoke(value: T): R

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.HashCodeKt


// *** FUNCTIONS ***

// JVM method = hashCode(Ljava/lang/Object;)I
inline fun Any?.hashCode(): Int

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.LateinitKt


// *** PROPERTIES ***

// JVM annotation-holding method = isInitialized$annotations(Lkotlin/reflect/KProperty0;)V
inline val kotlin.reflect.KProperty0<*>.isInitialized: Boolean
	// JVM method = isInitialized(Lkotlin/reflect/KProperty0;)Z
	get() = /* non-default */

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.PropertyReferenceDelegatesKt


// *** FUNCTIONS ***

// JVM method = getValue(Lkotlin/reflect/KProperty0;Ljava/lang/Object;Lkotlin/reflect/KProperty;)Ljava/lang/Object;
inline operator fun <V> kotlin.reflect.KProperty0<V>.getValue(thisRef: Any?, property: kotlin.reflect.KProperty<*>): V

// JVM method = getValue(Lkotlin/reflect/KProperty1;Ljava/lang/Object;Lkotlin/reflect/KProperty;)Ljava/lang/Object;
inline operator fun <T, V> kotlin.reflect.KProperty1<T, V>.getValue(thisRef: T, property: kotlin.reflect.KProperty<*>): V

// JVM method = setValue(Lkotlin/reflect/KMutableProperty0;Ljava/lang/Object;Lkotlin/reflect/KProperty;Ljava/lang/Object;)V
inline operator fun <V> kotlin.reflect.KMutableProperty0<V>.setValue(thisRef: Any?, property: kotlin.reflect.KProperty<*>, value: V)

// JVM method = setValue(Lkotlin/reflect/KMutableProperty1;Ljava/lang/Object;Lkotlin/reflect/KProperty;Ljava/lang/Object;)V
inline operator fun <T, V> kotlin.reflect.KMutableProperty1<T, V>.setValue(thisRef: T, property: kotlin.reflect.KProperty<*>, value: V)

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.ResultKt


// *** FUNCTIONS ***

// JVM method = createFailure(Ljava/lang/Throwable;)Ljava/lang/Object;
internal fun createFailure(exception: Throwable): Any

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runCatching(Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <R> runCatching(block: () -> R): Result<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = fold(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R, T> Result<T>.fold(onSuccess: (@ParameterName(name = "value") T) -> R, onFailure: (@ParameterName(name = "exception") Throwable) -> R): R {
	contract {
		callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)
		callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)
	}
}

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getOrDefault(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
inline fun <R, T : R> Result<T : R>.getOrDefault(defaultValue: R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getOrElse(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R, T : R> Result<T : R>.getOrElse(onFailure: (@ParameterName(name = "exception") Throwable) -> R): R {
	contract {
		callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)
	}
}

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getOrThrow(Ljava/lang/Object;)Ljava/lang/Object;
inline fun <T> Result<T>.getOrThrow(): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = map(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R, T> Result<T>.map(transform: (@ParameterName(name = "value") T) -> R): Result<R> {
	contract {
		callsInPlace(transform, InvocationKind.AT_MOST_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapCatching(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R, T> Result<T>.mapCatching(transform: (@ParameterName(name = "value") T) -> R): Result<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = onFailure(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Result<T>.onFailure(action: (@ParameterName(name = "exception") Throwable) -> Unit): Result<T> {
	contract {
		callsInPlace(action, InvocationKind.AT_MOST_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = onSuccess(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Result<T>.onSuccess(action: (@ParameterName(name = "value") T) -> Unit): Result<T> {
	contract {
		callsInPlace(action, InvocationKind.AT_MOST_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = recover(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R, T : R> Result<T : R>.recover(transform: (@ParameterName(name = "exception") Throwable) -> R): Result<R> {
	contract {
		callsInPlace(transform, InvocationKind.AT_MOST_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = recoverCatching(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R, T : R> Result<T : R>.recoverCatching(transform: (@ParameterName(name = "exception") Throwable) -> R): Result<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runCatching(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> T.runCatching(block: T.() -> R): Result<R>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = throwOnFailure(Ljava/lang/Object;)V
internal fun Result<*>.throwOnFailure()

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.SuspendKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = suspend(Lkotlin/jvm/functions/Function1;)Lkotlin/jvm/functions/Function1;
inline fun <R> suspend(noinline block: suspend () -> R): suspend () -> R

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.ThrowsKt


// *** TYPE ALIASES ***

@SinceKotlin(version = "1.4")
typealias Throws = Throws

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.TuplesKt


// *** FUNCTIONS ***

// JVM method = to(Ljava/lang/Object;Ljava/lang/Object;)Lkotlin/Pair;
infix fun <A, B> A.to(that: B): Pair<A, B>

// JVM method = toList(Lkotlin/Pair;)Ljava/util/List;
fun <T> Pair<T, T>.toList(): List<T>

// JVM method = toList(Lkotlin/Triple;)Ljava/util/List;
fun <T> Triple<T, T, T>.toList(): List<T>

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.TypeAliasesKt


// *** TYPE ALIASES ***

@SinceKotlin(version = "1.3")
typealias ArithmeticException = java.lang.ArithmeticException

@SinceKotlin(version = "1.1")
typealias AssertionError = java.lang.AssertionError

@SinceKotlin(version = "1.1")
typealias ClassCastException = java.lang.ClassCastException

@SinceKotlin(version = "1.1")
typealias Comparator<T> = java.util.Comparator<T>

@SinceKotlin(version = "1.3")
typealias ConcurrentModificationException = java.util.ConcurrentModificationException

@SinceKotlin(version = "1.1")
typealias Error = java.lang.Error

@SinceKotlin(version = "1.1")
typealias Exception = java.lang.Exception

@SinceKotlin(version = "1.1")
typealias IllegalArgumentException = java.lang.IllegalArgumentException

@SinceKotlin(version = "1.1")
typealias IllegalStateException = java.lang.IllegalStateException

@SinceKotlin(version = "1.1")
typealias IndexOutOfBoundsException = java.lang.IndexOutOfBoundsException

@SinceKotlin(version = "1.1")
typealias NoSuchElementException = java.util.NoSuchElementException

@SinceKotlin(version = "1.1")
typealias NullPointerException = java.lang.NullPointerException

@SinceKotlin(version = "1.1")
typealias NumberFormatException = java.lang.NumberFormatException

@SinceKotlin(version = "1.1")
typealias RuntimeException = java.lang.RuntimeException

@SinceKotlin(version = "1.1")
typealias UnsupportedOperationException = java.lang.UnsupportedOperationException

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.UByteArrayKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = UByteArray(ILkotlin/jvm/functions/Function1;)[B
inline fun UByteArray(size: Int, init: (Int) -> UByte): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = ubyteArrayOf-GBYM_sE([B)[B
inline fun ubyteArrayOf(vararg elements: UByte /* UByteArray */): UByteArray

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.UByteKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUByte(B)B
inline fun Byte.toUByte(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUByte(I)B
inline fun Int.toUByte(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUByte(J)B
inline fun Long.toUByte(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUByte(S)B
inline fun Short.toUByte(): UByte

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.UIntArrayKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = UIntArray(ILkotlin/jvm/functions/Function1;)[I
inline fun UIntArray(size: Int, init: (Int) -> UInt): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = uintArrayOf--ajY-9A([I)[I
inline fun uintArrayOf(vararg elements: UInt /* UIntArray */): UIntArray

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.UIntKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUInt(B)I
inline fun Byte.toUInt(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUInt(D)I
inline fun Double.toUInt(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUInt(F)I
inline fun Float.toUInt(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUInt(I)I
inline fun Int.toUInt(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUInt(J)I
inline fun Long.toUInt(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUInt(S)I
inline fun Short.toUInt(): UInt

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.ULongArrayKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = ULongArray(ILkotlin/jvm/functions/Function1;)[J
inline fun ULongArray(size: Int, init: (Int) -> ULong): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = ulongArrayOf-QwZRm1k([J)[J
inline fun ulongArrayOf(vararg elements: ULong /* ULongArray */): ULongArray

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.ULongKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULong(B)J
inline fun Byte.toULong(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULong(D)J
inline fun Double.toULong(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULong(F)J
inline fun Float.toULong(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULong(I)J
inline fun Int.toULong(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULong(J)J
inline fun Long.toULong(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULong(S)J
inline fun Short.toULong(): ULong

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.UNumbersKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = countLeadingZeroBits-7apg3OU(B)I
inline fun UByte.countLeadingZeroBits(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = countLeadingZeroBits-WZ4Q5Ns(I)I
inline fun UInt.countLeadingZeroBits(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = countLeadingZeroBits-VKZWuLQ(J)I
inline fun ULong.countLeadingZeroBits(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = countLeadingZeroBits-xj2QHRw(S)I
inline fun UShort.countLeadingZeroBits(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = countOneBits-7apg3OU(B)I
inline fun UByte.countOneBits(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = countOneBits-WZ4Q5Ns(I)I
inline fun UInt.countOneBits(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = countOneBits-VKZWuLQ(J)I
inline fun ULong.countOneBits(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = countOneBits-xj2QHRw(S)I
inline fun UShort.countOneBits(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = countTrailingZeroBits-7apg3OU(B)I
inline fun UByte.countTrailingZeroBits(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = countTrailingZeroBits-WZ4Q5Ns(I)I
inline fun UInt.countTrailingZeroBits(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = countTrailingZeroBits-VKZWuLQ(J)I
inline fun ULong.countTrailingZeroBits(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = countTrailingZeroBits-xj2QHRw(S)I
inline fun UShort.countTrailingZeroBits(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = rotateLeft-LxnNnR4(BI)B
inline fun UByte.rotateLeft(bitCount: Int): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = rotateLeft-V7xB4Y4(II)I
inline fun UInt.rotateLeft(bitCount: Int): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = rotateLeft-JSWoG40(JI)J
inline fun ULong.rotateLeft(bitCount: Int): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = rotateLeft-olVBNx4(SI)S
inline fun UShort.rotateLeft(bitCount: Int): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = rotateRight-LxnNnR4(BI)B
inline fun UByte.rotateRight(bitCount: Int): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = rotateRight-V7xB4Y4(II)I
inline fun UInt.rotateRight(bitCount: Int): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = rotateRight-JSWoG40(JI)J
inline fun ULong.rotateRight(bitCount: Int): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = rotateRight-olVBNx4(SI)S
inline fun UShort.rotateRight(bitCount: Int): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeHighestOneBit-7apg3OU(B)B
inline fun UByte.takeHighestOneBit(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeHighestOneBit-WZ4Q5Ns(I)I
inline fun UInt.takeHighestOneBit(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeHighestOneBit-VKZWuLQ(J)J
inline fun ULong.takeHighestOneBit(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeHighestOneBit-xj2QHRw(S)S
inline fun UShort.takeHighestOneBit(): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeLowestOneBit-7apg3OU(B)B
inline fun UByte.takeLowestOneBit(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeLowestOneBit-WZ4Q5Ns(I)I
inline fun UInt.takeLowestOneBit(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeLowestOneBit-VKZWuLQ(J)J
inline fun ULong.takeLowestOneBit(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeLowestOneBit-xj2QHRw(S)S
inline fun UShort.takeLowestOneBit(): UShort

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.UShortArrayKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = UShortArray(ILkotlin/jvm/functions/Function1;)[S
inline fun UShortArray(size: Int, init: (Int) -> UShort): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = ushortArrayOf-rL5Bavg([S)[S
inline fun ushortArrayOf(vararg elements: UShort /* UShortArray */): UShortArray

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.UShortKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUShort(B)S
inline fun Byte.toUShort(): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUShort(I)S
inline fun Int.toUShort(): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUShort(J)S
inline fun Long.toUShort(): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUShort(S)S
inline fun Short.toUShort(): UShort

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.UnsignedKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = doubleToUInt(D)I
internal fun doubleToUInt(v: Double): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = doubleToULong(D)J
internal fun doubleToULong(v: Double): ULong

// JVM method = uintCompare(II)I
internal fun uintCompare(v1: Int, v2: Int): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = uintDivide-J1ME1BU(II)I
internal fun uintDivide(v1: UInt, v2: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = uintRemainder-J1ME1BU(II)I
internal fun uintRemainder(v1: UInt, v2: UInt): UInt

// JVM method = uintToDouble(I)D
internal fun uintToDouble(v: Int): Double

// JVM method = ulongCompare(JJ)I
internal fun ulongCompare(v1: Long, v2: Long): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = ulongDivide-eb3DHEI(JJ)J
internal fun ulongDivide(v1: ULong, v2: ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = ulongRemainder-eb3DHEI(JJ)J
internal fun ulongRemainder(v1: ULong, v2: ULong): ULong

// JVM method = ulongToDouble(J)D
internal fun ulongToDouble(v: Long): Double

// JVM method = ulongToString(J)Ljava/lang/String;
internal fun ulongToString(v: Long): String

// JVM method = ulongToString(JI)Ljava/lang/String;
internal fun ulongToString(v: Long, base: Int): String

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.collections.MapAccessorsKt


// *** FUNCTIONS ***

// JVM method = getValue(Ljava/util/Map;Ljava/lang/Object;Lkotlin/reflect/KProperty;)Ljava/lang/Object;
inline operator fun <V, V1 : V> Map<in String, @kotlin.internal.Exact V>.getValue(thisRef: Any?, property: kotlin.reflect.KProperty<*>): V1 : V

// JVM method = getVar(Ljava/util/Map;Ljava/lang/Object;Lkotlin/reflect/KProperty;)Ljava/lang/Object;
inline operator fun <V, V1 : V> MutableMap<in String, out @kotlin.internal.Exact V>.getValue(thisRef: Any?, property: kotlin.reflect.KProperty<*>): V1 : V

// JVM method = setValue(Ljava/util/Map;Ljava/lang/Object;Lkotlin/reflect/KProperty;Ljava/lang/Object;)V
inline operator fun <V> MutableMap<in String, in V>.setValue(thisRef: Any?, property: kotlin.reflect.KProperty<*>, value: V)

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.collections.SlidingWindowKt


// *** FUNCTIONS ***

// JVM method = checkWindowSizeStep(II)V
internal fun checkWindowSizeStep(size: Int, step: Int)

// JVM method = windowedIterator(Ljava/util/Iterator;IIZZ)Ljava/util/Iterator;
internal fun <T> windowedIterator(iterator: Iterator<T>, size: Int, step: Int, partialWindows: Boolean, reuseBuffer: Boolean): Iterator<List<T>>

// JVM method = windowedSequence(Lkotlin/sequences/Sequence;IIZZ)Lkotlin/sequences/Sequence;
internal fun <T> Sequence<T>.windowedSequence(size: Int, step: Int, partialWindows: Boolean, reuseBuffer: Boolean): Sequence<List<T>>

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.collections.TypeAliasesKt


// *** TYPE ALIASES ***

@SinceKotlin(version = "1.1")
typealias ArrayList<E> = java.util.ArrayList<E>

@SinceKotlin(version = "1.1")
typealias HashMap<K, V> = java.util.HashMap<K, V>

@SinceKotlin(version = "1.1")
typealias HashSet<E> = java.util.HashSet<E>

@SinceKotlin(version = "1.1")
typealias LinkedHashMap<K, V> = java.util.LinkedHashMap<K, V>

@SinceKotlin(version = "1.1")
typealias LinkedHashSet<E> = java.util.LinkedHashSet<E>

@SinceKotlin(version = "1.1")
typealias RandomAccess = java.util.RandomAccess

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.collections.UArraySortingKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = partition-4UcCI2c([BII)I
private fun partition(array: UByteArray, left: Int, right: Int): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = partition-oBK06Vg([III)I
private fun partition(array: UIntArray, left: Int, right: Int): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = partition--nroSd4([JII)I
private fun partition(array: ULongArray, left: Int, right: Int): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = partition-Aa5vz7o([SII)I
private fun partition(array: UShortArray, left: Int, right: Int): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = quickSort-4UcCI2c([BII)V
private fun quickSort(array: UByteArray, left: Int, right: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = quickSort-oBK06Vg([III)V
private fun quickSort(array: UIntArray, left: Int, right: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = quickSort--nroSd4([JII)V
private fun quickSort(array: ULongArray, left: Int, right: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = quickSort-Aa5vz7o([SII)V
private fun quickSort(array: UShortArray, left: Int, right: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortArray-4UcCI2c([BII)V
internal fun sortArray(array: UByteArray, fromIndex: Int, toIndex: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortArray-oBK06Vg([III)V
internal fun sortArray(array: UIntArray, fromIndex: Int, toIndex: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortArray--nroSd4([JII)V
internal fun sortArray(array: ULongArray, fromIndex: Int, toIndex: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortArray-Aa5vz7o([SII)V
internal fun sortArray(array: UShortArray, fromIndex: Int, toIndex: Int)

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.collections.builders.ListBuilderKt


// *** FUNCTIONS ***

// JVM method = arrayOfUninitializedElements(I)[Ljava/lang/Object;
internal fun <E> arrayOfUninitializedElements(size: Int): Array<E>

// JVM method = copyOfUninitializedElements([Ljava/lang/Object;I)[Ljava/lang/Object;
internal fun <T> Array<T>.copyOfUninitializedElements(newSize: Int): Array<T>

// JVM method = resetAt([Ljava/lang/Object;I)V
internal fun <E> Array<E>.resetAt(index: Int)

// JVM method = resetRange([Ljava/lang/Object;II)V
internal fun <E> Array<E>.resetRange(fromIndex: Int, toIndex: Int)

// JVM method = subarrayContentEquals([Ljava/lang/Object;IILjava/util/List;)Z
private fun <T> Array<T>.subarrayContentEquals(offset: Int, length: Int, other: List<*>): Boolean

// JVM method = subarrayContentHashCode([Ljava/lang/Object;II)I
private fun <T> Array<T>.subarrayContentHashCode(offset: Int, length: Int): Int

// JVM method = subarrayContentToString([Ljava/lang/Object;II)Ljava/lang/String;
private fun <T> Array<out T>.subarrayContentToString(offset: Int, length: Int): String

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.concurrent.LocksKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = read(Ljava/util/concurrent/locks/ReentrantReadWriteLock;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <T> java.util.concurrent.locks.ReentrantReadWriteLock.read(action: () -> T): T {
	contract {
		callsInPlace(action, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = withLock(Ljava/util/concurrent/locks/Lock;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <T> java.util.concurrent.locks.Lock.withLock(action: () -> T): T {
	contract {
		callsInPlace(action, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = write(Ljava/util/concurrent/locks/ReentrantReadWriteLock;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <T> java.util.concurrent.locks.ReentrantReadWriteLock.write(action: () -> T): T {
	contract {
		callsInPlace(action, InvocationKind.EXACTLY_ONCE)
	}
}

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.concurrent.ThreadsKt


// *** FUNCTIONS ***

// JVM method = thread(ZZLjava/lang/ClassLoader;Ljava/lang/String;ILkotlin/jvm/functions/Function0;)Ljava/lang/Thread;
fun thread(start: Boolean /* = default */, isDaemon: Boolean /* = default */, contextClassLoader: java.lang.ClassLoader? /* = default */, name: String? /* = default */, priority: Int /* = default */, block: () -> Unit): java.lang.Thread

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrSet(Ljava/lang/ThreadLocal;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <T : Any> java.lang.ThreadLocal<T : Any>.getOrSet(default: () -> T : Any): T : Any

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.concurrent.TimersKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fixedRateTimer(Ljava/lang/String;ZLjava/util/Date;JLkotlin/jvm/functions/Function1;)Ljava/util/Timer;
inline fun fixedRateTimer(name: String? /* = default */, daemon: Boolean /* = default */, startAt: java.util.Date, period: Long, crossinline action: java.util.TimerTask.() -> Unit): java.util.Timer

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fixedRateTimer(Ljava/lang/String;ZJJLkotlin/jvm/functions/Function1;)Ljava/util/Timer;
inline fun fixedRateTimer(name: String? /* = default */, daemon: Boolean /* = default */, initialDelay: Long /* = default */, period: Long, crossinline action: java.util.TimerTask.() -> Unit): java.util.Timer

// JVM method = timer(Ljava/lang/String;Z)Ljava/util/Timer;
internal fun timer(name: String?, daemon: Boolean): java.util.Timer

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = timer(Ljava/lang/String;ZLjava/util/Date;JLkotlin/jvm/functions/Function1;)Ljava/util/Timer;
inline fun timer(name: String? /* = default */, daemon: Boolean /* = default */, startAt: java.util.Date, period: Long, crossinline action: java.util.TimerTask.() -> Unit): java.util.Timer

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = timer(Ljava/lang/String;ZJJLkotlin/jvm/functions/Function1;)Ljava/util/Timer;
inline fun timer(name: String? /* = default */, daemon: Boolean /* = default */, initialDelay: Long /* = default */, period: Long, crossinline action: java.util.TimerTask.() -> Unit): java.util.Timer

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = timerTask(Lkotlin/jvm/functions/Function1;)Ljava/util/TimerTask;
inline fun timerTask(crossinline action: java.util.TimerTask.() -> Unit): java.util.TimerTask

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = schedule(Ljava/util/Timer;Ljava/util/Date;Lkotlin/jvm/functions/Function1;)Ljava/util/TimerTask;
inline fun java.util.Timer.schedule(time: java.util.Date, crossinline action: java.util.TimerTask.() -> Unit): java.util.TimerTask

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = schedule(Ljava/util/Timer;Ljava/util/Date;JLkotlin/jvm/functions/Function1;)Ljava/util/TimerTask;
inline fun java.util.Timer.schedule(time: java.util.Date, period: Long, crossinline action: java.util.TimerTask.() -> Unit): java.util.TimerTask

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = schedule(Ljava/util/Timer;JLkotlin/jvm/functions/Function1;)Ljava/util/TimerTask;
inline fun java.util.Timer.schedule(delay: Long, crossinline action: java.util.TimerTask.() -> Unit): java.util.TimerTask

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = schedule(Ljava/util/Timer;JJLkotlin/jvm/functions/Function1;)Ljava/util/TimerTask;
inline fun java.util.Timer.schedule(delay: Long, period: Long, crossinline action: java.util.TimerTask.() -> Unit): java.util.TimerTask

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scheduleAtFixedRate(Ljava/util/Timer;Ljava/util/Date;JLkotlin/jvm/functions/Function1;)Ljava/util/TimerTask;
inline fun java.util.Timer.scheduleAtFixedRate(time: java.util.Date, period: Long, crossinline action: java.util.TimerTask.() -> Unit): java.util.TimerTask

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scheduleAtFixedRate(Ljava/util/Timer;JJLkotlin/jvm/functions/Function1;)Ljava/util/TimerTask;
inline fun java.util.Timer.scheduleAtFixedRate(delay: Long, period: Long, crossinline action: java.util.TimerTask.() -> Unit): java.util.TimerTask

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.concurrent.VolatileKt


// *** TYPE ALIASES ***

@SinceKotlin(version = "1.9")
@ExperimentalStdlibApi
typealias Volatile = Volatile

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.contracts.ContractBuilderKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = contract(Lkotlin/jvm/functions/Function1;)V
inline fun contract(builder: kotlin.contracts.ContractBuilder.() -> Unit)

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.coroutines.ContinuationKt


// *** PROPERTIES ***

// JVM annotation-holding method = getCoroutineContext$annotations()V
inline val coroutineContext: kotlin.coroutines.CoroutineContext
	// JVM method = getCoroutineContext()Lkotlin/coroutines/CoroutineContext;
	get() = /* non-default */


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = Continuation(Lkotlin/coroutines/CoroutineContext;Lkotlin/jvm/functions/Function1;)Lkotlin/coroutines/Continuation;
inline fun <T> Continuation(context: kotlin.coroutines.CoroutineContext, crossinline resumeWith: (Result<T>) -> Unit): kotlin.coroutines.Continuation<T>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = suspendCoroutine(Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
suspend inline fun <T> suspendCoroutine(crossinline block: (kotlin.coroutines.Continuation<T>) -> Unit): T {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = createCoroutine(Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation;
fun <T> suspend () -> T.createCoroutine(completion: kotlin.coroutines.Continuation<T>): kotlin.coroutines.Continuation<Unit>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = createCoroutine(Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation;
fun <R, T> suspend R.() -> T.createCoroutine(receiver: R, completion: kotlin.coroutines.Continuation<T>): kotlin.coroutines.Continuation<Unit>

// JVM method = resume(Lkotlin/coroutines/Continuation;Ljava/lang/Object;)V
inline fun <T> kotlin.coroutines.Continuation<T>.resume(value: T)

// JVM method = resumeWithException(Lkotlin/coroutines/Continuation;Ljava/lang/Throwable;)V
inline fun <T> kotlin.coroutines.Continuation<T>.resumeWithException(exception: Throwable)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = startCoroutine(Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)V
fun <T> suspend () -> T.startCoroutine(completion: kotlin.coroutines.Continuation<T>)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = startCoroutine(Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)V
fun <R, T> suspend R.() -> T.startCoroutine(receiver: R, completion: kotlin.coroutines.Continuation<T>)

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.coroutines.CoroutineContextImplKt


// *** FUNCTIONS ***

// JVM method = getPolymorphicElement(Lkotlin/coroutines/CoroutineContext$Element;Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;
fun <E : kotlin.coroutines.CoroutineContext.Element> kotlin.coroutines.CoroutineContext.Element.getPolymorphicElement(key: kotlin.coroutines.CoroutineContext.Key<E : kotlin.coroutines.CoroutineContext.Element>): E : kotlin.coroutines.CoroutineContext.Element?

// JVM method = minusPolymorphicKey(Lkotlin/coroutines/CoroutineContext$Element;Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext;
fun kotlin.coroutines.CoroutineContext.Element.minusPolymorphicKey(key: kotlin.coroutines.CoroutineContext.Key<*>): kotlin.coroutines.CoroutineContext

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.coroutines.cancellation.CancellationExceptionKt


// *** TYPE ALIASES ***

@SinceKotlin(version = "1.4")
typealias CancellationException = java.util.concurrent.CancellationException


// *** FUNCTIONS ***

// JVM method = CancellationException(Ljava/lang/String;Ljava/lang/Throwable;)Ljava/util/concurrent/CancellationException;
inline fun CancellationException(message: String?, cause: Throwable?): kotlin.coroutines.cancellation.CancellationException /* = java.util.concurrent.CancellationException */

// JVM method = CancellationException(Ljava/lang/Throwable;)Ljava/util/concurrent/CancellationException;
inline fun CancellationException(cause: Throwable?): kotlin.coroutines.cancellation.CancellationException /* = java.util.concurrent.CancellationException */

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.coroutines.jvm.internal.Boxing


// *** FUNCTIONS ***

// JVM method = boxBoolean(Z)Ljava/lang/Boolean;
internal fun boxBoolean(primitive: Boolean): java.lang.Boolean

// JVM method = boxByte(B)Ljava/lang/Byte;
internal fun boxByte(primitive: Byte): java.lang.Byte

// JVM method = boxChar(C)Ljava/lang/Character;
internal fun boxChar(primitive: Char): java.lang.Character

// JVM method = boxDouble(D)Ljava/lang/Double;
internal fun boxDouble(primitive: Double): java.lang.Double

// JVM method = boxFloat(F)Ljava/lang/Float;
internal fun boxFloat(primitive: Float): java.lang.Float

// JVM method = boxInt(I)Ljava/lang/Integer;
internal fun boxInt(primitive: Int): java.lang.Integer

// JVM method = boxLong(J)Ljava/lang/Long;
internal fun boxLong(primitive: Long): java.lang.Long

// JVM method = boxShort(S)Ljava/lang/Short;
internal fun boxShort(primitive: Short): java.lang.Short

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.coroutines.jvm.internal.DebugMetadataKt


// *** PROPERTIES ***

// JVM field = COROUTINES_DEBUG_METADATA_VERSION:I
private const val COROUTINES_DEBUG_METADATA_VERSION: Int


// *** FUNCTIONS ***

// JVM method = checkDebugMetadataVersion(II)V
private fun checkDebugMetadataVersion(expected: Int, actual: Int)

// JVM method = getDebugMetadataAnnotation(Lkotlin/coroutines/jvm/internal/BaseContinuationImpl;)Lkotlin/coroutines/jvm/internal/DebugMetadata;
private fun kotlin.coroutines.jvm.internal.BaseContinuationImpl.getDebugMetadataAnnotation(): kotlin.coroutines.jvm.internal.DebugMetadata?

// JVM method = getLabel(Lkotlin/coroutines/jvm/internal/BaseContinuationImpl;)I
private fun kotlin.coroutines.jvm.internal.BaseContinuationImpl.getLabel(): Int

// JVM method = getSpilledVariableFieldMapping(Lkotlin/coroutines/jvm/internal/BaseContinuationImpl;)[Ljava/lang/String;
internal fun kotlin.coroutines.jvm.internal.BaseContinuationImpl.getSpilledVariableFieldMapping(): Array<String>?

// JVM method = getStackTraceElement(Lkotlin/coroutines/jvm/internal/BaseContinuationImpl;)Ljava/lang/StackTraceElement;
internal fun kotlin.coroutines.jvm.internal.BaseContinuationImpl.getStackTraceElementImpl(): java.lang.StackTraceElement?

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.coroutines.jvm.internal.DebugProbesKt


// *** FUNCTIONS ***

// JVM method = probeCoroutineCreated(Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation;
internal fun <T> probeCoroutineCreated(completion: kotlin.coroutines.Continuation<T>): kotlin.coroutines.Continuation<T>

// JVM method = probeCoroutineResumed(Lkotlin/coroutines/Continuation;)V
internal fun probeCoroutineResumed(frame: kotlin.coroutines.Continuation<*>)

// JVM method = probeCoroutineSuspended(Lkotlin/coroutines/Continuation;)V
internal fun probeCoroutineSuspended(frame: kotlin.coroutines.Continuation<*>)

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.coroutines.jvm.internal.RunSuspendKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runSuspend(Lkotlin/jvm/functions/Function1;)V
internal fun runSuspend(block: suspend () -> Unit)

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.enums.EnumEntriesKt


// *** FUNCTIONS ***

// JVM method = enumEntries(Lkotlin/jvm/functions/Function0;)Lkotlin/enums/EnumEntries;
internal fun <E : Enum<E>> enumEntries(entriesProvider: () -> Array<E : Enum<E>>): kotlin.enums.EnumEntries<E : Enum<E>>

// JVM method = enumEntries([Ljava/lang/Enum;)Lkotlin/enums/EnumEntries;
internal fun <E : Enum<E>> enumEntries(entries: Array<E : Enum<E>>): kotlin.enums.EnumEntries<E : Enum<E>>

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.experimental.BitwiseOperationsKt


// *** FUNCTIONS ***

// JVM method = and(BB)B
inline infix fun Byte.and(other: Byte): Byte

// JVM method = and(SS)S
inline infix fun Short.and(other: Short): Short

// JVM method = inv(B)B
inline fun Byte.inv(): Byte

// JVM method = inv(S)S
inline fun Short.inv(): Short

// JVM method = or(BB)B
inline infix fun Byte.or(other: Byte): Byte

// JVM method = or(SS)S
inline infix fun Short.or(other: Short): Short

// JVM method = xor(BB)B
inline infix fun Byte.xor(other: Byte): Byte

// JVM method = xor(SS)S
inline infix fun Short.xor(other: Short): Short

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.internal.PlatformImplementationsKt


// *** PROPERTIES ***

// JVM field = IMPLEMENTATIONS:Lkotlin/internal/PlatformImplementations;
internal val IMPLEMENTATIONS: kotlin.internal.PlatformImplementations


// *** FUNCTIONS ***

// JVM method = apiVersionIsAtLeast(III)Z
internal fun apiVersionIsAtLeast(major: Int, minor: Int, patch: Int): Boolean

// JVM method = castToBaseType(Ljava/lang/Object;)Ljava/lang/Object;
private inline fun <reified T : Any> castToBaseType(instance: Any): reified T : Any

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.internal.ProgressionUtilKt


// *** FUNCTIONS ***

// JVM method = differenceModulo(III)I
private fun differenceModulo(a: Int, b: Int, c: Int): Int

// JVM method = differenceModulo(JJJ)J
private fun differenceModulo(a: Long, b: Long, c: Long): Long

// JVM method = getProgressionLastElement(III)I
internal fun getProgressionLastElement(start: Int, end: Int, step: Int): Int

// JVM method = getProgressionLastElement(JJJ)J
internal fun getProgressionLastElement(start: Long, end: Long, step: Long): Long

// JVM method = mod(II)I
private fun mod(a: Int, b: Int): Int

// JVM method = mod(JJ)J
private fun mod(a: Long, b: Long): Long

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.internal.UProgressionUtilKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = differenceModulo-WZ9TVnA(III)I
private fun differenceModulo(a: UInt, b: UInt, c: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = differenceModulo-sambcqE(JJJ)J
private fun differenceModulo(a: ULong, b: ULong, c: ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getProgressionLastElement-Nkh28Cs(III)I
internal fun getProgressionLastElement(start: UInt, end: UInt, step: Int): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getProgressionLastElement-7ftBX0g(JJJ)J
internal fun getProgressionLastElement(start: ULong, end: ULong, step: Long): ULong

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.io.ByteStreamsKt


// *** FUNCTIONS ***

// JVM method = buffered(Ljava/io/InputStream;I)Ljava/io/BufferedInputStream;
inline fun java.io.InputStream.buffered(bufferSize: Int /* = default */): java.io.BufferedInputStream

// JVM method = buffered(Ljava/io/OutputStream;I)Ljava/io/BufferedOutputStream;
inline fun java.io.OutputStream.buffered(bufferSize: Int /* = default */): java.io.BufferedOutputStream

// JVM method = bufferedReader(Ljava/io/InputStream;Ljava/nio/charset/Charset;)Ljava/io/BufferedReader;
inline fun java.io.InputStream.bufferedReader(charset: java.nio.charset.Charset /* = default */): java.io.BufferedReader

// JVM method = bufferedWriter(Ljava/io/OutputStream;Ljava/nio/charset/Charset;)Ljava/io/BufferedWriter;
inline fun java.io.OutputStream.bufferedWriter(charset: java.nio.charset.Charset /* = default */): java.io.BufferedWriter

// JVM method = byteInputStream(Ljava/lang/String;Ljava/nio/charset/Charset;)Ljava/io/ByteArrayInputStream;
inline fun String.byteInputStream(charset: java.nio.charset.Charset /* = default */): java.io.ByteArrayInputStream

// JVM method = copyTo(Ljava/io/InputStream;Ljava/io/OutputStream;I)J
fun java.io.InputStream.copyTo(out: java.io.OutputStream, bufferSize: Int /* = default */): Long

// JVM method = inputStream([B)Ljava/io/ByteArrayInputStream;
inline fun ByteArray.inputStream(): java.io.ByteArrayInputStream

// JVM method = inputStream([BII)Ljava/io/ByteArrayInputStream;
inline fun ByteArray.inputStream(offset: Int, length: Int): java.io.ByteArrayInputStream

// JVM method = iterator(Ljava/io/BufferedInputStream;)Lkotlin/collections/ByteIterator;
operator fun java.io.BufferedInputStream.iterator(): ByteIterator

// JVM method = readBytes(Ljava/io/InputStream;)[B
fun java.io.InputStream.readBytes(): ByteArray

// JVM method = readBytes(Ljava/io/InputStream;I)[B
fun java.io.InputStream.readBytes(estimatedSize: Int /* = default */): ByteArray

// JVM method = reader(Ljava/io/InputStream;Ljava/nio/charset/Charset;)Ljava/io/InputStreamReader;
inline fun java.io.InputStream.reader(charset: java.nio.charset.Charset /* = default */): java.io.InputStreamReader

// JVM method = writer(Ljava/io/OutputStream;Ljava/nio/charset/Charset;)Ljava/io/OutputStreamWriter;
inline fun java.io.OutputStream.writer(charset: java.nio.charset.Charset /* = default */): java.io.OutputStreamWriter

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.io.CloseableKt


// *** FUNCTIONS ***

// JVM method = closeFinally(Ljava/io/Closeable;Ljava/lang/Throwable;)V
internal fun java.io.Closeable?.closeFinally(cause: Throwable?)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = use(Ljava/io/Closeable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T : java.io.Closeable?, R> T : java.io.Closeable?.use(block: (T : java.io.Closeable?) -> R): R {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.io.ConsoleKt


// *** FUNCTIONS ***

// JVM method = print(Ljava/lang/Object;)V
inline fun print(message: Any?)

// JVM method = print(Z)V
inline fun print(message: Boolean)

// JVM method = print(B)V
inline fun print(message: Byte)

// JVM method = print(C)V
inline fun print(message: Char)

// JVM method = print([C)V
inline fun print(message: CharArray)

// JVM method = print(D)V
inline fun print(message: Double)

// JVM method = print(F)V
inline fun print(message: Float)

// JVM method = print(I)V
inline fun print(message: Int)

// JVM method = print(J)V
inline fun print(message: Long)

// JVM method = print(S)V
inline fun print(message: Short)

// JVM method = println()V
inline fun println()

// JVM method = println(Ljava/lang/Object;)V
inline fun println(message: Any?)

// JVM method = println(Z)V
inline fun println(message: Boolean)

// JVM method = println(B)V
inline fun println(message: Byte)

// JVM method = println(C)V
inline fun println(message: Char)

// JVM method = println([C)V
inline fun println(message: CharArray)

// JVM method = println(D)V
inline fun println(message: Double)

// JVM method = println(F)V
inline fun println(message: Float)

// JVM method = println(I)V
inline fun println(message: Int)

// JVM method = println(J)V
inline fun println(message: Long)

// JVM method = println(S)V
inline fun println(message: Short)

// JVM method = readLine()Ljava/lang/String;
fun readLine(): String?

// JVM method = readln()Ljava/lang/String;
fun readln(): String

// JVM method = readlnOrNull()Ljava/lang/String;
fun readlnOrNull(): String?

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.io.ConstantsKt


// *** PROPERTIES ***

// JVM field = DEFAULT_BLOCK_SIZE:I
internal const val DEFAULT_BLOCK_SIZE: Int

// JVM field = DEFAULT_BUFFER_SIZE:I
const val DEFAULT_BUFFER_SIZE: Int

// JVM field = MINIMUM_BLOCK_SIZE:I
internal const val MINIMUM_BLOCK_SIZE: Int

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.io.ExceptionsKt


// *** FUNCTIONS ***

// JVM method = constructMessage(Ljava/io/File;Ljava/io/File;Ljava/lang/String;)Ljava/lang/String;
private fun constructMessage(file: java.io.File, other: java.io.File?, reason: String?): String

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.io.SerializableKt


// *** TYPE ALIASES ***

internal typealias Serializable = java.io.Serializable

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.io.TextStreamsKt


// *** FUNCTIONS ***

// JVM method = buffered(Ljava/io/Reader;I)Ljava/io/BufferedReader;
inline fun java.io.Reader.buffered(bufferSize: Int /* = default */): java.io.BufferedReader

// JVM method = buffered(Ljava/io/Writer;I)Ljava/io/BufferedWriter;
inline fun java.io.Writer.buffered(bufferSize: Int /* = default */): java.io.BufferedWriter

// JVM method = copyTo(Ljava/io/Reader;Ljava/io/Writer;I)J
fun java.io.Reader.copyTo(out: java.io.Writer, bufferSize: Int /* = default */): Long

// JVM method = forEachLine(Ljava/io/Reader;Lkotlin/jvm/functions/Function1;)V
fun java.io.Reader.forEachLine(action: (String) -> Unit)

// JVM method = lineSequence(Ljava/io/BufferedReader;)Lkotlin/sequences/Sequence;
fun java.io.BufferedReader.lineSequence(): Sequence<String>

// JVM method = readBytes(Ljava/net/URL;)[B
fun java.net.URL.readBytes(): ByteArray

// JVM method = readLines(Ljava/io/Reader;)Ljava/util/List;
fun java.io.Reader.readLines(): List<String>

// JVM method = readText(Ljava/io/Reader;)Ljava/lang/String;
fun java.io.Reader.readText(): String

// JVM method = readText(Ljava/net/URL;Ljava/nio/charset/Charset;)Ljava/lang/String;
inline fun java.net.URL.readText(charset: java.nio.charset.Charset /* = default */): String

// JVM method = reader(Ljava/lang/String;)Ljava/io/StringReader;
inline fun String.reader(): java.io.StringReader

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = useLines(Ljava/io/Reader;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> java.io.Reader.useLines(block: (Sequence<String>) -> T): T

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.io.encoding.Base64JVMKt


// *** FUNCTIONS ***

// JVM method = platformCharsToBytes(Lkotlin/io/encoding/Base64;Ljava/lang/CharSequence;II)[B
internal inline fun kotlin.io.encoding.Base64.platformCharsToBytes(source: CharSequence, startIndex: Int, endIndex: Int): ByteArray

// JVM method = platformEncodeIntoByteArray(Lkotlin/io/encoding/Base64;[B[BIII)I
internal inline fun kotlin.io.encoding.Base64.platformEncodeIntoByteArray(source: ByteArray, destination: ByteArray, destinationOffset: Int, startIndex: Int, endIndex: Int): Int

// JVM method = platformEncodeToByteArray(Lkotlin/io/encoding/Base64;[BII)[B
internal inline fun kotlin.io.encoding.Base64.platformEncodeToByteArray(source: ByteArray, startIndex: Int, endIndex: Int): ByteArray

// JVM method = platformEncodeToString(Lkotlin/io/encoding/Base64;[BII)Ljava/lang/String;
internal inline fun kotlin.io.encoding.Base64.platformEncodeToString(source: ByteArray, startIndex: Int, endIndex: Int): String

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.io.encoding.Base64Kt


// *** PROPERTIES ***

// JVM field = base64DecodeMap:[I
// JVM annotation-holding method = getBase64DecodeMap$annotations()V
private val base64DecodeMap: IntArray

// JVM field = base64EncodeMap:[B
// JVM annotation-holding method = getBase64EncodeMap$annotations()V
private val base64EncodeMap: ByteArray

// JVM field = base64UrlDecodeMap:[I
// JVM annotation-holding method = getBase64UrlDecodeMap$annotations()V
private val base64UrlDecodeMap: IntArray

// JVM field = base64UrlEncodeMap:[B
// JVM annotation-holding method = getBase64UrlEncodeMap$annotations()V
private val base64UrlEncodeMap: ByteArray


// *** FUNCTIONS ***

// JVM method = isInMimeAlphabet(I)Z
internal fun isInMimeAlphabet(symbol: Int): Boolean

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.jvm.JvmClassMappingKt


// *** PROPERTIES ***

val <T : Annotation> T : Annotation.annotationClass: kotlin.reflect.KClass<out T : Annotation>
	// JVM method = getAnnotationClass(Ljava/lang/annotation/Annotation;)Lkotlin/reflect/KClass;
	get() = /* non-default */

// JVM annotation-holding method = getDeclaringJavaClass$annotations(Ljava/lang/Enum;)V
inline val <E : Enum<E>> Enum<E : Enum<E>>.declaringJavaClass: java.lang.Class<E : Enum<E>>
	// JVM method = getDeclaringJavaClass(Ljava/lang/Enum;)Ljava/lang/Class;
	get() = /* non-default */

// JVM annotation-holding method = getJavaClass$annotations(Lkotlin/reflect/KClass;)V
val <T> kotlin.reflect.KClass<T>.java: java.lang.Class<T>
	// JVM method = getJavaClass(Lkotlin/reflect/KClass;)Ljava/lang/Class;
	get() = /* non-default */

inline val <T : Any> T : Any.javaClass: java.lang.Class<T : Any>
	// JVM method = getJavaClass(Ljava/lang/Object;)Ljava/lang/Class;
	get() = /* non-default */

// JVM annotation-holding method = getRuntimeClassOfKClassInstance$annotations(Lkotlin/reflect/KClass;)V
inline val <T : Any> kotlin.reflect.KClass<T : Any>.javaClass: java.lang.Class<kotlin.reflect.KClass<T : Any>>
	// JVM method = getRuntimeClassOfKClassInstance(Lkotlin/reflect/KClass;)Ljava/lang/Class;
	get() = /* non-default */

val <T : Any> kotlin.reflect.KClass<T : Any>.javaObjectType: java.lang.Class<T : Any>
	// JVM method = getJavaObjectType(Lkotlin/reflect/KClass;)Ljava/lang/Class;
	get() = /* non-default */

val <T : Any> kotlin.reflect.KClass<T : Any>.javaPrimitiveType: java.lang.Class<T : Any>?
	// JVM method = getJavaPrimitiveType(Lkotlin/reflect/KClass;)Ljava/lang/Class;
	get() = /* non-default */

val <T : Any> java.lang.Class<T : Any>.kotlin: kotlin.reflect.KClass<T : Any>
	// JVM method = getKotlinClass(Ljava/lang/Class;)Lkotlin/reflect/KClass;
	get() = /* non-default */


// *** FUNCTIONS ***

// JVM method = isArrayOf([Ljava/lang/Object;)Z
fun <reified T : Any> Array<*>.isArrayOf(): Boolean

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.jvm.internal.ArrayIteratorKt


// *** FUNCTIONS ***

// JVM method = iterator([Ljava/lang/Object;)Ljava/util/Iterator;
fun <T> iterator(array: Array<T>): Iterator<T>

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.jvm.internal.ArrayIteratorsKt


// *** FUNCTIONS ***

// JVM method = iterator([Z)Lkotlin/collections/BooleanIterator;
fun iterator(array: BooleanArray): BooleanIterator

// JVM method = iterator([B)Lkotlin/collections/ByteIterator;
fun iterator(array: ByteArray): ByteIterator

// JVM method = iterator([C)Lkotlin/collections/CharIterator;
fun iterator(array: CharArray): CharIterator

// JVM method = iterator([D)Lkotlin/collections/DoubleIterator;
fun iterator(array: DoubleArray): DoubleIterator

// JVM method = iterator([F)Lkotlin/collections/FloatIterator;
fun iterator(array: FloatArray): FloatIterator

// JVM method = iterator([I)Lkotlin/collections/IntIterator;
fun iterator(array: IntArray): IntIterator

// JVM method = iterator([J)Lkotlin/collections/LongIterator;
fun iterator(array: LongArray): LongIterator

// JVM method = iterator([S)Lkotlin/collections/ShortIterator;
fun iterator(array: ShortArray): ShortIterator

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.jvm.internal.CollectionToArray


// *** PROPERTIES ***

// JVM field = EMPTY:[Ljava/lang/Object;
private val EMPTY: Array<Any?>

// JVM field = MAX_SIZE:I
private const val MAX_SIZE: Int


// *** FUNCTIONS ***

// JVM method = toArray(Ljava/util/Collection;)[Ljava/lang/Object;
fun collectionToArray(collection: Collection<*>): Array<Any?>

// JVM method = toArray(Ljava/util/Collection;[Ljava/lang/Object;)[Ljava/lang/Object;
fun collectionToArray(collection: Collection<*>, a: Array<Any?>?): Array<Any?>

// JVM method = toArrayImpl(Ljava/util/Collection;Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function2;)[Ljava/lang/Object;
private inline fun toArrayImpl(collection: Collection<*>, empty: () -> Array<Any?>, alloc: (Int) -> Array<Any?>, trim: (Array<Any?>, Int) -> Array<Any?>): Array<Any?>

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.jvm.internal.LocalVariableReferencesKt


// *** FUNCTIONS ***

// JVM method = notSupportedError()Ljava/lang/Void;
private fun notSupportedError(): Nothing

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.jvm.internal.unsafe.MonitorKt


// *** FUNCTIONS ***

// JVM method = monitorEnter(Ljava/lang/Object;)V
private fun monitorEnter(monitor: Any)

// JVM method = monitorExit(Ljava/lang/Object;)V
private fun monitorExit(monitor: Any)

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.math.UMathKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = max-J1ME1BU(II)I
inline fun max(a: UInt, b: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = max-eb3DHEI(JJ)J
inline fun max(a: ULong, b: ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = min-J1ME1BU(II)I
inline fun min(a: UInt, b: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = min-eb3DHEI(JJ)J
inline fun min(a: ULong, b: ULong): ULong

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.random.PlatformRandomKt


// *** FUNCTIONS ***

// JVM method = defaultPlatformRandom()Lkotlin/random/Random;
internal inline fun defaultPlatformRandom(): kotlin.random.Random

// JVM method = doubleFromParts(II)D
internal fun doubleFromParts(hi26: Int, low27: Int): Double

// JVM method = asJavaRandom(Lkotlin/random/Random;)Ljava/util/Random;
fun kotlin.random.Random.asJavaRandom(): java.util.Random

// JVM method = asKotlinRandom(Ljava/util/Random;)Lkotlin/random/Random;
fun java.util.Random.asKotlinRandom(): kotlin.random.Random

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.random.RandomKt


// *** FUNCTIONS ***

// JVM method = Random(I)Lkotlin/random/Random;
fun Random(seed: Int): kotlin.random.Random

// JVM method = Random(J)Lkotlin/random/Random;
fun Random(seed: Long): kotlin.random.Random

// JVM method = boundsErrorMessage(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/String;
internal fun boundsErrorMessage(from: Any, until: Any): String

// JVM method = checkRangeBounds(DD)V
internal fun checkRangeBounds(from: Double, until: Double)

// JVM method = checkRangeBounds(II)V
internal fun checkRangeBounds(from: Int, until: Int)

// JVM method = checkRangeBounds(JJ)V
internal fun checkRangeBounds(from: Long, until: Long)

// JVM method = fastLog2(I)I
internal fun fastLog2(value: Int): Int

// JVM method = nextInt(Lkotlin/random/Random;Lkotlin/ranges/IntRange;)I
fun kotlin.random.Random.nextInt(range: IntRange): Int

// JVM method = nextLong(Lkotlin/random/Random;Lkotlin/ranges/LongRange;)J
fun kotlin.random.Random.nextLong(range: LongRange): Long

// JVM method = takeUpperBits(II)I
internal fun Int.takeUpperBits(bitCount: Int): Int

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.random.URandomKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = checkUIntRangeBounds-J1ME1BU(II)V
internal fun checkUIntRangeBounds(from: UInt, until: UInt)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = checkULongRangeBounds-eb3DHEI(JJ)V
internal fun checkULongRangeBounds(from: ULong, until: ULong)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = nextUBytes(Lkotlin/random/Random;I)[B
fun kotlin.random.Random.nextUBytes(size: Int): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = nextUBytes-EVgfTAA(Lkotlin/random/Random;[B)[B
fun kotlin.random.Random.nextUBytes(array: UByteArray): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = nextUBytes-Wvrt4B4(Lkotlin/random/Random;[BII)[B
fun kotlin.random.Random.nextUBytes(array: UByteArray, fromIndex: Int /* = default */, toIndex: Int /* = default */): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = nextUInt(Lkotlin/random/Random;)I
fun kotlin.random.Random.nextUInt(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = nextUInt-qCasIEU(Lkotlin/random/Random;I)I
fun kotlin.random.Random.nextUInt(until: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = nextUInt-a8DCA5k(Lkotlin/random/Random;II)I
fun kotlin.random.Random.nextUInt(from: UInt, until: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = nextUInt(Lkotlin/random/Random;Lkotlin/ranges/UIntRange;)I
fun kotlin.random.Random.nextUInt(range: UIntRange): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = nextULong(Lkotlin/random/Random;)J
fun kotlin.random.Random.nextULong(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = nextULong-V1Xi4fY(Lkotlin/random/Random;J)J
fun kotlin.random.Random.nextULong(until: ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = nextULong-jmpaW-c(Lkotlin/random/Random;JJ)J
fun kotlin.random.Random.nextULong(from: ULong, until: ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = nextULong(Lkotlin/random/Random;Lkotlin/ranges/ULongRange;)J
fun kotlin.random.Random.nextULong(range: ULongRange): ULong

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.reflect.KClasses


// *** FUNCTIONS ***

// JVM method = cast(Lkotlin/reflect/KClass;Ljava/lang/Object;)Ljava/lang/Object;
fun <T : Any> kotlin.reflect.KClass<T : Any>.cast(value: Any?): T : Any

// JVM method = safeCast(Lkotlin/reflect/KClass;Ljava/lang/Object;)Ljava/lang/Object;
fun <T : Any> kotlin.reflect.KClass<T : Any>.safeCast(value: Any?): T : Any?

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.reflect.KClassesImplKt


// *** PROPERTIES ***

internal inline val kotlin.reflect.KClass<*>.qualifiedOrSimpleName: String?
	// JVM method = getQualifiedOrSimpleName(Lkotlin/reflect/KClass;)Ljava/lang/String;
	get() = /* non-default */

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.reflect.TypeOfKt


// *** FUNCTIONS ***

// JVM method = typeOf()Lkotlin/reflect/KType;
inline fun <reified T> typeOf(): kotlin.reflect.KType

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.reflect.TypesJVMKt


// *** PROPERTIES ***

// JVM annotation-holding method = getJavaType$annotations(Lkotlin/reflect/KType;)V
val kotlin.reflect.KType.javaType: java.lang.reflect.Type
	// JVM method = getJavaType(Lkotlin/reflect/KType;)Ljava/lang/reflect/Type;
	get() = /* non-default */

// JVM annotation-holding method = getJavaType$annotations(Lkotlin/reflect/KTypeProjection;)V
private val kotlin.reflect.KTypeProjection.javaType: java.lang.reflect.Type
	// JVM method = getJavaType(Lkotlin/reflect/KTypeProjection;)Ljava/lang/reflect/Type;
	get() = /* non-default */


// *** FUNCTIONS ***

// JVM method = createPossiblyInnerType(Ljava/lang/Class;Ljava/util/List;)Ljava/lang/reflect/Type;
private fun createPossiblyInnerType(jClass: java.lang.Class<*>, arguments: List<kotlin.reflect.KTypeProjection>): java.lang.reflect.Type

// JVM method = typeToString(Ljava/lang/reflect/Type;)Ljava/lang/String;
private fun typeToString(type: java.lang.reflect.Type): String

// JVM method = computeJavaType(Lkotlin/reflect/KType;Z)Ljava/lang/reflect/Type;
private fun kotlin.reflect.KType.computeJavaType(forceWrapper: Boolean /* = default */): java.lang.reflect.Type

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.system.ProcessKt


// *** FUNCTIONS ***

// JVM method = exitProcess(I)Ljava/lang/Void;
inline fun exitProcess(status: Int): Nothing

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.system.TimingKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = measureNanoTime(Lkotlin/jvm/functions/Function0;)J
inline fun measureNanoTime(block: () -> Unit): Long {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = measureTimeMillis(Lkotlin/jvm/functions/Function0;)J
inline fun measureTimeMillis(block: () -> Unit): Long {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.text.CharsetsKt


// *** FUNCTIONS ***

// JVM method = charset(Ljava/lang/String;)Ljava/nio/charset/Charset;
inline fun charset(charsetName: String): java.nio.charset.Charset

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.text.RegexKt


// *** FUNCTIONS ***

// JVM method = fromInt(I)Ljava/util/Set;
private inline fun <reified T> fromInt(value: Int): Set<reified T> where
	T : FlagEnum,
	T : Enum<reified T>

// JVM method = findNext(Ljava/util/regex/Matcher;ILjava/lang/CharSequence;)Lkotlin/text/MatchResult;
private fun java.util.regex.Matcher.findNext(from: Int, input: CharSequence): MatchResult?

// JVM method = matchEntire(Ljava/util/regex/Matcher;Ljava/lang/CharSequence;)Lkotlin/text/MatchResult;
private fun java.util.regex.Matcher.matchEntire(input: CharSequence): MatchResult?

// JVM method = range(Ljava/util/regex/MatchResult;)Lkotlin/ranges/IntRange;
private fun java.util.regex.MatchResult.range(): IntRange

// JVM method = range(Ljava/util/regex/MatchResult;I)Lkotlin/ranges/IntRange;
private fun java.util.regex.MatchResult.range(groupIndex: Int): IntRange

// JVM method = toInt(Ljava/lang/Iterable;)I
private fun Iterable<FlagEnum>.toInt(): Int

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.text.TypeAliasesKt


// *** TYPE ALIASES ***

@SinceKotlin(version = "1.1")
typealias Appendable = java.lang.Appendable

@SinceKotlin(version = "1.4")
@WasExperimental(markerClass = [ ExperimentalStdlibApi::class ])
typealias CharacterCodingException = java.nio.charset.CharacterCodingException

@SinceKotlin(version = "1.1")
typealias StringBuilder = java.lang.StringBuilder

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.text.UStringsKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toString-LxnNnR4(BI)Ljava/lang/String;
fun UByte.toString(radix: Int): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toString-V7xB4Y4(II)Ljava/lang/String;
fun UInt.toString(radix: Int): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toString-JSWoG40(JI)Ljava/lang/String;
fun ULong.toString(radix: Int): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toString-olVBNx4(SI)Ljava/lang/String;
fun UShort.toString(radix: Int): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUByte(Ljava/lang/String;)B
fun String.toUByte(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUByte(Ljava/lang/String;I)B
fun String.toUByte(radix: Int): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUByteOrNull(Ljava/lang/String;)Lkotlin/UByte;
fun String.toUByteOrNull(): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUByteOrNull(Ljava/lang/String;I)Lkotlin/UByte;
fun String.toUByteOrNull(radix: Int): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUInt(Ljava/lang/String;)I
fun String.toUInt(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUInt(Ljava/lang/String;I)I
fun String.toUInt(radix: Int): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUIntOrNull(Ljava/lang/String;)Lkotlin/UInt;
fun String.toUIntOrNull(): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUIntOrNull(Ljava/lang/String;I)Lkotlin/UInt;
fun String.toUIntOrNull(radix: Int): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULong(Ljava/lang/String;)J
fun String.toULong(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULong(Ljava/lang/String;I)J
fun String.toULong(radix: Int): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULongOrNull(Ljava/lang/String;)Lkotlin/ULong;
fun String.toULongOrNull(): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULongOrNull(Ljava/lang/String;I)Lkotlin/ULong;
fun String.toULongOrNull(radix: Int): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUShort(Ljava/lang/String;)S
fun String.toUShort(): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUShort(Ljava/lang/String;I)S
fun String.toUShort(radix: Int): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUShortOrNull(Ljava/lang/String;)Lkotlin/UShort;
fun String.toUShortOrNull(): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUShortOrNull(Ljava/lang/String;I)Lkotlin/UShort;
fun String.toUShortOrNull(radix: Int): UShort?

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.text._OneToManyTitlecaseMappingsKt


// *** FUNCTIONS ***

// JVM method = titlecaseImpl(C)Ljava/lang/String;
internal fun Char.titlecaseImpl(): String

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.time.DurationJvmKt


// *** PROPERTIES ***

// JVM field = durationAssertionsEnabled:Z
internal val durationAssertionsEnabled: Boolean

// JVM field = precisionFormats:[Ljava/lang/ThreadLocal;
private val precisionFormats: Array<java.lang.ThreadLocal<java.text.DecimalFormat>>


// *** FUNCTIONS ***

// JVM method = createFormatForDecimals(I)Ljava/text/DecimalFormat;
private fun createFormatForDecimals(decimals: Int): java.text.DecimalFormat

// JVM method = formatToExactDecimals(DI)Ljava/lang/String;
internal fun formatToExactDecimals(value: Double, decimals: Int): String

// JVM method = formatUpToDecimals(DI)Ljava/lang/String;
internal fun formatUpToDecimals(value: Double, decimals: Int): String

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.time.DurationKt


// *** PROPERTIES ***

// JVM field = MAX_MILLIS:J
internal const val MAX_MILLIS: Long

// JVM field = MAX_NANOS:J
internal const val MAX_NANOS: Long

// JVM field = MAX_NANOS_IN_MILLIS:J
private const val MAX_NANOS_IN_MILLIS: Long

// JVM field = NANOS_IN_MILLIS:I
internal const val NANOS_IN_MILLIS: Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getDays$annotations(D)V
val Double.days: kotlin.time.Duration
	// JVM method = getDays(D)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getDays$annotations(I)V
val Int.days: kotlin.time.Duration
	// JVM method = getDays(I)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getDays$annotations(J)V
val Long.days: kotlin.time.Duration
	// JVM method = getDays(J)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getHours$annotations(D)V
val Double.hours: kotlin.time.Duration
	// JVM method = getHours(D)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getHours$annotations(I)V
val Int.hours: kotlin.time.Duration
	// JVM method = getHours(I)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getHours$annotations(J)V
val Long.hours: kotlin.time.Duration
	// JVM method = getHours(J)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getMicroseconds$annotations(D)V
val Double.microseconds: kotlin.time.Duration
	// JVM method = getMicroseconds(D)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getMicroseconds$annotations(I)V
val Int.microseconds: kotlin.time.Duration
	// JVM method = getMicroseconds(I)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getMicroseconds$annotations(J)V
val Long.microseconds: kotlin.time.Duration
	// JVM method = getMicroseconds(J)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getMilliseconds$annotations(D)V
val Double.milliseconds: kotlin.time.Duration
	// JVM method = getMilliseconds(D)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getMilliseconds$annotations(I)V
val Int.milliseconds: kotlin.time.Duration
	// JVM method = getMilliseconds(I)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getMilliseconds$annotations(J)V
val Long.milliseconds: kotlin.time.Duration
	// JVM method = getMilliseconds(J)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getMinutes$annotations(D)V
val Double.minutes: kotlin.time.Duration
	// JVM method = getMinutes(D)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getMinutes$annotations(I)V
val Int.minutes: kotlin.time.Duration
	// JVM method = getMinutes(I)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getMinutes$annotations(J)V
val Long.minutes: kotlin.time.Duration
	// JVM method = getMinutes(J)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getNanoseconds$annotations(D)V
val Double.nanoseconds: kotlin.time.Duration
	// JVM method = getNanoseconds(D)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getNanoseconds$annotations(I)V
val Int.nanoseconds: kotlin.time.Duration
	// JVM method = getNanoseconds(I)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getNanoseconds$annotations(J)V
val Long.nanoseconds: kotlin.time.Duration
	// JVM method = getNanoseconds(J)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getSeconds$annotations(D)V
val Double.seconds: kotlin.time.Duration
	// JVM method = getSeconds(D)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getSeconds$annotations(I)V
val Int.seconds: kotlin.time.Duration
	// JVM method = getSeconds(I)J
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getSeconds$annotations(J)V
val Long.seconds: kotlin.time.Duration
	// JVM method = getSeconds(J)J
	get() = /* non-default */


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = durationOf(JI)J
private fun durationOf(normalValue: Long, unitDiscriminator: Int): kotlin.time.Duration

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = durationOfMillis(J)J
private fun durationOfMillis(normalMillis: Long): kotlin.time.Duration

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = durationOfMillisNormalized(J)J
private fun durationOfMillisNormalized(millis: Long): kotlin.time.Duration

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = durationOfNanos(J)J
private fun durationOfNanos(normalNanos: Long): kotlin.time.Duration

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = durationOfNanosNormalized(J)J
private fun durationOfNanosNormalized(nanos: Long): kotlin.time.Duration

// JVM method = millisToNanos(J)J
private fun millisToNanos(millis: Long): Long

// JVM method = nanosToMillis(J)J
private fun nanosToMillis(nanos: Long): Long

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = parseDuration(Ljava/lang/String;Z)J
private fun parseDuration(value: String, strictIso: Boolean): kotlin.time.Duration

// JVM method = parseOverLongIsoComponent(Ljava/lang/String;)J
private fun parseOverLongIsoComponent(value: String): Long

// JVM method = skipWhile(Ljava/lang/String;ILkotlin/jvm/functions/Function1;)I
private inline fun String.skipWhile(startIndex: Int, predicate: (Char) -> Boolean): Int

// JVM method = substringWhile(Ljava/lang/String;ILkotlin/jvm/functions/Function1;)Ljava/lang/String;
private inline fun String.substringWhile(startIndex: Int, predicate: (Char) -> Boolean): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = times-kIfJnKk(DJ)J
inline operator fun Double.times(duration: kotlin.time.Duration): kotlin.time.Duration

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = times-mvk6XK0(IJ)J
inline operator fun Int.times(duration: kotlin.time.Duration): kotlin.time.Duration

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toDuration(DLkotlin/time/DurationUnit;)J
fun Double.toDuration(unit: kotlin.time.DurationUnit): kotlin.time.Duration

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toDuration(ILkotlin/time/DurationUnit;)J
fun Int.toDuration(unit: kotlin.time.DurationUnit): kotlin.time.Duration

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toDuration(JLkotlin/time/DurationUnit;)J
fun Long.toDuration(unit: kotlin.time.DurationUnit): kotlin.time.Duration

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.time.LongSaturatedMathKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = checkInfiniteSumDefined-PjuGub4(JJJ)J
private fun checkInfiniteSumDefined(longNs: Long, duration: kotlin.time.Duration, durationNs: Long): Long

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = saturatingAdd-pTJri5U(JJ)J
internal fun saturatingAdd(longNs: Long, duration: kotlin.time.Duration): Long

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = saturatingAddInHalves-pTJri5U(JJ)J
private fun saturatingAddInHalves(longNs: Long, duration: kotlin.time.Duration): Long

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = saturatingDiff(JJ)J
internal fun saturatingDiff(valueNs: Long, originNs: Long): kotlin.time.Duration

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = saturatingFiniteDiff(JJ)J
private fun saturatingFiniteDiff(value1Ns: Long, value2Ns: Long): kotlin.time.Duration

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = saturatingOriginsDiff(JJ)J
internal fun saturatingOriginsDiff(origin1Ns: Long, origin2Ns: Long): kotlin.time.Duration

// JVM method = isSaturated(J)Z
private inline fun Long.isSaturated(): Boolean

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.time.MeasureTimeKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = measureTime(Lkotlin/jvm/functions/Function0;)J
inline fun measureTime(block: () -> Unit): kotlin.time.Duration {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = measureTimedValue(Lkotlin/jvm/functions/Function0;)Lkotlin/time/TimedValue;
inline fun <T> measureTimedValue(block: () -> T): kotlin.time.TimedValue<T> {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = measureTime(Lkotlin/time/TimeSource;Lkotlin/jvm/functions/Function0;)J
inline fun kotlin.time.TimeSource.measureTime(block: () -> Unit): kotlin.time.Duration {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = measureTime(Lkotlin/time/TimeSource$Monotonic;Lkotlin/jvm/functions/Function0;)J
inline fun kotlin.time.TimeSource.Monotonic.measureTime(block: () -> Unit): kotlin.time.Duration {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = measureTimedValue(Lkotlin/time/TimeSource;Lkotlin/jvm/functions/Function0;)Lkotlin/time/TimedValue;
inline fun <T> kotlin.time.TimeSource.measureTimedValue(block: () -> T): kotlin.time.TimedValue<T> {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = measureTimedValue(Lkotlin/time/TimeSource$Monotonic;Lkotlin/jvm/functions/Function0;)Lkotlin/time/TimedValue;
inline fun <T> kotlin.time.TimeSource.Monotonic.measureTimedValue(block: () -> T): kotlin.time.TimedValue<T> {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.time.MonoTimeSourceKt


// *** TYPE ALIASES ***

internal typealias ValueTimeMarkReading = Long

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.io.path.PathTreeWalkKt


// *** FUNCTIONS ***

// JVM method = keyOf(Ljava/nio/file/Path;[Ljava/nio/file/LinkOption;)Ljava/lang/Object;
private fun keyOf(path: java.nio.file.Path, linkOptions: Array<java.nio.file.LinkOption>): Any?

// JVM method = createsCycle(Lkotlin/io/path/PathNode;)Z
private fun kotlin.io.path.PathNode.createsCycle(): Boolean

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

// JVM: kotlin/jdk7/AutoCloseableKt
/* facade */ class kotlin.AutoCloseableKt


// *** FUNCTIONS ***

// JVM method = closeFinally(Ljava/lang/AutoCloseable;Ljava/lang/Throwable;)V
internal fun java.lang.AutoCloseable?.closeFinally(cause: Throwable?)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = use(Ljava/lang/AutoCloseable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T : java.lang.AutoCloseable?, R> T : java.lang.AutoCloseable?.use(block: (T : java.lang.AutoCloseable?) -> R): R {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

// JVM: kotlin/collections/jdk8/CollectionsJDK8Kt
/* facade */ class kotlin.collections.CollectionsJDK8Kt


// *** FUNCTIONS ***

// JVM method = getOrDefault(Ljava/util/Map;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
inline fun <@kotlin.internal.OnlyInputTypes K, V> Map<out @kotlin.internal.OnlyInputTypes K, V>.getOrDefault(key: @kotlin.internal.OnlyInputTypes K, defaultValue: V): V

// JVM method = remove(Ljava/util/Map;Ljava/lang/Object;Ljava/lang/Object;)Z
inline fun <@kotlin.internal.OnlyInputTypes K, @kotlin.internal.OnlyInputTypes V> MutableMap<out @kotlin.internal.OnlyInputTypes K, out @kotlin.internal.OnlyInputTypes V>.remove(key: @kotlin.internal.OnlyInputTypes K, value: @kotlin.internal.OnlyInputTypes V): Boolean

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

// JVM: kotlin/jvm/jdk8/JvmRepeatableKt
/* facade */ class kotlin.jvm.JvmRepeatableKt


// *** TYPE ALIASES ***

@SinceKotlin(version = "1.6")
typealias JvmRepeatable = java.lang.annotation.Repeatable

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

/* facade */ class kotlin.jvm.optionals.OptionalsKt


// *** FUNCTIONS ***

// JVM method = asSequence(Ljava/util/Optional;)Lkotlin/sequences/Sequence;
fun <T : Any> java.util.Optional<out T : Any>.asSequence(): Sequence<T : Any>

// requires language version >= 1.7, otherwise diagnostic error
// JVM method = getOrDefault(Ljava/util/Optional;Ljava/lang/Object;)Ljava/lang/Object;
fun <T> java.util.Optional<out T>.getOrDefault(defaultValue: T): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.7, otherwise diagnostic error
// JVM method = getOrElse(Ljava/util/Optional;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <T> java.util.Optional<out T>.getOrElse(defaultValue: () -> T): T

// JVM method = getOrNull(Ljava/util/Optional;)Ljava/lang/Object;
fun <T : Any> java.util.Optional<T : Any>.getOrNull(): T : Any?

// JVM method = toCollection(Ljava/util/Optional;Ljava/util/Collection;)Ljava/util/Collection;
fun <T : Any, C : MutableCollection<in T : Any>> java.util.Optional<T : Any>.toCollection(destination: C : MutableCollection<in T : Any>): C : MutableCollection<in T : Any>

// JVM method = toList(Ljava/util/Optional;)Ljava/util/List;
fun <T : Any> java.util.Optional<out T : Any>.toList(): List<T : Any>

// JVM method = toSet(Ljava/util/Optional;)Ljava/util/Set;
fun <T : Any> java.util.Optional<out T : Any>.toSet(): Set<T : Any>

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

// JVM: kotlin/streams/jdk8/StreamsKt
/* facade */ class kotlin.streams.StreamsKt


// *** FUNCTIONS ***

// JVM method = asSequence(Ljava/util/stream/DoubleStream;)Lkotlin/sequences/Sequence;
fun java.util.stream.DoubleStream.asSequence(): Sequence<Double>

// JVM method = asSequence(Ljava/util/stream/IntStream;)Lkotlin/sequences/Sequence;
fun java.util.stream.IntStream.asSequence(): Sequence<Int>

// JVM method = asSequence(Ljava/util/stream/LongStream;)Lkotlin/sequences/Sequence;
fun java.util.stream.LongStream.asSequence(): Sequence<Long>

// JVM method = asSequence(Ljava/util/stream/Stream;)Lkotlin/sequences/Sequence;
fun <T> java.util.stream.Stream<T>.asSequence(): Sequence<T>

// JVM method = asStream(Lkotlin/sequences/Sequence;)Ljava/util/stream/Stream;
fun <T> Sequence<T>.asStream(): java.util.stream.Stream<T>

// JVM method = toList(Ljava/util/stream/DoubleStream;)Ljava/util/List;
fun java.util.stream.DoubleStream.toList(): List<Double>

// JVM method = toList(Ljava/util/stream/IntStream;)Ljava/util/List;
fun java.util.stream.IntStream.toList(): List<Int>

// JVM method = toList(Ljava/util/stream/LongStream;)Ljava/util/List;
fun java.util.stream.LongStream.toList(): List<Long>

// JVM method = toList(Ljava/util/stream/Stream;)Ljava/util/List;
fun <T> java.util.stream.Stream<T>.toList(): List<T>

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

// JVM: kotlin/text/jdk8/RegexExtensionsJDK8Kt
/* facade */ class kotlin.text.RegexExtensionsJDK8Kt


// *** FUNCTIONS ***

// JVM method = get(Lkotlin/text/MatchGroupCollection;Ljava/lang/String;)Lkotlin/text/MatchGroup;
operator fun MatchGroupCollection.get(name: String): MatchGroup?

// ------------------------------------------------------------------------------------------------------

/* file-level declarations */

// JVM: kotlin/time/jdk8/DurationConversionsJDK8Kt
/* facade */ class kotlin.time.DurationConversionsJDK8Kt


// *** FUNCTIONS ***

// requires compiler version >= 1.4.30, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toJavaDuration-LRDsOJo(J)Ljava/time/Duration;
inline fun kotlin.time.Duration.toJavaDuration(): java.time.Duration

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toKotlinDuration(Ljava/time/Duration;)J
inline fun java.time.Duration.toKotlinDuration(): kotlin.time.Duration

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.ExceptionsKt

/* part */ class ExceptionsKt__ExceptionsKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.LazyKt

/* part */ class LazyKt__LazyJVMKt
/* part */ class LazyKt__LazyKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.NumbersKt

/* part */ class NumbersKt__BigDecimalsKt
/* part */ class NumbersKt__BigIntegersKt
/* part */ class NumbersKt__FloorDivModKt
/* part */ class NumbersKt__NumbersJVMKt
/* part */ class NumbersKt__NumbersKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.PreconditionsKt

/* part */ class PreconditionsKt__AssertionsJVMKt
/* part */ class PreconditionsKt__PreconditionsKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.StandardKt

/* part */ class StandardKt__StandardKt
/* part */ class StandardKt__SynchronizedKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.collections.ArraysKt

/* part */ class ArraysKt__ArraysJVMKt
/* part */ class ArraysKt__ArraysKt
/* part */ class ArraysKt___ArraysJvmKt
/* part */ class ArraysKt___ArraysKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.collections.CollectionsKt

/* part */ class CollectionsKt__CollectionsJVMKt
/* part */ class CollectionsKt__CollectionsKt
/* part */ class CollectionsKt__IterablesKt
/* part */ class CollectionsKt__IteratorsJVMKt
/* part */ class CollectionsKt__IteratorsKt
/* part */ class CollectionsKt__MutableCollectionsJVMKt
/* part */ class CollectionsKt__MutableCollectionsKt
/* part */ class CollectionsKt__ReversedViewsKt
/* part */ class CollectionsKt___CollectionsJvmKt
/* part */ class CollectionsKt___CollectionsKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.collections.GroupingKt

/* part */ class GroupingKt__GroupingJVMKt
/* part */ class GroupingKt__GroupingKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.collections.MapsKt

/* part */ class MapsKt__MapWithDefaultKt
/* part */ class MapsKt__MapsJVMKt
/* part */ class MapsKt__MapsKt
/* part */ class MapsKt___MapsJvmKt
/* part */ class MapsKt___MapsKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.collections.SetsKt

/* part */ class SetsKt__SetsJVMKt
/* part */ class SetsKt__SetsKt
/* part */ class SetsKt___SetsKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.collections.UCollectionsKt

/* part */ class UCollectionsKt___UCollectionsKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.collections.unsigned.UArraysKt

/* part */ class kotlin.collections.unsigned.UArraysKt___UArraysJvmKt
/* part */ class kotlin.collections.unsigned.UArraysKt___UArraysKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.comparisons.ComparisonsKt

/* part */ class ComparisonsKt__ComparisonsKt
/* part */ class ComparisonsKt___ComparisonsJvmKt
/* part */ class ComparisonsKt___ComparisonsKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.comparisons.UComparisonsKt

/* part */ class UComparisonsKt___UComparisonsKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.coroutines.intrinsics.IntrinsicsKt

/* part */ class kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsJvmKt
/* part */ class kotlin.coroutines.intrinsics.IntrinsicsKt__IntrinsicsKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.io.FilesKt

/* part */ class FilesKt__FilePathComponentsKt
/* part */ class FilesKt__FileReadWriteKt
/* part */ class FilesKt__FileTreeWalkKt
/* part */ class FilesKt__UtilsKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.io.encoding.StreamEncodingKt

/* part */ class kotlin.io.encoding.StreamEncodingKt__Base64IOStreamKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.math.MathKt

/* part */ class kotlin.math.MathKt__MathHKt
/* part */ class kotlin.math.MathKt__MathJVMKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.ranges.RangesKt

/* part */ class RangesKt__RangesKt
/* part */ class RangesKt___RangesKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.ranges.URangesKt

/* part */ class URangesKt___URangesKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.sequences.SequencesKt

/* part */ class SequencesKt__SequenceBuilderKt
/* part */ class SequencesKt__SequencesJVMKt
/* part */ class SequencesKt__SequencesKt
/* part */ class SequencesKt___SequencesJvmKt
/* part */ class SequencesKt___SequencesKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.sequences.USequencesKt

/* part */ class USequencesKt___USequencesKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.text.CharsKt

/* part */ class CharsKt__CharJVMKt
/* part */ class CharsKt__CharKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.text.StringsKt

/* part */ class StringsKt__AppendableKt
/* part */ class StringsKt__IndentKt
/* part */ class StringsKt__RegexExtensionsJVMKt
/* part */ class StringsKt__RegexExtensionsKt
/* part */ class StringsKt__StringBuilderJVMKt
/* part */ class StringsKt__StringBuilderKt
/* part */ class StringsKt__StringNumberConversionsJVMKt
/* part */ class StringsKt__StringNumberConversionsKt
/* part */ class StringsKt__StringsJVMKt
/* part */ class StringsKt__StringsKt
/* part */ class StringsKt___StringsJvmKt
/* part */ class StringsKt___StringsKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.time.DurationUnitKt

/* part */ class kotlin.time.DurationUnitKt__DurationUnitJvmKt
/* part */ class kotlin.time.DurationUnitKt__DurationUnitKt

// ------------------------------------------------------------------------------------------------------

/* multi-file class */

/* facade */ class kotlin.io.path.PathsKt

/* part */ class kotlin.io.path.PathsKt__PathReadWriteKt
/* part */ class kotlin.io.path.PathsKt__PathRecursiveFunctionsKt
/* part */ class kotlin.io.path.PathsKt__PathUtilsKt

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.ExceptionsKt


// *** PROPERTIES ***

// JVM annotation-holding method = getStackTrace$annotations(Ljava/lang/Throwable;)V
val Throwable.stackTrace: Array<java.lang.StackTraceElement>
	// JVM method = getStackTrace(Ljava/lang/Throwable;)[Ljava/lang/StackTraceElement;
	get() = /* non-default */

// JVM annotation-holding method = getSuppressedExceptions$annotations(Ljava/lang/Throwable;)V
val Throwable.suppressedExceptions: List<Throwable>
	// JVM method = getSuppressedExceptions(Ljava/lang/Throwable;)Ljava/util/List;
	get() = /* non-default */


// *** FUNCTIONS ***

// JVM method = addSuppressed(Ljava/lang/Throwable;Ljava/lang/Throwable;)V
fun Throwable.addSuppressed(exception: Throwable)

// JVM method = printStackTrace(Ljava/lang/Throwable;)V
inline fun Throwable.printStackTrace()

// JVM method = printStackTrace(Ljava/lang/Throwable;Ljava/io/PrintStream;)V
inline fun Throwable.printStackTrace(stream: java.io.PrintStream)

// JVM method = printStackTrace(Ljava/lang/Throwable;Ljava/io/PrintWriter;)V
inline fun Throwable.printStackTrace(writer: java.io.PrintWriter)

// JVM method = stackTraceToString(Ljava/lang/Throwable;)Ljava/lang/String;
fun Throwable.stackTraceToString(): String

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.LazyKt


// *** FUNCTIONS ***

// JVM method = lazy(Lkotlin/jvm/functions/Function0;)Lkotlin/Lazy;
fun <T> lazy(initializer: () -> T): Lazy<T>

// JVM method = lazy(Ljava/lang/Object;Lkotlin/jvm/functions/Function0;)Lkotlin/Lazy;
fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T>

// JVM method = lazy(Lkotlin/LazyThreadSafetyMode;Lkotlin/jvm/functions/Function0;)Lkotlin/Lazy;
fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.LazyKt


// *** FUNCTIONS ***

// JVM method = lazyOf(Ljava/lang/Object;)Lkotlin/Lazy;
fun <T> lazyOf(value: T): Lazy<T>

// JVM method = getValue(Lkotlin/Lazy;Ljava/lang/Object;Lkotlin/reflect/KProperty;)Ljava/lang/Object;
inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: kotlin.reflect.KProperty<*>): T

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.NumbersKt


// *** FUNCTIONS ***

// JVM method = dec(Ljava/math/BigDecimal;)Ljava/math/BigDecimal;
inline operator fun java.math.BigDecimal.dec(): java.math.BigDecimal

// JVM method = div(Ljava/math/BigDecimal;Ljava/math/BigDecimal;)Ljava/math/BigDecimal;
inline operator fun java.math.BigDecimal.div(other: java.math.BigDecimal): java.math.BigDecimal

// JVM method = inc(Ljava/math/BigDecimal;)Ljava/math/BigDecimal;
inline operator fun java.math.BigDecimal.inc(): java.math.BigDecimal

// JVM method = minus(Ljava/math/BigDecimal;Ljava/math/BigDecimal;)Ljava/math/BigDecimal;
inline operator fun java.math.BigDecimal.minus(other: java.math.BigDecimal): java.math.BigDecimal

// JVM method = plus(Ljava/math/BigDecimal;Ljava/math/BigDecimal;)Ljava/math/BigDecimal;
inline operator fun java.math.BigDecimal.plus(other: java.math.BigDecimal): java.math.BigDecimal

// JVM method = rem(Ljava/math/BigDecimal;Ljava/math/BigDecimal;)Ljava/math/BigDecimal;
inline operator fun java.math.BigDecimal.rem(other: java.math.BigDecimal): java.math.BigDecimal

// JVM method = times(Ljava/math/BigDecimal;Ljava/math/BigDecimal;)Ljava/math/BigDecimal;
inline operator fun java.math.BigDecimal.times(other: java.math.BigDecimal): java.math.BigDecimal

// JVM method = toBigDecimal(D)Ljava/math/BigDecimal;
inline fun Double.toBigDecimal(): java.math.BigDecimal

// JVM method = toBigDecimal(DLjava/math/MathContext;)Ljava/math/BigDecimal;
inline fun Double.toBigDecimal(mathContext: java.math.MathContext): java.math.BigDecimal

// JVM method = toBigDecimal(F)Ljava/math/BigDecimal;
inline fun Float.toBigDecimal(): java.math.BigDecimal

// JVM method = toBigDecimal(FLjava/math/MathContext;)Ljava/math/BigDecimal;
inline fun Float.toBigDecimal(mathContext: java.math.MathContext): java.math.BigDecimal

// JVM method = toBigDecimal(I)Ljava/math/BigDecimal;
inline fun Int.toBigDecimal(): java.math.BigDecimal

// JVM method = toBigDecimal(ILjava/math/MathContext;)Ljava/math/BigDecimal;
inline fun Int.toBigDecimal(mathContext: java.math.MathContext): java.math.BigDecimal

// JVM method = toBigDecimal(J)Ljava/math/BigDecimal;
inline fun Long.toBigDecimal(): java.math.BigDecimal

// JVM method = toBigDecimal(JLjava/math/MathContext;)Ljava/math/BigDecimal;
inline fun Long.toBigDecimal(mathContext: java.math.MathContext): java.math.BigDecimal

// JVM method = unaryMinus(Ljava/math/BigDecimal;)Ljava/math/BigDecimal;
inline operator fun java.math.BigDecimal.unaryMinus(): java.math.BigDecimal

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.NumbersKt


// *** FUNCTIONS ***

// JVM method = and(Ljava/math/BigInteger;Ljava/math/BigInteger;)Ljava/math/BigInteger;
inline infix fun java.math.BigInteger.and(other: java.math.BigInteger): java.math.BigInteger

// JVM method = dec(Ljava/math/BigInteger;)Ljava/math/BigInteger;
inline operator fun java.math.BigInteger.dec(): java.math.BigInteger

// JVM method = div(Ljava/math/BigInteger;Ljava/math/BigInteger;)Ljava/math/BigInteger;
inline operator fun java.math.BigInteger.div(other: java.math.BigInteger): java.math.BigInteger

// JVM method = inc(Ljava/math/BigInteger;)Ljava/math/BigInteger;
inline operator fun java.math.BigInteger.inc(): java.math.BigInteger

// JVM method = inv(Ljava/math/BigInteger;)Ljava/math/BigInteger;
inline fun java.math.BigInteger.inv(): java.math.BigInteger

// JVM method = minus(Ljava/math/BigInteger;Ljava/math/BigInteger;)Ljava/math/BigInteger;
inline operator fun java.math.BigInteger.minus(other: java.math.BigInteger): java.math.BigInteger

// JVM method = or(Ljava/math/BigInteger;Ljava/math/BigInteger;)Ljava/math/BigInteger;
inline infix fun java.math.BigInteger.or(other: java.math.BigInteger): java.math.BigInteger

// JVM method = plus(Ljava/math/BigInteger;Ljava/math/BigInteger;)Ljava/math/BigInteger;
inline operator fun java.math.BigInteger.plus(other: java.math.BigInteger): java.math.BigInteger

// JVM method = rem(Ljava/math/BigInteger;Ljava/math/BigInteger;)Ljava/math/BigInteger;
inline operator fun java.math.BigInteger.rem(other: java.math.BigInteger): java.math.BigInteger

// JVM method = shl(Ljava/math/BigInteger;I)Ljava/math/BigInteger;
inline infix fun java.math.BigInteger.shl(n: Int): java.math.BigInteger

// JVM method = shr(Ljava/math/BigInteger;I)Ljava/math/BigInteger;
inline infix fun java.math.BigInteger.shr(n: Int): java.math.BigInteger

// JVM method = times(Ljava/math/BigInteger;Ljava/math/BigInteger;)Ljava/math/BigInteger;
inline operator fun java.math.BigInteger.times(other: java.math.BigInteger): java.math.BigInteger

// JVM method = toBigDecimal(Ljava/math/BigInteger;)Ljava/math/BigDecimal;
inline fun java.math.BigInteger.toBigDecimal(): java.math.BigDecimal

// JVM method = toBigDecimal(Ljava/math/BigInteger;ILjava/math/MathContext;)Ljava/math/BigDecimal;
inline fun java.math.BigInteger.toBigDecimal(scale: Int /* = default */, mathContext: java.math.MathContext /* = default */): java.math.BigDecimal

// JVM method = toBigInteger(I)Ljava/math/BigInteger;
inline fun Int.toBigInteger(): java.math.BigInteger

// JVM method = toBigInteger(J)Ljava/math/BigInteger;
inline fun Long.toBigInteger(): java.math.BigInteger

// JVM method = unaryMinus(Ljava/math/BigInteger;)Ljava/math/BigInteger;
inline operator fun java.math.BigInteger.unaryMinus(): java.math.BigInteger

// JVM method = xor(Ljava/math/BigInteger;Ljava/math/BigInteger;)Ljava/math/BigInteger;
inline infix fun java.math.BigInteger.xor(other: java.math.BigInteger): java.math.BigInteger

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.NumbersKt


// *** FUNCTIONS ***

// JVM method = floorDiv(BB)I
inline fun Byte.floorDiv(other: Byte): Int

// JVM method = floorDiv(BI)I
inline fun Byte.floorDiv(other: Int): Int

// JVM method = floorDiv(BJ)J
inline fun Byte.floorDiv(other: Long): Long

// JVM method = floorDiv(BS)I
inline fun Byte.floorDiv(other: Short): Int

// JVM method = floorDiv(IB)I
inline fun Int.floorDiv(other: Byte): Int

// JVM method = floorDiv(II)I
inline fun Int.floorDiv(other: Int): Int

// JVM method = floorDiv(IJ)J
inline fun Int.floorDiv(other: Long): Long

// JVM method = floorDiv(IS)I
inline fun Int.floorDiv(other: Short): Int

// JVM method = floorDiv(JB)J
inline fun Long.floorDiv(other: Byte): Long

// JVM method = floorDiv(JI)J
inline fun Long.floorDiv(other: Int): Long

// JVM method = floorDiv(JJ)J
inline fun Long.floorDiv(other: Long): Long

// JVM method = floorDiv(JS)J
inline fun Long.floorDiv(other: Short): Long

// JVM method = floorDiv(SB)I
inline fun Short.floorDiv(other: Byte): Int

// JVM method = floorDiv(SI)I
inline fun Short.floorDiv(other: Int): Int

// JVM method = floorDiv(SJ)J
inline fun Short.floorDiv(other: Long): Long

// JVM method = floorDiv(SS)I
inline fun Short.floorDiv(other: Short): Int

// JVM method = mod(BB)B
inline fun Byte.mod(other: Byte): Byte

// JVM method = mod(BI)I
inline fun Byte.mod(other: Int): Int

// JVM method = mod(BJ)J
inline fun Byte.mod(other: Long): Long

// JVM method = mod(BS)S
inline fun Byte.mod(other: Short): Short

// JVM method = mod(DD)D
inline fun Double.mod(other: Double): Double

// JVM method = mod(DF)D
inline fun Double.mod(other: Float): Double

// JVM method = mod(FD)D
inline fun Float.mod(other: Double): Double

// JVM method = mod(FF)F
inline fun Float.mod(other: Float): Float

// JVM method = mod(IB)B
inline fun Int.mod(other: Byte): Byte

// JVM method = mod(II)I
inline fun Int.mod(other: Int): Int

// JVM method = mod(IJ)J
inline fun Int.mod(other: Long): Long

// JVM method = mod(IS)S
inline fun Int.mod(other: Short): Short

// JVM method = mod(JB)B
inline fun Long.mod(other: Byte): Byte

// JVM method = mod(JI)I
inline fun Long.mod(other: Int): Int

// JVM method = mod(JJ)J
inline fun Long.mod(other: Long): Long

// JVM method = mod(JS)S
inline fun Long.mod(other: Short): Short

// JVM method = mod(SB)B
inline fun Short.mod(other: Byte): Byte

// JVM method = mod(SI)I
inline fun Short.mod(other: Int): Int

// JVM method = mod(SJ)J
inline fun Short.mod(other: Long): Long

// JVM method = mod(SS)S
inline fun Short.mod(other: Short): Short

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.NumbersKt


// *** FUNCTIONS ***

// JVM method = countLeadingZeroBits(I)I
inline fun Int.countLeadingZeroBits(): Int

// JVM method = countLeadingZeroBits(J)I
inline fun Long.countLeadingZeroBits(): Int

// JVM method = countOneBits(I)I
inline fun Int.countOneBits(): Int

// JVM method = countOneBits(J)I
inline fun Long.countOneBits(): Int

// JVM method = countTrailingZeroBits(I)I
inline fun Int.countTrailingZeroBits(): Int

// JVM method = countTrailingZeroBits(J)I
inline fun Long.countTrailingZeroBits(): Int

// JVM method = fromBits(Lkotlin/jvm/internal/DoubleCompanionObject;J)D
inline fun Double.Companion.fromBits(bits: Long): Double

// JVM method = fromBits(Lkotlin/jvm/internal/FloatCompanionObject;I)F
inline fun Float.Companion.fromBits(bits: Int): Float

// JVM method = isFinite(D)Z
inline fun Double.isFinite(): Boolean

// JVM method = isFinite(F)Z
inline fun Float.isFinite(): Boolean

// JVM method = isInfinite(D)Z
inline fun Double.isInfinite(): Boolean

// JVM method = isInfinite(F)Z
inline fun Float.isInfinite(): Boolean

// JVM method = isNaN(D)Z
inline fun Double.isNaN(): Boolean

// JVM method = isNaN(F)Z
inline fun Float.isNaN(): Boolean

// JVM method = rotateLeft(II)I
inline fun Int.rotateLeft(bitCount: Int): Int

// JVM method = rotateLeft(JI)J
inline fun Long.rotateLeft(bitCount: Int): Long

// JVM method = rotateRight(II)I
inline fun Int.rotateRight(bitCount: Int): Int

// JVM method = rotateRight(JI)J
inline fun Long.rotateRight(bitCount: Int): Long

// JVM method = takeHighestOneBit(I)I
inline fun Int.takeHighestOneBit(): Int

// JVM method = takeHighestOneBit(J)J
inline fun Long.takeHighestOneBit(): Long

// JVM method = takeLowestOneBit(I)I
inline fun Int.takeLowestOneBit(): Int

// JVM method = takeLowestOneBit(J)J
inline fun Long.takeLowestOneBit(): Long

// JVM method = toBits(D)J
inline fun Double.toBits(): Long

// JVM method = toBits(F)I
inline fun Float.toBits(): Int

// JVM method = toRawBits(D)J
inline fun Double.toRawBits(): Long

// JVM method = toRawBits(F)I
inline fun Float.toRawBits(): Int

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.NumbersKt


// *** FUNCTIONS ***

// JVM method = countLeadingZeroBits(B)I
inline fun Byte.countLeadingZeroBits(): Int

// JVM method = countLeadingZeroBits(S)I
inline fun Short.countLeadingZeroBits(): Int

// JVM method = countOneBits(B)I
inline fun Byte.countOneBits(): Int

// JVM method = countOneBits(S)I
inline fun Short.countOneBits(): Int

// JVM method = countTrailingZeroBits(B)I
inline fun Byte.countTrailingZeroBits(): Int

// JVM method = countTrailingZeroBits(S)I
inline fun Short.countTrailingZeroBits(): Int

// JVM method = rotateLeft(BI)B
fun Byte.rotateLeft(bitCount: Int): Byte

// JVM method = rotateLeft(SI)S
fun Short.rotateLeft(bitCount: Int): Short

// JVM method = rotateRight(BI)B
fun Byte.rotateRight(bitCount: Int): Byte

// JVM method = rotateRight(SI)S
fun Short.rotateRight(bitCount: Int): Short

// JVM method = takeHighestOneBit(B)B
inline fun Byte.takeHighestOneBit(): Byte

// JVM method = takeHighestOneBit(S)S
inline fun Short.takeHighestOneBit(): Short

// JVM method = takeLowestOneBit(B)B
inline fun Byte.takeLowestOneBit(): Byte

// JVM method = takeLowestOneBit(S)S
inline fun Short.takeLowestOneBit(): Short

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.PreconditionsKt


// *** FUNCTIONS ***

// JVM method = assert(Z)V
inline fun assert(value: Boolean)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = assert(ZLkotlin/jvm/functions/Function0;)V
inline fun assert(value: Boolean, lazyMessage: () -> Any)

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.PreconditionsKt


// *** FUNCTIONS ***

// JVM method = check(Z)V
inline fun check(value: Boolean) {
	contract {
		returns() implies (value)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = check(ZLkotlin/jvm/functions/Function0;)V
inline fun check(value: Boolean, lazyMessage: () -> Any) {
	contract {
		returns() implies (value)
	}
}

// JVM method = checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;
inline fun <T : Any> checkNotNull(value: T : Any?): T : Any {
	contract {
		returns() implies (value != null)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = checkNotNull(Ljava/lang/Object;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <T : Any> checkNotNull(value: T : Any?, lazyMessage: () -> Any): T : Any {
	contract {
		returns() implies (value != null)
	}
}

// JVM method = error(Ljava/lang/Object;)Ljava/lang/Void;
inline fun error(message: Any): Nothing

// JVM method = require(Z)V
inline fun require(value: Boolean) {
	contract {
		returns() implies (value)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = require(ZLkotlin/jvm/functions/Function0;)V
inline fun require(value: Boolean, lazyMessage: () -> Any) {
	contract {
		returns() implies (value)
	}
}

// JVM method = requireNotNull(Ljava/lang/Object;)Ljava/lang/Object;
inline fun <T : Any> requireNotNull(value: T : Any?): T : Any {
	contract {
		returns() implies (value != null)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = requireNotNull(Ljava/lang/Object;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <T : Any> requireNotNull(value: T : Any?, lazyMessage: () -> Any): T : Any {
	contract {
		returns() implies (value != null)
	}
}

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.StandardKt


// *** FUNCTIONS ***

// JVM method = TODO()Ljava/lang/Void;
inline fun TODO(): Nothing

// JVM method = TODO(Ljava/lang/String;)Ljava/lang/Void;
inline fun TODO(reason: String): Nothing

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = repeat(ILkotlin/jvm/functions/Function1;)V
inline fun repeat(times: Int, action: (Int) -> Unit) {
	contract {
		callsInPlace(action, InvocationKind.UNKNOWN)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = run(Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <R> run(block: () -> R): R {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = with(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> with(receiver: T, block: T.() -> R): R {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = also(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> T.also(block: (T) -> Unit): T {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = apply(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> T.apply(block: T.() -> Unit): T {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = let(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> T.let(block: (T) -> R): R {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = run(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> T.run(block: T.() -> R): R {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeIf(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {
	contract {
		callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeUnless(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {
	contract {
		callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)
	}
}

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.StandardKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = synchronized(Ljava/lang/Object;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <R> synchronized(lock: Any, block: () -> R): R {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.ArraysKt


// *** FUNCTIONS ***

// JVM method = arrayOfNulls([Ljava/lang/Object;I)[Ljava/lang/Object;
internal fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T>

// JVM method = copyOfRangeToIndexCheck(II)V
internal fun copyOfRangeToIndexCheck(toIndex: Int, size: Int)

// JVM method = contentDeepHashCode([Ljava/lang/Object;)I
internal fun <T> Array<out T>?.contentDeepHashCodeImpl(): Int

// JVM method = orEmpty([Ljava/lang/Object;)[Ljava/lang/Object;
inline fun <reified T> Array<out reified T>?.orEmpty(): Array<out reified T>

// JVM method = toString([BLjava/nio/charset/Charset;)Ljava/lang/String;
inline fun ByteArray.toString(charset: java.nio.charset.Charset): String

// JVM method = toTypedArray(Ljava/util/Collection;)[Ljava/lang/Object;
inline fun <reified T> Collection<reified T>.toTypedArray(): Array<reified T>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.ArraysKt


// *** FUNCTIONS ***

// JVM method = contentDeepEquals([Ljava/lang/Object;[Ljava/lang/Object;)Z
internal fun <T> Array<out T>?.contentDeepEqualsImpl(other: Array<out T>?): Boolean

// JVM method = contentDeepToString([Ljava/lang/Object;)Ljava/lang/String;
internal fun <T> Array<out T>?.contentDeepToStringImpl(): String

// JVM method = contentDeepToStringInternal$ArraysKt__ArraysKt([Ljava/lang/Object;Ljava/lang/StringBuilder;Ljava/util/List;)V
private fun <T> Array<out T>.contentDeepToStringInternal(result: StringBuilder /* = java.lang.StringBuilder */, processed: MutableList<Array<*>>)

// JVM method = flatten([[Ljava/lang/Object;)Ljava/util/List;
fun <T> Array<out Array<out T>>.flatten(): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = ifEmpty([Ljava/lang/Object;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where
	C : Array<*>,
	C : R

// JVM method = isNullOrEmpty([Ljava/lang/Object;)Z
inline fun Array<*>?.isNullOrEmpty(): Boolean {
	contract {
		returns(false) implies (this@isNullOrEmpty != null)
	}
}

// JVM method = unzip([Lkotlin/Pair;)Lkotlin/Pair;
fun <T, R> Array<out Pair<T, R>>.unzip(): Pair<List<T>, List<R>>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.ArraysKt


// *** FUNCTIONS ***

// JVM method = asList([Ljava/lang/Object;)Ljava/util/List;
fun <T> Array<out T>.asList(): List<T>

// JVM method = asList([Z)Ljava/util/List;
fun BooleanArray.asList(): List<Boolean>

// JVM method = asList([B)Ljava/util/List;
fun ByteArray.asList(): List<Byte>

// JVM method = asList([C)Ljava/util/List;
fun CharArray.asList(): List<Char>

// JVM method = asList([D)Ljava/util/List;
fun DoubleArray.asList(): List<Double>

// JVM method = asList([F)Ljava/util/List;
fun FloatArray.asList(): List<Float>

// JVM method = asList([I)Ljava/util/List;
fun IntArray.asList(): List<Int>

// JVM method = asList([J)Ljava/util/List;
fun LongArray.asList(): List<Long>

// JVM method = asList([S)Ljava/util/List;
fun ShortArray.asList(): List<Short>

// JVM method = binarySearch([Ljava/lang/Object;Ljava/lang/Object;Ljava/util/Comparator;II)I
fun <T> Array<out T>.binarySearch(element: T, comparator: Comparator<in T> /* = java.util.Comparator<in T> */, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// JVM method = binarySearch([Ljava/lang/Object;Ljava/lang/Object;II)I
fun <T> Array<out T>.binarySearch(element: T, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// JVM method = binarySearch([BBII)I
fun ByteArray.binarySearch(element: Byte, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// JVM method = binarySearch([CCII)I
fun CharArray.binarySearch(element: Char, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// JVM method = binarySearch([DDII)I
fun DoubleArray.binarySearch(element: Double, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// JVM method = binarySearch([FFII)I
fun FloatArray.binarySearch(element: Float, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// JVM method = binarySearch([IIII)I
fun IntArray.binarySearch(element: Int, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// JVM method = binarySearch([JJII)I
fun LongArray.binarySearch(element: Long, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// JVM method = binarySearch([SSII)I
fun ShortArray.binarySearch(element: Short, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// JVM method = contentDeepEqualsInline([Ljava/lang/Object;[Ljava/lang/Object;)Z
inline infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean

// JVM method = contentDeepEqualsNullable([Ljava/lang/Object;[Ljava/lang/Object;)Z
inline infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean

// JVM method = contentDeepHashCodeInline([Ljava/lang/Object;)I
inline fun <T> Array<out T>.contentDeepHashCode(): Int

// JVM method = contentDeepHashCodeNullable([Ljava/lang/Object;)I
inline fun <T> Array<out T>?.contentDeepHashCode(): Int

// JVM method = contentDeepToStringInline([Ljava/lang/Object;)Ljava/lang/String;
inline fun <T> Array<out T>.contentDeepToString(): String

// JVM method = contentDeepToStringNullable([Ljava/lang/Object;)Ljava/lang/String;
inline fun <T> Array<out T>?.contentDeepToString(): String

// JVM method = contentEquals([Ljava/lang/Object;[Ljava/lang/Object;)Z
inline infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean

// JVM method = contentEqualsNullable([Ljava/lang/Object;[Ljava/lang/Object;)Z
inline infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean

// JVM method = contentEquals([Z[Z)Z
inline infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean

// JVM method = contentEqualsNullable([Z[Z)Z
inline infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean

// JVM method = contentEquals([B[B)Z
inline infix fun ByteArray.contentEquals(other: ByteArray): Boolean

// JVM method = contentEqualsNullable([B[B)Z
inline infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean

// JVM method = contentEquals([C[C)Z
inline infix fun CharArray.contentEquals(other: CharArray): Boolean

// JVM method = contentEqualsNullable([C[C)Z
inline infix fun CharArray?.contentEquals(other: CharArray?): Boolean

// JVM method = contentEquals([D[D)Z
inline infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean

// JVM method = contentEqualsNullable([D[D)Z
inline infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean

// JVM method = contentEquals([F[F)Z
inline infix fun FloatArray.contentEquals(other: FloatArray): Boolean

// JVM method = contentEqualsNullable([F[F)Z
inline infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean

// JVM method = contentEquals([I[I)Z
inline infix fun IntArray.contentEquals(other: IntArray): Boolean

// JVM method = contentEqualsNullable([I[I)Z
inline infix fun IntArray?.contentEquals(other: IntArray?): Boolean

// JVM method = contentEquals([J[J)Z
inline infix fun LongArray.contentEquals(other: LongArray): Boolean

// JVM method = contentEqualsNullable([J[J)Z
inline infix fun LongArray?.contentEquals(other: LongArray?): Boolean

// JVM method = contentEquals([S[S)Z
inline infix fun ShortArray.contentEquals(other: ShortArray): Boolean

// JVM method = contentEqualsNullable([S[S)Z
inline infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean

// JVM method = contentHashCode([Ljava/lang/Object;)I
inline fun <T> Array<out T>.contentHashCode(): Int

// JVM method = contentHashCodeNullable([Ljava/lang/Object;)I
inline fun <T> Array<out T>?.contentHashCode(): Int

// JVM method = contentHashCode([Z)I
inline fun BooleanArray.contentHashCode(): Int

// JVM method = contentHashCodeNullable([Z)I
inline fun BooleanArray?.contentHashCode(): Int

// JVM method = contentHashCode([B)I
inline fun ByteArray.contentHashCode(): Int

// JVM method = contentHashCodeNullable([B)I
inline fun ByteArray?.contentHashCode(): Int

// JVM method = contentHashCode([C)I
inline fun CharArray.contentHashCode(): Int

// JVM method = contentHashCodeNullable([C)I
inline fun CharArray?.contentHashCode(): Int

// JVM method = contentHashCode([D)I
inline fun DoubleArray.contentHashCode(): Int

// JVM method = contentHashCodeNullable([D)I
inline fun DoubleArray?.contentHashCode(): Int

// JVM method = contentHashCode([F)I
inline fun FloatArray.contentHashCode(): Int

// JVM method = contentHashCodeNullable([F)I
inline fun FloatArray?.contentHashCode(): Int

// JVM method = contentHashCode([I)I
inline fun IntArray.contentHashCode(): Int

// JVM method = contentHashCodeNullable([I)I
inline fun IntArray?.contentHashCode(): Int

// JVM method = contentHashCode([J)I
inline fun LongArray.contentHashCode(): Int

// JVM method = contentHashCodeNullable([J)I
inline fun LongArray?.contentHashCode(): Int

// JVM method = contentHashCode([S)I
inline fun ShortArray.contentHashCode(): Int

// JVM method = contentHashCodeNullable([S)I
inline fun ShortArray?.contentHashCode(): Int

// JVM method = contentToString([Ljava/lang/Object;)Ljava/lang/String;
inline fun <T> Array<out T>.contentToString(): String

// JVM method = contentToStringNullable([Ljava/lang/Object;)Ljava/lang/String;
inline fun <T> Array<out T>?.contentToString(): String

// JVM method = contentToString([Z)Ljava/lang/String;
inline fun BooleanArray.contentToString(): String

// JVM method = contentToStringNullable([Z)Ljava/lang/String;
inline fun BooleanArray?.contentToString(): String

// JVM method = contentToString([B)Ljava/lang/String;
inline fun ByteArray.contentToString(): String

// JVM method = contentToStringNullable([B)Ljava/lang/String;
inline fun ByteArray?.contentToString(): String

// JVM method = contentToString([C)Ljava/lang/String;
inline fun CharArray.contentToString(): String

// JVM method = contentToStringNullable([C)Ljava/lang/String;
inline fun CharArray?.contentToString(): String

// JVM method = contentToString([D)Ljava/lang/String;
inline fun DoubleArray.contentToString(): String

// JVM method = contentToStringNullable([D)Ljava/lang/String;
inline fun DoubleArray?.contentToString(): String

// JVM method = contentToString([F)Ljava/lang/String;
inline fun FloatArray.contentToString(): String

// JVM method = contentToStringNullable([F)Ljava/lang/String;
inline fun FloatArray?.contentToString(): String

// JVM method = contentToString([I)Ljava/lang/String;
inline fun IntArray.contentToString(): String

// JVM method = contentToStringNullable([I)Ljava/lang/String;
inline fun IntArray?.contentToString(): String

// JVM method = contentToString([J)Ljava/lang/String;
inline fun LongArray.contentToString(): String

// JVM method = contentToStringNullable([J)Ljava/lang/String;
inline fun LongArray?.contentToString(): String

// JVM method = contentToString([S)Ljava/lang/String;
inline fun ShortArray.contentToString(): String

// JVM method = contentToStringNullable([S)Ljava/lang/String;
inline fun ShortArray?.contentToString(): String

// JVM method = copyInto([Ljava/lang/Object;[Ljava/lang/Object;III)[Ljava/lang/Object;
fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): Array<T>

// JVM method = copyInto([Z[ZIII)[Z
fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): BooleanArray

// JVM method = copyInto([B[BIII)[B
fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): ByteArray

// JVM method = copyInto([C[CIII)[C
fun CharArray.copyInto(destination: CharArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): CharArray

// JVM method = copyInto([D[DIII)[D
fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): DoubleArray

// JVM method = copyInto([F[FIII)[F
fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): FloatArray

// JVM method = copyInto([I[IIII)[I
fun IntArray.copyInto(destination: IntArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): IntArray

// JVM method = copyInto([J[JIII)[J
fun LongArray.copyInto(destination: LongArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): LongArray

// JVM method = copyInto([S[SIII)[S
fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): ShortArray

// JVM method = copyOf([Ljava/lang/Object;)[Ljava/lang/Object;
inline fun <T> Array<T>.copyOf(): Array<T>

// JVM method = copyOf([Ljava/lang/Object;I)[Ljava/lang/Object;
inline fun <T> Array<T>.copyOf(newSize: Int): Array<T?>

// JVM method = copyOf([Z)[Z
inline fun BooleanArray.copyOf(): BooleanArray

// JVM method = copyOf([ZI)[Z
inline fun BooleanArray.copyOf(newSize: Int): BooleanArray

// JVM method = copyOf([B)[B
inline fun ByteArray.copyOf(): ByteArray

// JVM method = copyOf([BI)[B
inline fun ByteArray.copyOf(newSize: Int): ByteArray

// JVM method = copyOf([C)[C
inline fun CharArray.copyOf(): CharArray

// JVM method = copyOf([CI)[C
inline fun CharArray.copyOf(newSize: Int): CharArray

// JVM method = copyOf([D)[D
inline fun DoubleArray.copyOf(): DoubleArray

// JVM method = copyOf([DI)[D
inline fun DoubleArray.copyOf(newSize: Int): DoubleArray

// JVM method = copyOf([F)[F
inline fun FloatArray.copyOf(): FloatArray

// JVM method = copyOf([FI)[F
inline fun FloatArray.copyOf(newSize: Int): FloatArray

// JVM method = copyOf([I)[I
inline fun IntArray.copyOf(): IntArray

// JVM method = copyOf([II)[I
inline fun IntArray.copyOf(newSize: Int): IntArray

// JVM method = copyOf([J)[J
inline fun LongArray.copyOf(): LongArray

// JVM method = copyOf([JI)[J
inline fun LongArray.copyOf(newSize: Int): LongArray

// JVM method = copyOf([S)[S
inline fun ShortArray.copyOf(): ShortArray

// JVM method = copyOf([SI)[S
inline fun ShortArray.copyOf(newSize: Int): ShortArray

// JVM method = copyOfRangeInline([Ljava/lang/Object;II)[Ljava/lang/Object;
inline fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>

// JVM method = copyOfRangeInline([ZII)[Z
inline fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray

// JVM method = copyOfRangeInline([BII)[B
inline fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray

// JVM method = copyOfRangeInline([CII)[C
inline fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray

// JVM method = copyOfRangeInline([DII)[D
inline fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray

// JVM method = copyOfRangeInline([FII)[F
inline fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray

// JVM method = copyOfRangeInline([III)[I
inline fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray

// JVM method = copyOfRangeInline([JII)[J
inline fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray

// JVM method = copyOfRangeInline([SII)[S
inline fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray

// JVM method = copyOfRange([Ljava/lang/Object;II)[Ljava/lang/Object;
internal fun <T> Array<T>.copyOfRangeImpl(fromIndex: Int, toIndex: Int): Array<T>

// JVM method = copyOfRange([ZII)[Z
internal fun BooleanArray.copyOfRangeImpl(fromIndex: Int, toIndex: Int): BooleanArray

// JVM method = copyOfRange([BII)[B
internal fun ByteArray.copyOfRangeImpl(fromIndex: Int, toIndex: Int): ByteArray

// JVM method = copyOfRange([CII)[C
internal fun CharArray.copyOfRangeImpl(fromIndex: Int, toIndex: Int): CharArray

// JVM method = copyOfRange([DII)[D
internal fun DoubleArray.copyOfRangeImpl(fromIndex: Int, toIndex: Int): DoubleArray

// JVM method = copyOfRange([FII)[F
internal fun FloatArray.copyOfRangeImpl(fromIndex: Int, toIndex: Int): FloatArray

// JVM method = copyOfRange([III)[I
internal fun IntArray.copyOfRangeImpl(fromIndex: Int, toIndex: Int): IntArray

// JVM method = copyOfRange([JII)[J
internal fun LongArray.copyOfRangeImpl(fromIndex: Int, toIndex: Int): LongArray

// JVM method = copyOfRange([SII)[S
internal fun ShortArray.copyOfRangeImpl(fromIndex: Int, toIndex: Int): ShortArray

// JVM method = elementAt([Ljava/lang/Object;I)Ljava/lang/Object;
inline fun <T> Array<out T>.elementAt(index: Int): T

// JVM method = elementAt([ZI)Z
inline fun BooleanArray.elementAt(index: Int): Boolean

// JVM method = elementAt([BI)B
inline fun ByteArray.elementAt(index: Int): Byte

// JVM method = elementAt([CI)C
inline fun CharArray.elementAt(index: Int): Char

// JVM method = elementAt([DI)D
inline fun DoubleArray.elementAt(index: Int): Double

// JVM method = elementAt([FI)F
inline fun FloatArray.elementAt(index: Int): Float

// JVM method = elementAt([II)I
inline fun IntArray.elementAt(index: Int): Int

// JVM method = elementAt([JI)J
inline fun LongArray.elementAt(index: Int): Long

// JVM method = elementAt([SI)S
inline fun ShortArray.elementAt(index: Int): Short

// JVM method = fill([Ljava/lang/Object;Ljava/lang/Object;II)V
fun <T> Array<T>.fill(element: T, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = fill([ZZII)V
fun BooleanArray.fill(element: Boolean, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = fill([BBII)V
fun ByteArray.fill(element: Byte, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = fill([CCII)V
fun CharArray.fill(element: Char, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = fill([DDII)V
fun DoubleArray.fill(element: Double, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = fill([FFII)V
fun FloatArray.fill(element: Float, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = fill([IIII)V
fun IntArray.fill(element: Int, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = fill([JJII)V
fun LongArray.fill(element: Long, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = fill([SSII)V
fun ShortArray.fill(element: Short, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = filterIsInstance([Ljava/lang/Object;Ljava/lang/Class;)Ljava/util/List;
fun <R> Array<*>.filterIsInstance(klass: java.lang.Class<R>): List<R>

// JVM method = filterIsInstanceTo([Ljava/lang/Object;Ljava/util/Collection;Ljava/lang/Class;)Ljava/util/Collection;
fun <C : MutableCollection<in R>, R> Array<*>.filterIsInstanceTo(destination: C : MutableCollection<in R>, klass: java.lang.Class<R>): C : MutableCollection<in R>

// JVM method = max([Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Array<out T : Comparable<T>>.max(): T : Comparable<T>?

// JVM method = max([Ljava/lang/Double;)Ljava/lang/Double;
fun Array<out Double>.max(): Double?

// JVM method = max([Ljava/lang/Float;)Ljava/lang/Float;
fun Array<out Float>.max(): Float?

// JVM method = max([B)Ljava/lang/Byte;
fun ByteArray.max(): Byte?

// JVM method = max([C)Ljava/lang/Character;
fun CharArray.max(): Char?

// JVM method = max([D)Ljava/lang/Double;
fun DoubleArray.max(): Double?

// JVM method = max([F)Ljava/lang/Float;
fun FloatArray.max(): Float?

// JVM method = max([I)Ljava/lang/Integer;
fun IntArray.max(): Int?

// JVM method = max([J)Ljava/lang/Long;
fun LongArray.max(): Long?

// JVM method = max([S)Ljava/lang/Short;
fun ShortArray.max(): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R : Comparable<R>): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Boolean;
inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R : Comparable<R>): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy([BLkotlin/jvm/functions/Function1;)Ljava/lang/Byte;
inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R : Comparable<R>): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy([CLkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R : Comparable<R>): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy([DLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R : Comparable<R>): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy([FLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R : Comparable<R>): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy([ILkotlin/jvm/functions/Function1;)Ljava/lang/Integer;
inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R : Comparable<R>): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy([JLkotlin/jvm/functions/Function1;)Ljava/lang/Long;
inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R : Comparable<R>): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy([SLkotlin/jvm/functions/Function1;)Ljava/lang/Short;
inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R : Comparable<R>): Short?

// JVM method = maxWith([Ljava/lang/Object;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Array<out T>.maxWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T?

// JVM method = maxWith([ZLjava/util/Comparator;)Ljava/lang/Boolean;
fun BooleanArray.maxWith(comparator: Comparator<in Boolean> /* = java.util.Comparator<in Boolean> */): Boolean?

// JVM method = maxWith([BLjava/util/Comparator;)Ljava/lang/Byte;
fun ByteArray.maxWith(comparator: Comparator<in Byte> /* = java.util.Comparator<in Byte> */): Byte?

// JVM method = maxWith([CLjava/util/Comparator;)Ljava/lang/Character;
fun CharArray.maxWith(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): Char?

// JVM method = maxWith([DLjava/util/Comparator;)Ljava/lang/Double;
fun DoubleArray.maxWith(comparator: Comparator<in Double> /* = java.util.Comparator<in Double> */): Double?

// JVM method = maxWith([FLjava/util/Comparator;)Ljava/lang/Float;
fun FloatArray.maxWith(comparator: Comparator<in Float> /* = java.util.Comparator<in Float> */): Float?

// JVM method = maxWith([ILjava/util/Comparator;)Ljava/lang/Integer;
fun IntArray.maxWith(comparator: Comparator<in Int> /* = java.util.Comparator<in Int> */): Int?

// JVM method = maxWith([JLjava/util/Comparator;)Ljava/lang/Long;
fun LongArray.maxWith(comparator: Comparator<in Long> /* = java.util.Comparator<in Long> */): Long?

// JVM method = maxWith([SLjava/util/Comparator;)Ljava/lang/Short;
fun ShortArray.maxWith(comparator: Comparator<in Short> /* = java.util.Comparator<in Short> */): Short?

// JVM method = min([Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Array<out T : Comparable<T>>.min(): T : Comparable<T>?

// JVM method = min([Ljava/lang/Double;)Ljava/lang/Double;
fun Array<out Double>.min(): Double?

// JVM method = min([Ljava/lang/Float;)Ljava/lang/Float;
fun Array<out Float>.min(): Float?

// JVM method = min([B)Ljava/lang/Byte;
fun ByteArray.min(): Byte?

// JVM method = min([C)Ljava/lang/Character;
fun CharArray.min(): Char?

// JVM method = min([D)Ljava/lang/Double;
fun DoubleArray.min(): Double?

// JVM method = min([F)Ljava/lang/Float;
fun FloatArray.min(): Float?

// JVM method = min([I)Ljava/lang/Integer;
fun IntArray.min(): Int?

// JVM method = min([J)Ljava/lang/Long;
fun LongArray.min(): Long?

// JVM method = min([S)Ljava/lang/Short;
fun ShortArray.min(): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R : Comparable<R>): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Boolean;
inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R : Comparable<R>): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy([BLkotlin/jvm/functions/Function1;)Ljava/lang/Byte;
inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R : Comparable<R>): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy([CLkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R : Comparable<R>): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy([DLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R : Comparable<R>): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy([FLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R : Comparable<R>): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy([ILkotlin/jvm/functions/Function1;)Ljava/lang/Integer;
inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R : Comparable<R>): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy([JLkotlin/jvm/functions/Function1;)Ljava/lang/Long;
inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R : Comparable<R>): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy([SLkotlin/jvm/functions/Function1;)Ljava/lang/Short;
inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R : Comparable<R>): Short?

// JVM method = minWith([Ljava/lang/Object;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Array<out T>.minWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T?

// JVM method = minWith([ZLjava/util/Comparator;)Ljava/lang/Boolean;
fun BooleanArray.minWith(comparator: Comparator<in Boolean> /* = java.util.Comparator<in Boolean> */): Boolean?

// JVM method = minWith([BLjava/util/Comparator;)Ljava/lang/Byte;
fun ByteArray.minWith(comparator: Comparator<in Byte> /* = java.util.Comparator<in Byte> */): Byte?

// JVM method = minWith([CLjava/util/Comparator;)Ljava/lang/Character;
fun CharArray.minWith(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): Char?

// JVM method = minWith([DLjava/util/Comparator;)Ljava/lang/Double;
fun DoubleArray.minWith(comparator: Comparator<in Double> /* = java.util.Comparator<in Double> */): Double?

// JVM method = minWith([FLjava/util/Comparator;)Ljava/lang/Float;
fun FloatArray.minWith(comparator: Comparator<in Float> /* = java.util.Comparator<in Float> */): Float?

// JVM method = minWith([ILjava/util/Comparator;)Ljava/lang/Integer;
fun IntArray.minWith(comparator: Comparator<in Int> /* = java.util.Comparator<in Int> */): Int?

// JVM method = minWith([JLjava/util/Comparator;)Ljava/lang/Long;
fun LongArray.minWith(comparator: Comparator<in Long> /* = java.util.Comparator<in Long> */): Long?

// JVM method = minWith([SLjava/util/Comparator;)Ljava/lang/Short;
fun ShortArray.minWith(comparator: Comparator<in Short> /* = java.util.Comparator<in Short> */): Short?

// JVM method = plus([Ljava/lang/Object;Ljava/lang/Object;)[Ljava/lang/Object;
operator fun <T> Array<T>.plus(element: T): Array<T>

// JVM method = plus([Ljava/lang/Object;[Ljava/lang/Object;)[Ljava/lang/Object;
operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>

// JVM method = plus([Ljava/lang/Object;Ljava/util/Collection;)[Ljava/lang/Object;
operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>

// JVM method = plus([ZZ)[Z
operator fun BooleanArray.plus(element: Boolean): BooleanArray

// JVM method = plus([Z[Z)[Z
operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray

// JVM method = plus([ZLjava/util/Collection;)[Z
operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray

// JVM method = plus([BB)[B
operator fun ByteArray.plus(element: Byte): ByteArray

// JVM method = plus([B[B)[B
operator fun ByteArray.plus(elements: ByteArray): ByteArray

// JVM method = plus([BLjava/util/Collection;)[B
operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray

// JVM method = plus([CC)[C
operator fun CharArray.plus(element: Char): CharArray

// JVM method = plus([C[C)[C
operator fun CharArray.plus(elements: CharArray): CharArray

// JVM method = plus([CLjava/util/Collection;)[C
operator fun CharArray.plus(elements: Collection<Char>): CharArray

// JVM method = plus([DD)[D
operator fun DoubleArray.plus(element: Double): DoubleArray

// JVM method = plus([D[D)[D
operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray

// JVM method = plus([DLjava/util/Collection;)[D
operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray

// JVM method = plus([FF)[F
operator fun FloatArray.plus(element: Float): FloatArray

// JVM method = plus([F[F)[F
operator fun FloatArray.plus(elements: FloatArray): FloatArray

// JVM method = plus([FLjava/util/Collection;)[F
operator fun FloatArray.plus(elements: Collection<Float>): FloatArray

// JVM method = plus([II)[I
operator fun IntArray.plus(element: Int): IntArray

// JVM method = plus([I[I)[I
operator fun IntArray.plus(elements: IntArray): IntArray

// JVM method = plus([ILjava/util/Collection;)[I
operator fun IntArray.plus(elements: Collection<Int>): IntArray

// JVM method = plus([JJ)[J
operator fun LongArray.plus(element: Long): LongArray

// JVM method = plus([J[J)[J
operator fun LongArray.plus(elements: LongArray): LongArray

// JVM method = plus([JLjava/util/Collection;)[J
operator fun LongArray.plus(elements: Collection<Long>): LongArray

// JVM method = plus([SS)[S
operator fun ShortArray.plus(element: Short): ShortArray

// JVM method = plus([S[S)[S
operator fun ShortArray.plus(elements: ShortArray): ShortArray

// JVM method = plus([SLjava/util/Collection;)[S
operator fun ShortArray.plus(elements: Collection<Short>): ShortArray

// JVM method = plusElement([Ljava/lang/Object;Ljava/lang/Object;)[Ljava/lang/Object;
inline fun <T> Array<T>.plusElement(element: T): Array<T>

// JVM method = sort([Ljava/lang/Object;)V
fun <T> Array<out T>.sort()

// JVM method = sort([Ljava/lang/Comparable;)V
inline fun <T : Comparable<T>> Array<out T : Comparable<T>>.sort()

// JVM method = sort([Ljava/lang/Object;II)V
fun <T> Array<out T>.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = sort([Ljava/lang/Comparable;II)V
fun <T : Comparable<T>> Array<out T : Comparable<T>>.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = sort([B)V
fun ByteArray.sort()

// JVM method = sort([BII)V
fun ByteArray.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = sort([C)V
fun CharArray.sort()

// JVM method = sort([CII)V
fun CharArray.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = sort([D)V
fun DoubleArray.sort()

// JVM method = sort([DII)V
fun DoubleArray.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = sort([F)V
fun FloatArray.sort()

// JVM method = sort([FII)V
fun FloatArray.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = sort([I)V
fun IntArray.sort()

// JVM method = sort([III)V
fun IntArray.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = sort([J)V
fun LongArray.sort()

// JVM method = sort([JII)V
fun LongArray.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = sort([S)V
fun ShortArray.sort()

// JVM method = sort([SII)V
fun ShortArray.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// JVM method = sortWith([Ljava/lang/Object;Ljava/util/Comparator;)V
fun <T> Array<out T>.sortWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */)

// JVM method = sortWith([Ljava/lang/Object;Ljava/util/Comparator;II)V
fun <T> Array<out T>.sortWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigDecimal([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun <T> Array<out T>.sumOf(selector: (T) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigInteger([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun <T> Array<out T>.sumOf(selector: (T) -> java.math.BigInteger): java.math.BigInteger

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigDecimal([ZLkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun BooleanArray.sumOf(selector: (Boolean) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigInteger([ZLkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun BooleanArray.sumOf(selector: (Boolean) -> java.math.BigInteger): java.math.BigInteger

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigDecimal([BLkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun ByteArray.sumOf(selector: (Byte) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigInteger([BLkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun ByteArray.sumOf(selector: (Byte) -> java.math.BigInteger): java.math.BigInteger

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigDecimal([CLkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun CharArray.sumOf(selector: (Char) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigInteger([CLkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun CharArray.sumOf(selector: (Char) -> java.math.BigInteger): java.math.BigInteger

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigDecimal([DLkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun DoubleArray.sumOf(selector: (Double) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigInteger([DLkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun DoubleArray.sumOf(selector: (Double) -> java.math.BigInteger): java.math.BigInteger

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigDecimal([FLkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun FloatArray.sumOf(selector: (Float) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigInteger([FLkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun FloatArray.sumOf(selector: (Float) -> java.math.BigInteger): java.math.BigInteger

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigDecimal([ILkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun IntArray.sumOf(selector: (Int) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigInteger([ILkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun IntArray.sumOf(selector: (Int) -> java.math.BigInteger): java.math.BigInteger

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigDecimal([JLkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun LongArray.sumOf(selector: (Long) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigInteger([JLkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun LongArray.sumOf(selector: (Long) -> java.math.BigInteger): java.math.BigInteger

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigDecimal([SLkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun ShortArray.sumOf(selector: (Short) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigInteger([SLkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun ShortArray.sumOf(selector: (Short) -> java.math.BigInteger): java.math.BigInteger

// JVM method = toSortedSet([Ljava/lang/Comparable;)Ljava/util/SortedSet;
fun <T : Comparable<T>> Array<out T : Comparable<T>>.toSortedSet(): java.util.SortedSet<T : Comparable<T>>

// JVM method = toSortedSet([Ljava/lang/Object;Ljava/util/Comparator;)Ljava/util/SortedSet;
fun <T> Array<out T>.toSortedSet(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): java.util.SortedSet<T>

// JVM method = toSortedSet([Z)Ljava/util/SortedSet;
fun BooleanArray.toSortedSet(): java.util.SortedSet<Boolean>

// JVM method = toSortedSet([B)Ljava/util/SortedSet;
fun ByteArray.toSortedSet(): java.util.SortedSet<Byte>

// JVM method = toSortedSet([C)Ljava/util/SortedSet;
fun CharArray.toSortedSet(): java.util.SortedSet<Char>

// JVM method = toSortedSet([D)Ljava/util/SortedSet;
fun DoubleArray.toSortedSet(): java.util.SortedSet<Double>

// JVM method = toSortedSet([F)Ljava/util/SortedSet;
fun FloatArray.toSortedSet(): java.util.SortedSet<Float>

// JVM method = toSortedSet([I)Ljava/util/SortedSet;
fun IntArray.toSortedSet(): java.util.SortedSet<Int>

// JVM method = toSortedSet([J)Ljava/util/SortedSet;
fun LongArray.toSortedSet(): java.util.SortedSet<Long>

// JVM method = toSortedSet([S)Ljava/util/SortedSet;
fun ShortArray.toSortedSet(): java.util.SortedSet<Short>

// JVM method = toTypedArray([Z)[Ljava/lang/Boolean;
fun BooleanArray.toTypedArray(): Array<Boolean>

// JVM method = toTypedArray([B)[Ljava/lang/Byte;
fun ByteArray.toTypedArray(): Array<Byte>

// JVM method = toTypedArray([C)[Ljava/lang/Character;
fun CharArray.toTypedArray(): Array<Char>

// JVM method = toTypedArray([D)[Ljava/lang/Double;
fun DoubleArray.toTypedArray(): Array<Double>

// JVM method = toTypedArray([F)[Ljava/lang/Float;
fun FloatArray.toTypedArray(): Array<Float>

// JVM method = toTypedArray([I)[Ljava/lang/Integer;
fun IntArray.toTypedArray(): Array<Int>

// JVM method = toTypedArray([J)[Ljava/lang/Long;
fun LongArray.toTypedArray(): Array<Long>

// JVM method = toTypedArray([S)[Ljava/lang/Short;
fun ShortArray.toTypedArray(): Array<Short>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.ArraysKt


// *** PROPERTIES ***

val <T> Array<out T>.indices: IntRange
	// JVM method = getIndices([Ljava/lang/Object;)Lkotlin/ranges/IntRange;
	get() = /* non-default */

val BooleanArray.indices: IntRange
	// JVM method = getIndices([Z)Lkotlin/ranges/IntRange;
	get() = /* non-default */

val ByteArray.indices: IntRange
	// JVM method = getIndices([B)Lkotlin/ranges/IntRange;
	get() = /* non-default */

val CharArray.indices: IntRange
	// JVM method = getIndices([C)Lkotlin/ranges/IntRange;
	get() = /* non-default */

val DoubleArray.indices: IntRange
	// JVM method = getIndices([D)Lkotlin/ranges/IntRange;
	get() = /* non-default */

val FloatArray.indices: IntRange
	// JVM method = getIndices([F)Lkotlin/ranges/IntRange;
	get() = /* non-default */

val IntArray.indices: IntRange
	// JVM method = getIndices([I)Lkotlin/ranges/IntRange;
	get() = /* non-default */

val LongArray.indices: IntRange
	// JVM method = getIndices([J)Lkotlin/ranges/IntRange;
	get() = /* non-default */

val ShortArray.indices: IntRange
	// JVM method = getIndices([S)Lkotlin/ranges/IntRange;
	get() = /* non-default */

val <T> Array<out T>.lastIndex: Int
	// JVM method = getLastIndex([Ljava/lang/Object;)I
	get() = /* non-default */

val BooleanArray.lastIndex: Int
	// JVM method = getLastIndex([Z)I
	get() = /* non-default */

val ByteArray.lastIndex: Int
	// JVM method = getLastIndex([B)I
	get() = /* non-default */

val CharArray.lastIndex: Int
	// JVM method = getLastIndex([C)I
	get() = /* non-default */

val DoubleArray.lastIndex: Int
	// JVM method = getLastIndex([D)I
	get() = /* non-default */

val FloatArray.lastIndex: Int
	// JVM method = getLastIndex([F)I
	get() = /* non-default */

val IntArray.lastIndex: Int
	// JVM method = getLastIndex([I)I
	get() = /* non-default */

val LongArray.lastIndex: Int
	// JVM method = getLastIndex([J)I
	get() = /* non-default */

val ShortArray.lastIndex: Int
	// JVM method = getLastIndex([S)I
	get() = /* non-default */


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Z
inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all([ZLkotlin/jvm/functions/Function1;)Z
inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all([BLkotlin/jvm/functions/Function1;)Z
inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all([CLkotlin/jvm/functions/Function1;)Z
inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all([DLkotlin/jvm/functions/Function1;)Z
inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all([FLkotlin/jvm/functions/Function1;)Z
inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all([ILkotlin/jvm/functions/Function1;)Z
inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all([JLkotlin/jvm/functions/Function1;)Z
inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all([SLkotlin/jvm/functions/Function1;)Z
inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean

// JVM method = any([Ljava/lang/Object;)Z
fun <T> Array<out T>.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Z
inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean

// JVM method = any([Z)Z
fun BooleanArray.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any([ZLkotlin/jvm/functions/Function1;)Z
inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean

// JVM method = any([B)Z
fun ByteArray.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any([BLkotlin/jvm/functions/Function1;)Z
inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean

// JVM method = any([C)Z
fun CharArray.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any([CLkotlin/jvm/functions/Function1;)Z
inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean

// JVM method = any([D)Z
fun DoubleArray.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any([DLkotlin/jvm/functions/Function1;)Z
inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean

// JVM method = any([F)Z
fun FloatArray.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any([FLkotlin/jvm/functions/Function1;)Z
inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean

// JVM method = any([I)Z
fun IntArray.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any([ILkotlin/jvm/functions/Function1;)Z
inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean

// JVM method = any([J)Z
fun LongArray.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any([JLkotlin/jvm/functions/Function1;)Z
inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean

// JVM method = any([S)Z
fun ShortArray.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any([SLkotlin/jvm/functions/Function1;)Z
inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean

// JVM method = asIterable([Ljava/lang/Object;)Ljava/lang/Iterable;
fun <T> Array<out T>.asIterable(): Iterable<T>

// JVM method = asIterable([Z)Ljava/lang/Iterable;
fun BooleanArray.asIterable(): Iterable<Boolean>

// JVM method = asIterable([B)Ljava/lang/Iterable;
fun ByteArray.asIterable(): Iterable<Byte>

// JVM method = asIterable([C)Ljava/lang/Iterable;
fun CharArray.asIterable(): Iterable<Char>

// JVM method = asIterable([D)Ljava/lang/Iterable;
fun DoubleArray.asIterable(): Iterable<Double>

// JVM method = asIterable([F)Ljava/lang/Iterable;
fun FloatArray.asIterable(): Iterable<Float>

// JVM method = asIterable([I)Ljava/lang/Iterable;
fun IntArray.asIterable(): Iterable<Int>

// JVM method = asIterable([J)Ljava/lang/Iterable;
fun LongArray.asIterable(): Iterable<Long>

// JVM method = asIterable([S)Ljava/lang/Iterable;
fun ShortArray.asIterable(): Iterable<Short>

// JVM method = asSequence([Ljava/lang/Object;)Lkotlin/sequences/Sequence;
fun <T> Array<out T>.asSequence(): Sequence<T>

// JVM method = asSequence([Z)Lkotlin/sequences/Sequence;
fun BooleanArray.asSequence(): Sequence<Boolean>

// JVM method = asSequence([B)Lkotlin/sequences/Sequence;
fun ByteArray.asSequence(): Sequence<Byte>

// JVM method = asSequence([C)Lkotlin/sequences/Sequence;
fun CharArray.asSequence(): Sequence<Char>

// JVM method = asSequence([D)Lkotlin/sequences/Sequence;
fun DoubleArray.asSequence(): Sequence<Double>

// JVM method = asSequence([F)Lkotlin/sequences/Sequence;
fun FloatArray.asSequence(): Sequence<Float>

// JVM method = asSequence([I)Lkotlin/sequences/Sequence;
fun IntArray.asSequence(): Sequence<Int>

// JVM method = asSequence([J)Lkotlin/sequences/Sequence;
fun LongArray.asSequence(): Sequence<Long>

// JVM method = asSequence([S)Lkotlin/sequences/Sequence;
fun ShortArray.asSequence(): Sequence<Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associate([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associate([ZLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associate([BLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associate([CLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associate([DLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associate([FLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associate([ILkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associate([JLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associate([SLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([ZLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([ZLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([BLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([BLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([CLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([CLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([DLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([DLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([FLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([FLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([ILkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([ILkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([JLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([JLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([SLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy([SLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([Ljava/lang/Object;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M : MutableMap<in K, in T>, keySelector: (T) -> K): M : MutableMap<in K, in T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([Ljava/lang/Object;Ljava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M : MutableMap<in K, in V>, keySelector: (T) -> K, valueTransform: (T) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([ZLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M : MutableMap<in K, in Boolean>, keySelector: (Boolean) -> K): M : MutableMap<in K, in Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([ZLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M : MutableMap<in K, in V>, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([BLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M : MutableMap<in K, in Byte>, keySelector: (Byte) -> K): M : MutableMap<in K, in Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([BLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M : MutableMap<in K, in V>, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([CLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M : MutableMap<in K, in Char>, keySelector: (Char) -> K): M : MutableMap<in K, in Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([CLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M : MutableMap<in K, in V>, keySelector: (Char) -> K, valueTransform: (Char) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([DLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M : MutableMap<in K, in Double>, keySelector: (Double) -> K): M : MutableMap<in K, in Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([DLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M : MutableMap<in K, in V>, keySelector: (Double) -> K, valueTransform: (Double) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([FLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M : MutableMap<in K, in Float>, keySelector: (Float) -> K): M : MutableMap<in K, in Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([FLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M : MutableMap<in K, in V>, keySelector: (Float) -> K, valueTransform: (Float) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([ILjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M : MutableMap<in K, in Int>, keySelector: (Int) -> K): M : MutableMap<in K, in Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([ILjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M : MutableMap<in K, in V>, keySelector: (Int) -> K, valueTransform: (Int) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([JLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M : MutableMap<in K, in Long>, keySelector: (Long) -> K): M : MutableMap<in K, in Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([JLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M : MutableMap<in K, in V>, keySelector: (Long) -> K, valueTransform: (Long) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([SLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M : MutableMap<in K, in Short>, keySelector: (Short) -> K): M : MutableMap<in K, in Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo([SLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M : MutableMap<in K, in V>, keySelector: (Short) -> K, valueTransform: (Short) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateTo([Ljava/lang/Object;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M : MutableMap<in K, in V>, transform: (T) -> Pair<K, V>): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateTo([ZLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M : MutableMap<in K, in V>, transform: (Boolean) -> Pair<K, V>): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateTo([BLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M : MutableMap<in K, in V>, transform: (Byte) -> Pair<K, V>): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateTo([CLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M : MutableMap<in K, in V>, transform: (Char) -> Pair<K, V>): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateTo([DLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M : MutableMap<in K, in V>, transform: (Double) -> Pair<K, V>): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateTo([FLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M : MutableMap<in K, in V>, transform: (Float) -> Pair<K, V>): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateTo([ILjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M : MutableMap<in K, in V>, transform: (Int) -> Pair<K, V>): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateTo([JLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M : MutableMap<in K, in V>, transform: (Long) -> Pair<K, V>): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateTo([SLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M : MutableMap<in K, in V>, transform: (Short) -> Pair<K, V>): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWith([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> Array<out K>.associateWith(valueSelector: (K) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWith([ZLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> BooleanArray.associateWith(valueSelector: (Boolean) -> V): Map<Boolean, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWith([BLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> ByteArray.associateWith(valueSelector: (Byte) -> V): Map<Byte, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWith([CLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> CharArray.associateWith(valueSelector: (Char) -> V): Map<Char, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWith([DLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> DoubleArray.associateWith(valueSelector: (Double) -> V): Map<Double, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWith([FLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> FloatArray.associateWith(valueSelector: (Float) -> V): Map<Float, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWith([ILkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> IntArray.associateWith(valueSelector: (Int) -> V): Map<Int, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWith([JLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> LongArray.associateWith(valueSelector: (Long) -> V): Map<Long, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWith([SLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> ShortArray.associateWith(valueSelector: (Short) -> V): Map<Short, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWithTo([Ljava/lang/Object;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> Array<out K>.associateWithTo(destination: M : MutableMap<in K, in V>, valueSelector: (K) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWithTo([ZLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in Boolean, in V>> BooleanArray.associateWithTo(destination: M : MutableMap<in Boolean, in V>, valueSelector: (Boolean) -> V): M : MutableMap<in Boolean, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWithTo([BLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in Byte, in V>> ByteArray.associateWithTo(destination: M : MutableMap<in Byte, in V>, valueSelector: (Byte) -> V): M : MutableMap<in Byte, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWithTo([CLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in Char, in V>> CharArray.associateWithTo(destination: M : MutableMap<in Char, in V>, valueSelector: (Char) -> V): M : MutableMap<in Char, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWithTo([DLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in Double, in V>> DoubleArray.associateWithTo(destination: M : MutableMap<in Double, in V>, valueSelector: (Double) -> V): M : MutableMap<in Double, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWithTo([FLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in Float, in V>> FloatArray.associateWithTo(destination: M : MutableMap<in Float, in V>, valueSelector: (Float) -> V): M : MutableMap<in Float, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWithTo([ILjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in Int, in V>> IntArray.associateWithTo(destination: M : MutableMap<in Int, in V>, valueSelector: (Int) -> V): M : MutableMap<in Int, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWithTo([JLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in Long, in V>> LongArray.associateWithTo(destination: M : MutableMap<in Long, in V>, valueSelector: (Long) -> V): M : MutableMap<in Long, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWithTo([SLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in Short, in V>> ShortArray.associateWithTo(destination: M : MutableMap<in Short, in V>, valueSelector: (Short) -> V): M : MutableMap<in Short, in V>

// JVM method = averageOfByte([Ljava/lang/Byte;)D
fun Array<out Byte>.average(): Double

// JVM method = averageOfDouble([Ljava/lang/Double;)D
fun Array<out Double>.average(): Double

// JVM method = averageOfFloat([Ljava/lang/Float;)D
fun Array<out Float>.average(): Double

// JVM method = averageOfInt([Ljava/lang/Integer;)D
fun Array<out Int>.average(): Double

// JVM method = averageOfLong([Ljava/lang/Long;)D
fun Array<out Long>.average(): Double

// JVM method = averageOfShort([Ljava/lang/Short;)D
fun Array<out Short>.average(): Double

// JVM method = average([B)D
fun ByteArray.average(): Double

// JVM method = average([D)D
fun DoubleArray.average(): Double

// JVM method = average([F)D
fun FloatArray.average(): Double

// JVM method = average([I)D
fun IntArray.average(): Double

// JVM method = average([J)D
fun LongArray.average(): Double

// JVM method = average([S)D
fun ShortArray.average(): Double

// JVM method = component1([Ljava/lang/Object;)Ljava/lang/Object;
inline operator fun <T> Array<out T>.component1(): T

// JVM method = component1([Z)Z
inline operator fun BooleanArray.component1(): Boolean

// JVM method = component1([B)B
inline operator fun ByteArray.component1(): Byte

// JVM method = component1([C)C
inline operator fun CharArray.component1(): Char

// JVM method = component1([D)D
inline operator fun DoubleArray.component1(): Double

// JVM method = component1([F)F
inline operator fun FloatArray.component1(): Float

// JVM method = component1([I)I
inline operator fun IntArray.component1(): Int

// JVM method = component1([J)J
inline operator fun LongArray.component1(): Long

// JVM method = component1([S)S
inline operator fun ShortArray.component1(): Short

// JVM method = component2([Ljava/lang/Object;)Ljava/lang/Object;
inline operator fun <T> Array<out T>.component2(): T

// JVM method = component2([Z)Z
inline operator fun BooleanArray.component2(): Boolean

// JVM method = component2([B)B
inline operator fun ByteArray.component2(): Byte

// JVM method = component2([C)C
inline operator fun CharArray.component2(): Char

// JVM method = component2([D)D
inline operator fun DoubleArray.component2(): Double

// JVM method = component2([F)F
inline operator fun FloatArray.component2(): Float

// JVM method = component2([I)I
inline operator fun IntArray.component2(): Int

// JVM method = component2([J)J
inline operator fun LongArray.component2(): Long

// JVM method = component2([S)S
inline operator fun ShortArray.component2(): Short

// JVM method = component3([Ljava/lang/Object;)Ljava/lang/Object;
inline operator fun <T> Array<out T>.component3(): T

// JVM method = component3([Z)Z
inline operator fun BooleanArray.component3(): Boolean

// JVM method = component3([B)B
inline operator fun ByteArray.component3(): Byte

// JVM method = component3([C)C
inline operator fun CharArray.component3(): Char

// JVM method = component3([D)D
inline operator fun DoubleArray.component3(): Double

// JVM method = component3([F)F
inline operator fun FloatArray.component3(): Float

// JVM method = component3([I)I
inline operator fun IntArray.component3(): Int

// JVM method = component3([J)J
inline operator fun LongArray.component3(): Long

// JVM method = component3([S)S
inline operator fun ShortArray.component3(): Short

// JVM method = component4([Ljava/lang/Object;)Ljava/lang/Object;
inline operator fun <T> Array<out T>.component4(): T

// JVM method = component4([Z)Z
inline operator fun BooleanArray.component4(): Boolean

// JVM method = component4([B)B
inline operator fun ByteArray.component4(): Byte

// JVM method = component4([C)C
inline operator fun CharArray.component4(): Char

// JVM method = component4([D)D
inline operator fun DoubleArray.component4(): Double

// JVM method = component4([F)F
inline operator fun FloatArray.component4(): Float

// JVM method = component4([I)I
inline operator fun IntArray.component4(): Int

// JVM method = component4([J)J
inline operator fun LongArray.component4(): Long

// JVM method = component4([S)S
inline operator fun ShortArray.component4(): Short

// JVM method = component5([Ljava/lang/Object;)Ljava/lang/Object;
inline operator fun <T> Array<out T>.component5(): T

// JVM method = component5([Z)Z
inline operator fun BooleanArray.component5(): Boolean

// JVM method = component5([B)B
inline operator fun ByteArray.component5(): Byte

// JVM method = component5([C)C
inline operator fun CharArray.component5(): Char

// JVM method = component5([D)D
inline operator fun DoubleArray.component5(): Double

// JVM method = component5([F)F
inline operator fun FloatArray.component5(): Float

// JVM method = component5([I)I
inline operator fun IntArray.component5(): Int

// JVM method = component5([J)J
inline operator fun LongArray.component5(): Long

// JVM method = component5([S)S
inline operator fun ShortArray.component5(): Short

// JVM method = contains([Ljava/lang/Object;Ljava/lang/Object;)Z
operator fun <@kotlin.internal.OnlyInputTypes T> Array<out @kotlin.internal.OnlyInputTypes T>.contains(element: @kotlin.internal.OnlyInputTypes T): Boolean

// JVM method = contains([ZZ)Z
operator fun BooleanArray.contains(element: Boolean): Boolean

// JVM method = contains([BB)Z
operator fun ByteArray.contains(element: Byte): Boolean

// JVM method = contains([CC)Z
operator fun CharArray.contains(element: Char): Boolean

// JVM method = contains([DD)Z
operator fun DoubleArray.contains(element: Double): Boolean

// JVM method = contains([FF)Z
operator fun FloatArray.contains(element: Float): Boolean

// JVM method = contains([II)Z
operator fun IntArray.contains(element: Int): Boolean

// JVM method = contains([JJ)Z
operator fun LongArray.contains(element: Long): Boolean

// JVM method = contains([SS)Z
operator fun ShortArray.contains(element: Short): Boolean

// JVM method = count([Ljava/lang/Object;)I
inline fun <T> Array<out T>.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int

// JVM method = count([Z)I
inline fun BooleanArray.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count([ZLkotlin/jvm/functions/Function1;)I
inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int

// JVM method = count([B)I
inline fun ByteArray.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count([BLkotlin/jvm/functions/Function1;)I
inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int

// JVM method = count([C)I
inline fun CharArray.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count([CLkotlin/jvm/functions/Function1;)I
inline fun CharArray.count(predicate: (Char) -> Boolean): Int

// JVM method = count([D)I
inline fun DoubleArray.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count([DLkotlin/jvm/functions/Function1;)I
inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int

// JVM method = count([F)I
inline fun FloatArray.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count([FLkotlin/jvm/functions/Function1;)I
inline fun FloatArray.count(predicate: (Float) -> Boolean): Int

// JVM method = count([I)I
inline fun IntArray.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count([ILkotlin/jvm/functions/Function1;)I
inline fun IntArray.count(predicate: (Int) -> Boolean): Int

// JVM method = count([J)I
inline fun LongArray.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count([JLkotlin/jvm/functions/Function1;)I
inline fun LongArray.count(predicate: (Long) -> Boolean): Int

// JVM method = count([S)I
inline fun ShortArray.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count([SLkotlin/jvm/functions/Function1;)I
inline fun ShortArray.count(predicate: (Short) -> Boolean): Int

// JVM method = distinct([Ljava/lang/Object;)Ljava/util/List;
fun <T> Array<out T>.distinct(): List<T>

// JVM method = distinct([Z)Ljava/util/List;
fun BooleanArray.distinct(): List<Boolean>

// JVM method = distinct([B)Ljava/util/List;
fun ByteArray.distinct(): List<Byte>

// JVM method = distinct([C)Ljava/util/List;
fun CharArray.distinct(): List<Char>

// JVM method = distinct([D)Ljava/util/List;
fun DoubleArray.distinct(): List<Double>

// JVM method = distinct([F)Ljava/util/List;
fun FloatArray.distinct(): List<Float>

// JVM method = distinct([I)Ljava/util/List;
fun IntArray.distinct(): List<Int>

// JVM method = distinct([J)Ljava/util/List;
fun LongArray.distinct(): List<Long>

// JVM method = distinct([S)Ljava/util/List;
fun ShortArray.distinct(): List<Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = distinctBy([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = distinctBy([ZLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = distinctBy([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = distinctBy([CLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = distinctBy([DLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = distinctBy([FLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = distinctBy([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = distinctBy([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = distinctBy([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short>

// JVM method = drop([Ljava/lang/Object;I)Ljava/util/List;
fun <T> Array<out T>.drop(n: Int): List<T>

// JVM method = drop([ZI)Ljava/util/List;
fun BooleanArray.drop(n: Int): List<Boolean>

// JVM method = drop([BI)Ljava/util/List;
fun ByteArray.drop(n: Int): List<Byte>

// JVM method = drop([CI)Ljava/util/List;
fun CharArray.drop(n: Int): List<Char>

// JVM method = drop([DI)Ljava/util/List;
fun DoubleArray.drop(n: Int): List<Double>

// JVM method = drop([FI)Ljava/util/List;
fun FloatArray.drop(n: Int): List<Float>

// JVM method = drop([II)Ljava/util/List;
fun IntArray.drop(n: Int): List<Int>

// JVM method = drop([JI)Ljava/util/List;
fun LongArray.drop(n: Int): List<Long>

// JVM method = drop([SI)Ljava/util/List;
fun ShortArray.drop(n: Int): List<Short>

// JVM method = dropLast([Ljava/lang/Object;I)Ljava/util/List;
fun <T> Array<out T>.dropLast(n: Int): List<T>

// JVM method = dropLast([ZI)Ljava/util/List;
fun BooleanArray.dropLast(n: Int): List<Boolean>

// JVM method = dropLast([BI)Ljava/util/List;
fun ByteArray.dropLast(n: Int): List<Byte>

// JVM method = dropLast([CI)Ljava/util/List;
fun CharArray.dropLast(n: Int): List<Char>

// JVM method = dropLast([DI)Ljava/util/List;
fun DoubleArray.dropLast(n: Int): List<Double>

// JVM method = dropLast([FI)Ljava/util/List;
fun FloatArray.dropLast(n: Int): List<Float>

// JVM method = dropLast([II)Ljava/util/List;
fun IntArray.dropLast(n: Int): List<Int>

// JVM method = dropLast([JI)Ljava/util/List;
fun LongArray.dropLast(n: Int): List<Long>

// JVM method = dropLast([SI)Ljava/util/List;
fun ShortArray.dropLast(n: Int): List<Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropLastWhile([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropLastWhile([ZLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropLastWhile([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropLastWhile([CLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropLastWhile([DLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropLastWhile([FLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropLastWhile([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropLastWhile([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropLastWhile([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropWhile([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropWhile([ZLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropWhile([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropWhile([CLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropWhile([DLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropWhile([FLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropWhile([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropWhile([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropWhile([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = elementAtOrElse([Ljava/lang/Object;ILkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = elementAtOrElse([ZILkotlin/jvm/functions/Function1;)Z
inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = elementAtOrElse([BILkotlin/jvm/functions/Function1;)B
inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = elementAtOrElse([CILkotlin/jvm/functions/Function1;)C
inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = elementAtOrElse([DILkotlin/jvm/functions/Function1;)D
inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = elementAtOrElse([FILkotlin/jvm/functions/Function1;)F
inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = elementAtOrElse([IILkotlin/jvm/functions/Function1;)I
inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = elementAtOrElse([JILkotlin/jvm/functions/Function1;)J
inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = elementAtOrElse([SILkotlin/jvm/functions/Function1;)S
inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short

// JVM method = elementAtOrNull([Ljava/lang/Object;I)Ljava/lang/Object;
inline fun <T> Array<out T>.elementAtOrNull(index: Int): T?

// JVM method = elementAtOrNull([ZI)Ljava/lang/Boolean;
inline fun BooleanArray.elementAtOrNull(index: Int): Boolean?

// JVM method = elementAtOrNull([BI)Ljava/lang/Byte;
inline fun ByteArray.elementAtOrNull(index: Int): Byte?

// JVM method = elementAtOrNull([CI)Ljava/lang/Character;
inline fun CharArray.elementAtOrNull(index: Int): Char?

// JVM method = elementAtOrNull([DI)Ljava/lang/Double;
inline fun DoubleArray.elementAtOrNull(index: Int): Double?

// JVM method = elementAtOrNull([FI)Ljava/lang/Float;
inline fun FloatArray.elementAtOrNull(index: Int): Float?

// JVM method = elementAtOrNull([II)Ljava/lang/Integer;
inline fun IntArray.elementAtOrNull(index: Int): Int?

// JVM method = elementAtOrNull([JI)Ljava/lang/Long;
inline fun LongArray.elementAtOrNull(index: Int): Long?

// JVM method = elementAtOrNull([SI)Ljava/lang/Short;
inline fun ShortArray.elementAtOrNull(index: Int): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter([ZLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter([CLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter([DLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter([FLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexed([Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T> Array<out T>.filterIndexed(predicate: (@ParameterName(name = "index") Int, T) -> Boolean): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexed([ZLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun BooleanArray.filterIndexed(predicate: (@ParameterName(name = "index") Int, Boolean) -> Boolean): List<Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexed([BLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun ByteArray.filterIndexed(predicate: (@ParameterName(name = "index") Int, Byte) -> Boolean): List<Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexed([CLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun CharArray.filterIndexed(predicate: (@ParameterName(name = "index") Int, Char) -> Boolean): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexed([DLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun DoubleArray.filterIndexed(predicate: (@ParameterName(name = "index") Int, Double) -> Boolean): List<Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexed([FLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun FloatArray.filterIndexed(predicate: (@ParameterName(name = "index") Int, Float) -> Boolean): List<Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexed([ILkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun IntArray.filterIndexed(predicate: (@ParameterName(name = "index") Int, Int) -> Boolean): List<Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexed([JLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun LongArray.filterIndexed(predicate: (@ParameterName(name = "index") Int, Long) -> Boolean): List<Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexed([SLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun ShortArray.filterIndexed(predicate: (@ParameterName(name = "index") Int, Short) -> Boolean): List<Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexedTo([Ljava/lang/Object;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C : MutableCollection<in T>, predicate: (@ParameterName(name = "index") Int, T) -> Boolean): C : MutableCollection<in T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexedTo([ZLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C : MutableCollection<in Boolean>, predicate: (@ParameterName(name = "index") Int, Boolean) -> Boolean): C : MutableCollection<in Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexedTo([BLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C : MutableCollection<in Byte>, predicate: (@ParameterName(name = "index") Int, Byte) -> Boolean): C : MutableCollection<in Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexedTo([CLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C : MutableCollection<in Char>, predicate: (@ParameterName(name = "index") Int, Char) -> Boolean): C : MutableCollection<in Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexedTo([DLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C : MutableCollection<in Double>, predicate: (@ParameterName(name = "index") Int, Double) -> Boolean): C : MutableCollection<in Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexedTo([FLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C : MutableCollection<in Float>, predicate: (@ParameterName(name = "index") Int, Float) -> Boolean): C : MutableCollection<in Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexedTo([ILjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C : MutableCollection<in Int>, predicate: (@ParameterName(name = "index") Int, Int) -> Boolean): C : MutableCollection<in Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexedTo([JLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C : MutableCollection<in Long>, predicate: (@ParameterName(name = "index") Int, Long) -> Boolean): C : MutableCollection<in Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexedTo([SLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C : MutableCollection<in Short>, predicate: (@ParameterName(name = "index") Int, Short) -> Boolean): C : MutableCollection<in Short>

// JVM method = filterIsInstance([Ljava/lang/Object;)Ljava/util/List;
inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer reified R>

// JVM method = filterIsInstanceTo([Ljava/lang/Object;Ljava/util/Collection;)Ljava/util/Collection;
inline fun <reified R, C : MutableCollection<in reified R>> Array<*>.filterIsInstanceTo(destination: C : MutableCollection<in reified R>): C : MutableCollection<in reified R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot([ZLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot([CLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot([DLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot([FLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short>

// JVM method = filterNotNull([Ljava/lang/Object;)Ljava/util/List;
fun <T : Any> Array<out T : Any?>.filterNotNull(): List<T : Any>

// JVM method = filterNotNullTo([Ljava/lang/Object;Ljava/util/Collection;)Ljava/util/Collection;
fun <C : MutableCollection<in T : Any>, T : Any> Array<out T : Any?>.filterNotNullTo(destination: C : MutableCollection<in T : Any>): C : MutableCollection<in T : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo([Ljava/lang/Object;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C : MutableCollection<in T>, predicate: (T) -> Boolean): C : MutableCollection<in T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo([ZLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C : MutableCollection<in Boolean>, predicate: (Boolean) -> Boolean): C : MutableCollection<in Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo([BLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C : MutableCollection<in Byte>, predicate: (Byte) -> Boolean): C : MutableCollection<in Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo([CLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C : MutableCollection<in Char>, predicate: (Char) -> Boolean): C : MutableCollection<in Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo([DLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C : MutableCollection<in Double>, predicate: (Double) -> Boolean): C : MutableCollection<in Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo([FLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C : MutableCollection<in Float>, predicate: (Float) -> Boolean): C : MutableCollection<in Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo([ILjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C : MutableCollection<in Int>, predicate: (Int) -> Boolean): C : MutableCollection<in Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo([JLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C : MutableCollection<in Long>, predicate: (Long) -> Boolean): C : MutableCollection<in Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo([SLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C : MutableCollection<in Short>, predicate: (Short) -> Boolean): C : MutableCollection<in Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo([Ljava/lang/Object;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C : MutableCollection<in T>, predicate: (T) -> Boolean): C : MutableCollection<in T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo([ZLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C : MutableCollection<in Boolean>, predicate: (Boolean) -> Boolean): C : MutableCollection<in Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo([BLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C : MutableCollection<in Byte>, predicate: (Byte) -> Boolean): C : MutableCollection<in Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo([CLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C : MutableCollection<in Char>, predicate: (Char) -> Boolean): C : MutableCollection<in Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo([DLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C : MutableCollection<in Double>, predicate: (Double) -> Boolean): C : MutableCollection<in Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo([FLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C : MutableCollection<in Float>, predicate: (Float) -> Boolean): C : MutableCollection<in Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo([ILjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C : MutableCollection<in Int>, predicate: (Int) -> Boolean): C : MutableCollection<in Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo([JLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C : MutableCollection<in Long>, predicate: (Long) -> Boolean): C : MutableCollection<in Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo([SLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C : MutableCollection<in Short>, predicate: (Short) -> Boolean): C : MutableCollection<in Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = find([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = find([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Boolean;
inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = find([BLkotlin/jvm/functions/Function1;)Ljava/lang/Byte;
inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = find([CLkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun CharArray.find(predicate: (Char) -> Boolean): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = find([DLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = find([FLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun FloatArray.find(predicate: (Float) -> Boolean): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = find([ILkotlin/jvm/functions/Function1;)Ljava/lang/Integer;
inline fun IntArray.find(predicate: (Int) -> Boolean): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = find([JLkotlin/jvm/functions/Function1;)Ljava/lang/Long;
inline fun LongArray.find(predicate: (Long) -> Boolean): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = find([SLkotlin/jvm/functions/Function1;)Ljava/lang/Short;
inline fun ShortArray.find(predicate: (Short) -> Boolean): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Boolean;
inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast([BLkotlin/jvm/functions/Function1;)Ljava/lang/Byte;
inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast([CLkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast([DLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast([FLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast([ILkotlin/jvm/functions/Function1;)Ljava/lang/Integer;
inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast([JLkotlin/jvm/functions/Function1;)Ljava/lang/Long;
inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast([SLkotlin/jvm/functions/Function1;)Ljava/lang/Short;
inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short?

// JVM method = first([Ljava/lang/Object;)Ljava/lang/Object;
fun <T> Array<out T>.first(): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = first([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T

// JVM method = first([Z)Z
fun BooleanArray.first(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = first([ZLkotlin/jvm/functions/Function1;)Z
inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean

// JVM method = first([B)B
fun ByteArray.first(): Byte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = first([BLkotlin/jvm/functions/Function1;)B
inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte

// JVM method = first([C)C
fun CharArray.first(): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = first([CLkotlin/jvm/functions/Function1;)C
inline fun CharArray.first(predicate: (Char) -> Boolean): Char

// JVM method = first([D)D
fun DoubleArray.first(): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = first([DLkotlin/jvm/functions/Function1;)D
inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double

// JVM method = first([F)F
fun FloatArray.first(): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = first([FLkotlin/jvm/functions/Function1;)F
inline fun FloatArray.first(predicate: (Float) -> Boolean): Float

// JVM method = first([I)I
fun IntArray.first(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = first([ILkotlin/jvm/functions/Function1;)I
inline fun IntArray.first(predicate: (Int) -> Boolean): Int

// JVM method = first([J)J
fun LongArray.first(): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = first([JLkotlin/jvm/functions/Function1;)J
inline fun LongArray.first(predicate: (Long) -> Boolean): Long

// JVM method = first([S)S
fun ShortArray.first(): Short

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = first([SLkotlin/jvm/functions/Function1;)S
inline fun ShortArray.first(predicate: (Short) -> Boolean): Short

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstNotNullOf([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Any> Array<out T>.firstNotNullOf(transform: (T) -> R : Any?): R : Any

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstNotNullOfOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Any> Array<out T>.firstNotNullOfOrNull(transform: (T) -> R : Any?): R : Any?

// JVM method = firstOrNull([Ljava/lang/Object;)Ljava/lang/Object;
fun <T> Array<out T>.firstOrNull(): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T?

// JVM method = firstOrNull([Z)Ljava/lang/Boolean;
fun BooleanArray.firstOrNull(): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstOrNull([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Boolean;
inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean?

// JVM method = firstOrNull([B)Ljava/lang/Byte;
fun ByteArray.firstOrNull(): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstOrNull([BLkotlin/jvm/functions/Function1;)Ljava/lang/Byte;
inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte?

// JVM method = firstOrNull([C)Ljava/lang/Character;
fun CharArray.firstOrNull(): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstOrNull([CLkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char?

// JVM method = firstOrNull([D)Ljava/lang/Double;
fun DoubleArray.firstOrNull(): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstOrNull([DLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double?

// JVM method = firstOrNull([F)Ljava/lang/Float;
fun FloatArray.firstOrNull(): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstOrNull([FLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float?

// JVM method = firstOrNull([I)Ljava/lang/Integer;
fun IntArray.firstOrNull(): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstOrNull([ILkotlin/jvm/functions/Function1;)Ljava/lang/Integer;
inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int?

// JVM method = firstOrNull([J)Ljava/lang/Long;
fun LongArray.firstOrNull(): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstOrNull([JLkotlin/jvm/functions/Function1;)Ljava/lang/Long;
inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long?

// JVM method = firstOrNull([S)Ljava/lang/Short;
fun ShortArray.firstOrNull(): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstOrNull([SLkotlin/jvm/functions/Function1;)Ljava/lang/Short;
inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMap([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapSequence([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Sequence<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMap([ZLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMap([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMap([CLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMap([DLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMap([FLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMap([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMap([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMap([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterable([Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R> Array<out T>.flatMapIndexed(transform: (@ParameterName(name = "index") Int, T) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedSequence([Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R> Array<out T>.flatMapIndexed(transform: (@ParameterName(name = "index") Int, T) -> Sequence<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterable([ZLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> BooleanArray.flatMapIndexed(transform: (@ParameterName(name = "index") Int, Boolean) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterable([BLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> ByteArray.flatMapIndexed(transform: (@ParameterName(name = "index") Int, Byte) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterable([CLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> CharArray.flatMapIndexed(transform: (@ParameterName(name = "index") Int, Char) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterable([DLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> DoubleArray.flatMapIndexed(transform: (@ParameterName(name = "index") Int, Double) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterable([FLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> FloatArray.flatMapIndexed(transform: (@ParameterName(name = "index") Int, Float) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterable([ILkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> IntArray.flatMapIndexed(transform: (@ParameterName(name = "index") Int, Int) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterable([JLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> LongArray.flatMapIndexed(transform: (@ParameterName(name = "index") Int, Long) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterable([SLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> ShortArray.flatMapIndexed(transform: (@ParameterName(name = "index") Int, Short) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterableTo([Ljava/lang/Object;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, T) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedSequenceTo([Ljava/lang/Object;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, T) -> Sequence<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterableTo([ZLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Boolean) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterableTo([BLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Byte) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterableTo([CLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> CharArray.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Char) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterableTo([DLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Double) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterableTo([FLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Float) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterableTo([ILjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Int) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterableTo([JLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> LongArray.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Long) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterableTo([SLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Short) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo([Ljava/lang/Object;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C : MutableCollection<in R>, transform: (T) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapSequenceTo([Ljava/lang/Object;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C : MutableCollection<in R>, transform: (T) -> Sequence<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo([ZLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C : MutableCollection<in R>, transform: (Boolean) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo([BLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C : MutableCollection<in R>, transform: (Byte) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo([CLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C : MutableCollection<in R>, transform: (Char) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo([DLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C : MutableCollection<in R>, transform: (Double) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo([FLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C : MutableCollection<in R>, transform: (Float) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo([ILjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C : MutableCollection<in R>, transform: (Int) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo([JLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C : MutableCollection<in R>, transform: (Long) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo([SLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C : MutableCollection<in R>, transform: (Short) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold([Ljava/lang/Object;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <T, R> Array<out T>.fold(initial: R, operation: (@ParameterName(name = "acc") R, T) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold([ZLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> BooleanArray.fold(initial: R, operation: (@ParameterName(name = "acc") R, Boolean) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold([BLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> ByteArray.fold(initial: R, operation: (@ParameterName(name = "acc") R, Byte) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold([CLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> CharArray.fold(initial: R, operation: (@ParameterName(name = "acc") R, Char) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold([DLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> DoubleArray.fold(initial: R, operation: (@ParameterName(name = "acc") R, Double) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold([FLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> FloatArray.fold(initial: R, operation: (@ParameterName(name = "acc") R, Float) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold([ILjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> IntArray.fold(initial: R, operation: (@ParameterName(name = "acc") R, Int) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold([JLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> LongArray.fold(initial: R, operation: (@ParameterName(name = "acc") R, Long) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold([SLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> ShortArray.fold(initial: R, operation: (@ParameterName(name = "acc") R, Short) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldIndexed([Ljava/lang/Object;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, T) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldIndexed([ZLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Boolean) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldIndexed([BLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> ByteArray.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Byte) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldIndexed([CLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> CharArray.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Char) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldIndexed([DLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Double) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldIndexed([FLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> FloatArray.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Float) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldIndexed([ILjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> IntArray.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Int) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldIndexed([JLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> LongArray.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Long) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldIndexed([SLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> ShortArray.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Short) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRight([Ljava/lang/Object;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRight([ZLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRight([BLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRight([CLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> CharArray.foldRight(initial: R, operation: (Char, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRight([DLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRight([FLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRight([ILjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> IntArray.foldRight(initial: R, operation: (Int, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRight([JLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> LongArray.foldRight(initial: R, operation: (Long, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRight([SLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRightIndexed([Ljava/lang/Object;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, T, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRightIndexed([ZLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, Boolean, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRightIndexed([BLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, Byte, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRightIndexed([CLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, Char, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRightIndexed([DLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, Double, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRightIndexed([FLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, Float, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRightIndexed([ILjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, Int, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRightIndexed([JLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, Long, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRightIndexed([SLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, Short, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)V
inline fun <T> Array<out T>.forEach(action: (T) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach([ZLkotlin/jvm/functions/Function1;)V
inline fun BooleanArray.forEach(action: (Boolean) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach([BLkotlin/jvm/functions/Function1;)V
inline fun ByteArray.forEach(action: (Byte) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach([CLkotlin/jvm/functions/Function1;)V
inline fun CharArray.forEach(action: (Char) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach([DLkotlin/jvm/functions/Function1;)V
inline fun DoubleArray.forEach(action: (Double) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach([FLkotlin/jvm/functions/Function1;)V
inline fun FloatArray.forEach(action: (Float) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach([ILkotlin/jvm/functions/Function1;)V
inline fun IntArray.forEach(action: (Int) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach([JLkotlin/jvm/functions/Function1;)V
inline fun LongArray.forEach(action: (Long) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach([SLkotlin/jvm/functions/Function1;)V
inline fun ShortArray.forEach(action: (Short) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachIndexed([Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)V
inline fun <T> Array<out T>.forEachIndexed(action: (@ParameterName(name = "index") Int, T) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachIndexed([ZLkotlin/jvm/functions/Function2;)V
inline fun BooleanArray.forEachIndexed(action: (@ParameterName(name = "index") Int, Boolean) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachIndexed([BLkotlin/jvm/functions/Function2;)V
inline fun ByteArray.forEachIndexed(action: (@ParameterName(name = "index") Int, Byte) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachIndexed([CLkotlin/jvm/functions/Function2;)V
inline fun CharArray.forEachIndexed(action: (@ParameterName(name = "index") Int, Char) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachIndexed([DLkotlin/jvm/functions/Function2;)V
inline fun DoubleArray.forEachIndexed(action: (@ParameterName(name = "index") Int, Double) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachIndexed([FLkotlin/jvm/functions/Function2;)V
inline fun FloatArray.forEachIndexed(action: (@ParameterName(name = "index") Int, Float) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachIndexed([ILkotlin/jvm/functions/Function2;)V
inline fun IntArray.forEachIndexed(action: (@ParameterName(name = "index") Int, Int) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachIndexed([JLkotlin/jvm/functions/Function2;)V
inline fun LongArray.forEachIndexed(action: (@ParameterName(name = "index") Int, Long) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachIndexed([SLkotlin/jvm/functions/Function2;)V
inline fun ShortArray.forEachIndexed(action: (@ParameterName(name = "index") Int, Short) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElse([Ljava/lang/Object;ILkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElse([ZILkotlin/jvm/functions/Function1;)Z
inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElse([BILkotlin/jvm/functions/Function1;)B
inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElse([CILkotlin/jvm/functions/Function1;)C
inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElse([DILkotlin/jvm/functions/Function1;)D
inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElse([FILkotlin/jvm/functions/Function1;)F
inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElse([IILkotlin/jvm/functions/Function1;)I
inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElse([JILkotlin/jvm/functions/Function1;)J
inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElse([SILkotlin/jvm/functions/Function1;)S
inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short

// JVM method = getOrNull([Ljava/lang/Object;I)Ljava/lang/Object;
fun <T> Array<out T>.getOrNull(index: Int): T?

// JVM method = getOrNull([ZI)Ljava/lang/Boolean;
fun BooleanArray.getOrNull(index: Int): Boolean?

// JVM method = getOrNull([BI)Ljava/lang/Byte;
fun ByteArray.getOrNull(index: Int): Byte?

// JVM method = getOrNull([CI)Ljava/lang/Character;
fun CharArray.getOrNull(index: Int): Char?

// JVM method = getOrNull([DI)Ljava/lang/Double;
fun DoubleArray.getOrNull(index: Int): Double?

// JVM method = getOrNull([FI)Ljava/lang/Float;
fun FloatArray.getOrNull(index: Int): Float?

// JVM method = getOrNull([II)Ljava/lang/Integer;
fun IntArray.getOrNull(index: Int): Int?

// JVM method = getOrNull([JI)Ljava/lang/Long;
fun LongArray.getOrNull(index: Int): Long?

// JVM method = getOrNull([SI)Ljava/lang/Short;
fun ShortArray.getOrNull(index: Int): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([ZLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([ZLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([BLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([BLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([CLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([CLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([DLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([DLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([FLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([FLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([ILkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([ILkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([JLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([JLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([SLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy([SLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([Ljava/lang/Object;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M : MutableMap<in K, MutableList<T>>, keySelector: (T) -> K): M : MutableMap<in K, MutableList<T>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([Ljava/lang/Object;Ljava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (T) -> K, valueTransform: (T) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([ZLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M : MutableMap<in K, MutableList<Boolean>>, keySelector: (Boolean) -> K): M : MutableMap<in K, MutableList<Boolean>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([ZLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([BLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M : MutableMap<in K, MutableList<Byte>>, keySelector: (Byte) -> K): M : MutableMap<in K, MutableList<Byte>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([BLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([CLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M : MutableMap<in K, MutableList<Char>>, keySelector: (Char) -> K): M : MutableMap<in K, MutableList<Char>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([CLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (Char) -> K, valueTransform: (Char) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([DLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M : MutableMap<in K, MutableList<Double>>, keySelector: (Double) -> K): M : MutableMap<in K, MutableList<Double>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([DLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (Double) -> K, valueTransform: (Double) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([FLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M : MutableMap<in K, MutableList<Float>>, keySelector: (Float) -> K): M : MutableMap<in K, MutableList<Float>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([FLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (Float) -> K, valueTransform: (Float) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([ILjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M : MutableMap<in K, MutableList<Int>>, keySelector: (Int) -> K): M : MutableMap<in K, MutableList<Int>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([ILjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (Int) -> K, valueTransform: (Int) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([JLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M : MutableMap<in K, MutableList<Long>>, keySelector: (Long) -> K): M : MutableMap<in K, MutableList<Long>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([JLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (Long) -> K, valueTransform: (Long) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([SLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M : MutableMap<in K, MutableList<Short>>, keySelector: (Short) -> K): M : MutableMap<in K, MutableList<Short>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo([SLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (Short) -> K, valueTransform: (Short) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupingBy([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Lkotlin/collections/Grouping;
inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K>

// JVM method = indexOf([Ljava/lang/Object;Ljava/lang/Object;)I
fun <@kotlin.internal.OnlyInputTypes T> Array<out @kotlin.internal.OnlyInputTypes T>.indexOf(element: @kotlin.internal.OnlyInputTypes T): Int

// JVM method = indexOf([ZZ)I
fun BooleanArray.indexOf(element: Boolean): Int

// JVM method = indexOf([BB)I
fun ByteArray.indexOf(element: Byte): Int

// JVM method = indexOf([CC)I
fun CharArray.indexOf(element: Char): Int

// JVM method = indexOf([DD)I
fun DoubleArray.indexOf(element: Double): Int

// JVM method = indexOf([FF)I
fun FloatArray.indexOf(element: Float): Int

// JVM method = indexOf([II)I
fun IntArray.indexOf(element: Int): Int

// JVM method = indexOf([JJ)I
fun LongArray.indexOf(element: Long): Int

// JVM method = indexOf([SS)I
fun ShortArray.indexOf(element: Short): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst([ZLkotlin/jvm/functions/Function1;)I
inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst([BLkotlin/jvm/functions/Function1;)I
inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst([CLkotlin/jvm/functions/Function1;)I
inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst([DLkotlin/jvm/functions/Function1;)I
inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst([FLkotlin/jvm/functions/Function1;)I
inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst([ILkotlin/jvm/functions/Function1;)I
inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst([JLkotlin/jvm/functions/Function1;)I
inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst([SLkotlin/jvm/functions/Function1;)I
inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast([ZLkotlin/jvm/functions/Function1;)I
inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast([BLkotlin/jvm/functions/Function1;)I
inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast([CLkotlin/jvm/functions/Function1;)I
inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast([DLkotlin/jvm/functions/Function1;)I
inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast([FLkotlin/jvm/functions/Function1;)I
inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast([ILkotlin/jvm/functions/Function1;)I
inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast([JLkotlin/jvm/functions/Function1;)I
inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast([SLkotlin/jvm/functions/Function1;)I
inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int

// JVM method = intersect([Ljava/lang/Object;Ljava/lang/Iterable;)Ljava/util/Set;
infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T>

// JVM method = intersect([ZLjava/lang/Iterable;)Ljava/util/Set;
infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean>

// JVM method = intersect([BLjava/lang/Iterable;)Ljava/util/Set;
infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte>

// JVM method = intersect([CLjava/lang/Iterable;)Ljava/util/Set;
infix fun CharArray.intersect(other: Iterable<Char>): Set<Char>

// JVM method = intersect([DLjava/lang/Iterable;)Ljava/util/Set;
infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double>

// JVM method = intersect([FLjava/lang/Iterable;)Ljava/util/Set;
infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float>

// JVM method = intersect([ILjava/lang/Iterable;)Ljava/util/Set;
infix fun IntArray.intersect(other: Iterable<Int>): Set<Int>

// JVM method = intersect([JLjava/lang/Iterable;)Ljava/util/Set;
infix fun LongArray.intersect(other: Iterable<Long>): Set<Long>

// JVM method = intersect([SLjava/lang/Iterable;)Ljava/util/Set;
infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short>

// JVM method = isEmpty([Ljava/lang/Object;)Z
inline fun <T> Array<out T>.isEmpty(): Boolean

// JVM method = isEmpty([Z)Z
inline fun BooleanArray.isEmpty(): Boolean

// JVM method = isEmpty([B)Z
inline fun ByteArray.isEmpty(): Boolean

// JVM method = isEmpty([C)Z
inline fun CharArray.isEmpty(): Boolean

// JVM method = isEmpty([D)Z
inline fun DoubleArray.isEmpty(): Boolean

// JVM method = isEmpty([F)Z
inline fun FloatArray.isEmpty(): Boolean

// JVM method = isEmpty([I)Z
inline fun IntArray.isEmpty(): Boolean

// JVM method = isEmpty([J)Z
inline fun LongArray.isEmpty(): Boolean

// JVM method = isEmpty([S)Z
inline fun ShortArray.isEmpty(): Boolean

// JVM method = isNotEmpty([Ljava/lang/Object;)Z
inline fun <T> Array<out T>.isNotEmpty(): Boolean

// JVM method = isNotEmpty([Z)Z
inline fun BooleanArray.isNotEmpty(): Boolean

// JVM method = isNotEmpty([B)Z
inline fun ByteArray.isNotEmpty(): Boolean

// JVM method = isNotEmpty([C)Z
inline fun CharArray.isNotEmpty(): Boolean

// JVM method = isNotEmpty([D)Z
inline fun DoubleArray.isNotEmpty(): Boolean

// JVM method = isNotEmpty([F)Z
inline fun FloatArray.isNotEmpty(): Boolean

// JVM method = isNotEmpty([I)Z
inline fun IntArray.isNotEmpty(): Boolean

// JVM method = isNotEmpty([J)Z
inline fun LongArray.isNotEmpty(): Boolean

// JVM method = isNotEmpty([S)Z
inline fun ShortArray.isNotEmpty(): Boolean

// JVM method = joinTo([Ljava/lang/Object;Ljava/lang/Appendable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
fun <T, A : Appendable /* = java.lang.Appendable */> Array<out T>.joinTo(buffer: A : Appendable /* = java.lang.Appendable */, separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((T) -> CharSequence)? /* = default */): A : Appendable /* = java.lang.Appendable */

// JVM method = joinTo([ZLjava/lang/Appendable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
fun <A : Appendable /* = java.lang.Appendable */> BooleanArray.joinTo(buffer: A : Appendable /* = java.lang.Appendable */, separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Boolean) -> CharSequence)? /* = default */): A : Appendable /* = java.lang.Appendable */

// JVM method = joinTo([BLjava/lang/Appendable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
fun <A : Appendable /* = java.lang.Appendable */> ByteArray.joinTo(buffer: A : Appendable /* = java.lang.Appendable */, separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Byte) -> CharSequence)? /* = default */): A : Appendable /* = java.lang.Appendable */

// JVM method = joinTo([CLjava/lang/Appendable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
fun <A : Appendable /* = java.lang.Appendable */> CharArray.joinTo(buffer: A : Appendable /* = java.lang.Appendable */, separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Char) -> CharSequence)? /* = default */): A : Appendable /* = java.lang.Appendable */

// JVM method = joinTo([DLjava/lang/Appendable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
fun <A : Appendable /* = java.lang.Appendable */> DoubleArray.joinTo(buffer: A : Appendable /* = java.lang.Appendable */, separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Double) -> CharSequence)? /* = default */): A : Appendable /* = java.lang.Appendable */

// JVM method = joinTo([FLjava/lang/Appendable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
fun <A : Appendable /* = java.lang.Appendable */> FloatArray.joinTo(buffer: A : Appendable /* = java.lang.Appendable */, separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Float) -> CharSequence)? /* = default */): A : Appendable /* = java.lang.Appendable */

// JVM method = joinTo([ILjava/lang/Appendable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
fun <A : Appendable /* = java.lang.Appendable */> IntArray.joinTo(buffer: A : Appendable /* = java.lang.Appendable */, separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Int) -> CharSequence)? /* = default */): A : Appendable /* = java.lang.Appendable */

// JVM method = joinTo([JLjava/lang/Appendable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
fun <A : Appendable /* = java.lang.Appendable */> LongArray.joinTo(buffer: A : Appendable /* = java.lang.Appendable */, separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Long) -> CharSequence)? /* = default */): A : Appendable /* = java.lang.Appendable */

// JVM method = joinTo([SLjava/lang/Appendable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
fun <A : Appendable /* = java.lang.Appendable */> ShortArray.joinTo(buffer: A : Appendable /* = java.lang.Appendable */, separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Short) -> CharSequence)? /* = default */): A : Appendable /* = java.lang.Appendable */

// JVM method = joinToString([Ljava/lang/Object;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
fun <T> Array<out T>.joinToString(separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((T) -> CharSequence)? /* = default */): String

// JVM method = joinToString([ZLjava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
fun BooleanArray.joinToString(separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Boolean) -> CharSequence)? /* = default */): String

// JVM method = joinToString([BLjava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
fun ByteArray.joinToString(separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Byte) -> CharSequence)? /* = default */): String

// JVM method = joinToString([CLjava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
fun CharArray.joinToString(separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Char) -> CharSequence)? /* = default */): String

// JVM method = joinToString([DLjava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
fun DoubleArray.joinToString(separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Double) -> CharSequence)? /* = default */): String

// JVM method = joinToString([FLjava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
fun FloatArray.joinToString(separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Float) -> CharSequence)? /* = default */): String

// JVM method = joinToString([ILjava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
fun IntArray.joinToString(separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Int) -> CharSequence)? /* = default */): String

// JVM method = joinToString([JLjava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
fun LongArray.joinToString(separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Long) -> CharSequence)? /* = default */): String

// JVM method = joinToString([SLjava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
fun ShortArray.joinToString(separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((Short) -> CharSequence)? /* = default */): String

// JVM method = last([Ljava/lang/Object;)Ljava/lang/Object;
fun <T> Array<out T>.last(): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T

// JVM method = last([Z)Z
fun BooleanArray.last(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last([ZLkotlin/jvm/functions/Function1;)Z
inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean

// JVM method = last([B)B
fun ByteArray.last(): Byte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last([BLkotlin/jvm/functions/Function1;)B
inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte

// JVM method = last([C)C
fun CharArray.last(): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last([CLkotlin/jvm/functions/Function1;)C
inline fun CharArray.last(predicate: (Char) -> Boolean): Char

// JVM method = last([D)D
fun DoubleArray.last(): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last([DLkotlin/jvm/functions/Function1;)D
inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double

// JVM method = last([F)F
fun FloatArray.last(): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last([FLkotlin/jvm/functions/Function1;)F
inline fun FloatArray.last(predicate: (Float) -> Boolean): Float

// JVM method = last([I)I
fun IntArray.last(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last([ILkotlin/jvm/functions/Function1;)I
inline fun IntArray.last(predicate: (Int) -> Boolean): Int

// JVM method = last([J)J
fun LongArray.last(): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last([JLkotlin/jvm/functions/Function1;)J
inline fun LongArray.last(predicate: (Long) -> Boolean): Long

// JVM method = last([S)S
fun ShortArray.last(): Short

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last([SLkotlin/jvm/functions/Function1;)S
inline fun ShortArray.last(predicate: (Short) -> Boolean): Short

// JVM method = lastIndexOf([Ljava/lang/Object;Ljava/lang/Object;)I
fun <@kotlin.internal.OnlyInputTypes T> Array<out @kotlin.internal.OnlyInputTypes T>.lastIndexOf(element: @kotlin.internal.OnlyInputTypes T): Int

// JVM method = lastIndexOf([ZZ)I
fun BooleanArray.lastIndexOf(element: Boolean): Int

// JVM method = lastIndexOf([BB)I
fun ByteArray.lastIndexOf(element: Byte): Int

// JVM method = lastIndexOf([CC)I
fun CharArray.lastIndexOf(element: Char): Int

// JVM method = lastIndexOf([DD)I
fun DoubleArray.lastIndexOf(element: Double): Int

// JVM method = lastIndexOf([FF)I
fun FloatArray.lastIndexOf(element: Float): Int

// JVM method = lastIndexOf([II)I
fun IntArray.lastIndexOf(element: Int): Int

// JVM method = lastIndexOf([JJ)I
fun LongArray.lastIndexOf(element: Long): Int

// JVM method = lastIndexOf([SS)I
fun ShortArray.lastIndexOf(element: Short): Int

// JVM method = lastOrNull([Ljava/lang/Object;)Ljava/lang/Object;
fun <T> Array<out T>.lastOrNull(): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T?

// JVM method = lastOrNull([Z)Ljava/lang/Boolean;
fun BooleanArray.lastOrNull(): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Boolean;
inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean?

// JVM method = lastOrNull([B)Ljava/lang/Byte;
fun ByteArray.lastOrNull(): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull([BLkotlin/jvm/functions/Function1;)Ljava/lang/Byte;
inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte?

// JVM method = lastOrNull([C)Ljava/lang/Character;
fun CharArray.lastOrNull(): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull([CLkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char?

// JVM method = lastOrNull([D)Ljava/lang/Double;
fun DoubleArray.lastOrNull(): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull([DLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double?

// JVM method = lastOrNull([F)Ljava/lang/Float;
fun FloatArray.lastOrNull(): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull([FLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float?

// JVM method = lastOrNull([I)Ljava/lang/Integer;
fun IntArray.lastOrNull(): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull([ILkotlin/jvm/functions/Function1;)Ljava/lang/Integer;
inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int?

// JVM method = lastOrNull([J)Ljava/lang/Long;
fun LongArray.lastOrNull(): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull([JLkotlin/jvm/functions/Function1;)Ljava/lang/Long;
inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long?

// JVM method = lastOrNull([S)Ljava/lang/Short;
fun ShortArray.lastOrNull(): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull([SLkotlin/jvm/functions/Function1;)Ljava/lang/Short;
inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = map([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = map([ZLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = map([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = map([CLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> CharArray.map(transform: (Char) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = map([DLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = map([FLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> FloatArray.map(transform: (Float) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = map([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> IntArray.map(transform: (Int) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = map([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> LongArray.map(transform: (Long) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = map([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> ShortArray.map(transform: (Short) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexed([Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R> Array<out T>.mapIndexed(transform: (@ParameterName(name = "index") Int, T) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexed([ZLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> BooleanArray.mapIndexed(transform: (@ParameterName(name = "index") Int, Boolean) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexed([BLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> ByteArray.mapIndexed(transform: (@ParameterName(name = "index") Int, Byte) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexed([CLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> CharArray.mapIndexed(transform: (@ParameterName(name = "index") Int, Char) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexed([DLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> DoubleArray.mapIndexed(transform: (@ParameterName(name = "index") Int, Double) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexed([FLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> FloatArray.mapIndexed(transform: (@ParameterName(name = "index") Int, Float) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexed([ILkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> IntArray.mapIndexed(transform: (@ParameterName(name = "index") Int, Int) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexed([JLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> LongArray.mapIndexed(transform: (@ParameterName(name = "index") Int, Long) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexed([SLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> ShortArray.mapIndexed(transform: (@ParameterName(name = "index") Int, Short) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedNotNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (@ParameterName(name = "index") Int, T) -> R : Any?): List<R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedNotNullTo([Ljava/lang/Object;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, R : Any, C : MutableCollection<in R : Any>> Array<out T>.mapIndexedNotNullTo(destination: C : MutableCollection<in R : Any>, transform: (@ParameterName(name = "index") Int, T) -> R : Any?): C : MutableCollection<in R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedTo([Ljava/lang/Object;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, T) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedTo([ZLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Boolean) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedTo([BLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Byte) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedTo([CLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Char) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedTo([DLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Double) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedTo([FLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Float) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedTo([ILjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Int) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedTo([JLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Long) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedTo([SLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Short) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapNotNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R : Any?): List<R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapNotNullTo([Ljava/lang/Object;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, R : Any, C : MutableCollection<in R : Any>> Array<out T>.mapNotNullTo(destination: C : MutableCollection<in R : Any>, transform: (T) -> R : Any?): C : MutableCollection<in R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo([Ljava/lang/Object;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C : MutableCollection<in R>, transform: (T) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo([ZLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C : MutableCollection<in R>, transform: (Boolean) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo([BLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C : MutableCollection<in R>, transform: (Byte) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo([CLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C : MutableCollection<in R>, transform: (Char) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo([DLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C : MutableCollection<in R>, transform: (Double) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo([FLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C : MutableCollection<in R>, transform: (Float) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo([ILjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C : MutableCollection<in R>, transform: (Int) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo([JLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C : MutableCollection<in R>, transform: (Long) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo([SLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C : MutableCollection<in R>, transform: (Short) -> R): C : MutableCollection<in R>

// JVM method = maxOrThrow([Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Array<out T : Comparable<T>>.max(): T : Comparable<T>

// JVM method = maxOrThrow([Ljava/lang/Double;)D
fun Array<out Double>.max(): Double

// JVM method = maxOrThrow([Ljava/lang/Float;)F
fun Array<out Float>.max(): Float

// JVM method = maxOrThrow([B)B
fun ByteArray.max(): Byte

// JVM method = maxOrThrow([C)C
fun CharArray.max(): Char

// JVM method = maxOrThrow([D)D
fun DoubleArray.max(): Double

// JVM method = maxOrThrow([F)F
fun FloatArray.max(): Float

// JVM method = maxOrThrow([I)I
fun IntArray.max(): Int

// JVM method = maxOrThrow([J)J
fun LongArray.max(): Long

// JVM method = maxOrThrow([S)S
fun ShortArray.max(): Short

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R : Comparable<R>): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow([ZLkotlin/jvm/functions/Function1;)Z
inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R : Comparable<R>): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow([BLkotlin/jvm/functions/Function1;)B
inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R : Comparable<R>): Byte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow([CLkotlin/jvm/functions/Function1;)C
inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R : Comparable<R>): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow([DLkotlin/jvm/functions/Function1;)D
inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R : Comparable<R>): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow([FLkotlin/jvm/functions/Function1;)F
inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R : Comparable<R>): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow([ILkotlin/jvm/functions/Function1;)I
inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R : Comparable<R>): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow([JLkotlin/jvm/functions/Function1;)J
inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R : Comparable<R>): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow([SLkotlin/jvm/functions/Function1;)S
inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R : Comparable<R>): Short

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Array<out T>.maxByOrNull(selector: (T) -> R : Comparable<R>): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Boolean;
inline fun <R : Comparable<R>> BooleanArray.maxByOrNull(selector: (Boolean) -> R : Comparable<R>): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull([BLkotlin/jvm/functions/Function1;)Ljava/lang/Byte;
inline fun <R : Comparable<R>> ByteArray.maxByOrNull(selector: (Byte) -> R : Comparable<R>): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull([CLkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun <R : Comparable<R>> CharArray.maxByOrNull(selector: (Char) -> R : Comparable<R>): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull([DLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun <R : Comparable<R>> DoubleArray.maxByOrNull(selector: (Double) -> R : Comparable<R>): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull([FLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun <R : Comparable<R>> FloatArray.maxByOrNull(selector: (Float) -> R : Comparable<R>): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull([ILkotlin/jvm/functions/Function1;)Ljava/lang/Integer;
inline fun <R : Comparable<R>> IntArray.maxByOrNull(selector: (Int) -> R : Comparable<R>): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull([JLkotlin/jvm/functions/Function1;)Ljava/lang/Long;
inline fun <R : Comparable<R>> LongArray.maxByOrNull(selector: (Long) -> R : Comparable<R>): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull([SLkotlin/jvm/functions/Function1;)Ljava/lang/Short;
inline fun <R : Comparable<R>> ShortArray.maxByOrNull(selector: (Short) -> R : Comparable<R>): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <T, R : Comparable<R>> Array<out T>.maxOf(selector: (T) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)D
inline fun <T> Array<out T>.maxOf(selector: (T) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)F
inline fun <T> Array<out T>.maxOf(selector: (T) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> BooleanArray.maxOf(selector: (Boolean) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([ZLkotlin/jvm/functions/Function1;)D
inline fun BooleanArray.maxOf(selector: (Boolean) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([ZLkotlin/jvm/functions/Function1;)F
inline fun BooleanArray.maxOf(selector: (Boolean) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([BLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> ByteArray.maxOf(selector: (Byte) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([BLkotlin/jvm/functions/Function1;)D
inline fun ByteArray.maxOf(selector: (Byte) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([BLkotlin/jvm/functions/Function1;)F
inline fun ByteArray.maxOf(selector: (Byte) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([CLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> CharArray.maxOf(selector: (Char) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([CLkotlin/jvm/functions/Function1;)D
inline fun CharArray.maxOf(selector: (Char) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([CLkotlin/jvm/functions/Function1;)F
inline fun CharArray.maxOf(selector: (Char) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([DLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> DoubleArray.maxOf(selector: (Double) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([DLkotlin/jvm/functions/Function1;)D
inline fun DoubleArray.maxOf(selector: (Double) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([DLkotlin/jvm/functions/Function1;)F
inline fun DoubleArray.maxOf(selector: (Double) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([FLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> FloatArray.maxOf(selector: (Float) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([FLkotlin/jvm/functions/Function1;)D
inline fun FloatArray.maxOf(selector: (Float) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([FLkotlin/jvm/functions/Function1;)F
inline fun FloatArray.maxOf(selector: (Float) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([ILkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> IntArray.maxOf(selector: (Int) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([ILkotlin/jvm/functions/Function1;)D
inline fun IntArray.maxOf(selector: (Int) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([ILkotlin/jvm/functions/Function1;)F
inline fun IntArray.maxOf(selector: (Int) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([JLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> LongArray.maxOf(selector: (Long) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([JLkotlin/jvm/functions/Function1;)D
inline fun LongArray.maxOf(selector: (Long) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([JLkotlin/jvm/functions/Function1;)F
inline fun LongArray.maxOf(selector: (Long) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([SLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> ShortArray.maxOf(selector: (Short) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([SLkotlin/jvm/functions/Function1;)D
inline fun ShortArray.maxOf(selector: (Short) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf([SLkotlin/jvm/functions/Function1;)F
inline fun ShortArray.maxOf(selector: (Short) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <T, R : Comparable<R>> Array<out T>.maxOfOrNull(selector: (T) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> BooleanArray.maxOfOrNull(selector: (Boolean) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([BLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> ByteArray.maxOfOrNull(selector: (Byte) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([BLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([BLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([CLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> CharArray.maxOfOrNull(selector: (Char) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([CLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun CharArray.maxOfOrNull(selector: (Char) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([CLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun CharArray.maxOfOrNull(selector: (Char) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([DLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> DoubleArray.maxOfOrNull(selector: (Double) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([DLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([DLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([FLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> FloatArray.maxOfOrNull(selector: (Float) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([FLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([FLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun FloatArray.maxOfOrNull(selector: (Float) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([ILkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> IntArray.maxOfOrNull(selector: (Int) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([ILkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun IntArray.maxOfOrNull(selector: (Int) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([ILkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([JLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> LongArray.maxOfOrNull(selector: (Long) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([JLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun LongArray.maxOfOrNull(selector: (Long) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([JLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([SLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> ShortArray.maxOfOrNull(selector: (Short) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([SLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun ShortArray.maxOfOrNull(selector: (Short) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull([SLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith([Ljava/lang/Object;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> Array<out T>.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (T) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith([ZLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> BooleanArray.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Boolean) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith([BLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> ByteArray.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Byte) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith([CLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> CharArray.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Char) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith([DLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> DoubleArray.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Double) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith([FLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> FloatArray.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Float) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith([ILjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> IntArray.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Int) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith([JLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> LongArray.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Long) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith([SLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> ShortArray.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Short) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull([Ljava/lang/Object;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> Array<out T>.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (T) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull([ZLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> BooleanArray.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Boolean) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull([BLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> ByteArray.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Byte) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull([CLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> CharArray.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Char) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull([DLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> DoubleArray.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Double) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull([FLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> FloatArray.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Float) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull([ILjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> IntArray.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Int) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull([JLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> LongArray.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Long) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull([SLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> ShortArray.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Short) -> R): R?

// JVM method = maxOrNull([Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Array<out T : Comparable<T>>.maxOrNull(): T : Comparable<T>?

// JVM method = maxOrNull([Ljava/lang/Double;)Ljava/lang/Double;
fun Array<out Double>.maxOrNull(): Double?

// JVM method = maxOrNull([Ljava/lang/Float;)Ljava/lang/Float;
fun Array<out Float>.maxOrNull(): Float?

// JVM method = maxOrNull([B)Ljava/lang/Byte;
fun ByteArray.maxOrNull(): Byte?

// JVM method = maxOrNull([C)Ljava/lang/Character;
fun CharArray.maxOrNull(): Char?

// JVM method = maxOrNull([D)Ljava/lang/Double;
fun DoubleArray.maxOrNull(): Double?

// JVM method = maxOrNull([F)Ljava/lang/Float;
fun FloatArray.maxOrNull(): Float?

// JVM method = maxOrNull([I)Ljava/lang/Integer;
fun IntArray.maxOrNull(): Int?

// JVM method = maxOrNull([J)Ljava/lang/Long;
fun LongArray.maxOrNull(): Long?

// JVM method = maxOrNull([S)Ljava/lang/Short;
fun ShortArray.maxOrNull(): Short?

// JVM method = maxWithOrThrow([Ljava/lang/Object;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Array<out T>.maxWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T

// JVM method = maxWithOrThrow([ZLjava/util/Comparator;)Z
fun BooleanArray.maxWith(comparator: Comparator<in Boolean> /* = java.util.Comparator<in Boolean> */): Boolean

// JVM method = maxWithOrThrow([BLjava/util/Comparator;)B
fun ByteArray.maxWith(comparator: Comparator<in Byte> /* = java.util.Comparator<in Byte> */): Byte

// JVM method = maxWithOrThrow([CLjava/util/Comparator;)C
fun CharArray.maxWith(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): Char

// JVM method = maxWithOrThrow([DLjava/util/Comparator;)D
fun DoubleArray.maxWith(comparator: Comparator<in Double> /* = java.util.Comparator<in Double> */): Double

// JVM method = maxWithOrThrow([FLjava/util/Comparator;)F
fun FloatArray.maxWith(comparator: Comparator<in Float> /* = java.util.Comparator<in Float> */): Float

// JVM method = maxWithOrThrow([ILjava/util/Comparator;)I
fun IntArray.maxWith(comparator: Comparator<in Int> /* = java.util.Comparator<in Int> */): Int

// JVM method = maxWithOrThrow([JLjava/util/Comparator;)J
fun LongArray.maxWith(comparator: Comparator<in Long> /* = java.util.Comparator<in Long> */): Long

// JVM method = maxWithOrThrow([SLjava/util/Comparator;)S
fun ShortArray.maxWith(comparator: Comparator<in Short> /* = java.util.Comparator<in Short> */): Short

// JVM method = maxWithOrNull([Ljava/lang/Object;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Array<out T>.maxWithOrNull(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T?

// JVM method = maxWithOrNull([ZLjava/util/Comparator;)Ljava/lang/Boolean;
fun BooleanArray.maxWithOrNull(comparator: Comparator<in Boolean> /* = java.util.Comparator<in Boolean> */): Boolean?

// JVM method = maxWithOrNull([BLjava/util/Comparator;)Ljava/lang/Byte;
fun ByteArray.maxWithOrNull(comparator: Comparator<in Byte> /* = java.util.Comparator<in Byte> */): Byte?

// JVM method = maxWithOrNull([CLjava/util/Comparator;)Ljava/lang/Character;
fun CharArray.maxWithOrNull(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): Char?

// JVM method = maxWithOrNull([DLjava/util/Comparator;)Ljava/lang/Double;
fun DoubleArray.maxWithOrNull(comparator: Comparator<in Double> /* = java.util.Comparator<in Double> */): Double?

// JVM method = maxWithOrNull([FLjava/util/Comparator;)Ljava/lang/Float;
fun FloatArray.maxWithOrNull(comparator: Comparator<in Float> /* = java.util.Comparator<in Float> */): Float?

// JVM method = maxWithOrNull([ILjava/util/Comparator;)Ljava/lang/Integer;
fun IntArray.maxWithOrNull(comparator: Comparator<in Int> /* = java.util.Comparator<in Int> */): Int?

// JVM method = maxWithOrNull([JLjava/util/Comparator;)Ljava/lang/Long;
fun LongArray.maxWithOrNull(comparator: Comparator<in Long> /* = java.util.Comparator<in Long> */): Long?

// JVM method = maxWithOrNull([SLjava/util/Comparator;)Ljava/lang/Short;
fun ShortArray.maxWithOrNull(comparator: Comparator<in Short> /* = java.util.Comparator<in Short> */): Short?

// JVM method = minOrThrow([Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Array<out T : Comparable<T>>.min(): T : Comparable<T>

// JVM method = minOrThrow([Ljava/lang/Double;)D
fun Array<out Double>.min(): Double

// JVM method = minOrThrow([Ljava/lang/Float;)F
fun Array<out Float>.min(): Float

// JVM method = minOrThrow([B)B
fun ByteArray.min(): Byte

// JVM method = minOrThrow([C)C
fun CharArray.min(): Char

// JVM method = minOrThrow([D)D
fun DoubleArray.min(): Double

// JVM method = minOrThrow([F)F
fun FloatArray.min(): Float

// JVM method = minOrThrow([I)I
fun IntArray.min(): Int

// JVM method = minOrThrow([J)J
fun LongArray.min(): Long

// JVM method = minOrThrow([S)S
fun ShortArray.min(): Short

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R : Comparable<R>): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow([ZLkotlin/jvm/functions/Function1;)Z
inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R : Comparable<R>): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow([BLkotlin/jvm/functions/Function1;)B
inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R : Comparable<R>): Byte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow([CLkotlin/jvm/functions/Function1;)C
inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R : Comparable<R>): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow([DLkotlin/jvm/functions/Function1;)D
inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R : Comparable<R>): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow([FLkotlin/jvm/functions/Function1;)F
inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R : Comparable<R>): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow([ILkotlin/jvm/functions/Function1;)I
inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R : Comparable<R>): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow([JLkotlin/jvm/functions/Function1;)J
inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R : Comparable<R>): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow([SLkotlin/jvm/functions/Function1;)S
inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R : Comparable<R>): Short

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Array<out T>.minByOrNull(selector: (T) -> R : Comparable<R>): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Boolean;
inline fun <R : Comparable<R>> BooleanArray.minByOrNull(selector: (Boolean) -> R : Comparable<R>): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull([BLkotlin/jvm/functions/Function1;)Ljava/lang/Byte;
inline fun <R : Comparable<R>> ByteArray.minByOrNull(selector: (Byte) -> R : Comparable<R>): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull([CLkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun <R : Comparable<R>> CharArray.minByOrNull(selector: (Char) -> R : Comparable<R>): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull([DLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun <R : Comparable<R>> DoubleArray.minByOrNull(selector: (Double) -> R : Comparable<R>): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull([FLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun <R : Comparable<R>> FloatArray.minByOrNull(selector: (Float) -> R : Comparable<R>): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull([ILkotlin/jvm/functions/Function1;)Ljava/lang/Integer;
inline fun <R : Comparable<R>> IntArray.minByOrNull(selector: (Int) -> R : Comparable<R>): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull([JLkotlin/jvm/functions/Function1;)Ljava/lang/Long;
inline fun <R : Comparable<R>> LongArray.minByOrNull(selector: (Long) -> R : Comparable<R>): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull([SLkotlin/jvm/functions/Function1;)Ljava/lang/Short;
inline fun <R : Comparable<R>> ShortArray.minByOrNull(selector: (Short) -> R : Comparable<R>): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <T, R : Comparable<R>> Array<out T>.minOf(selector: (T) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)D
inline fun <T> Array<out T>.minOf(selector: (T) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)F
inline fun <T> Array<out T>.minOf(selector: (T) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> BooleanArray.minOf(selector: (Boolean) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([ZLkotlin/jvm/functions/Function1;)D
inline fun BooleanArray.minOf(selector: (Boolean) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([ZLkotlin/jvm/functions/Function1;)F
inline fun BooleanArray.minOf(selector: (Boolean) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([BLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> ByteArray.minOf(selector: (Byte) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([BLkotlin/jvm/functions/Function1;)D
inline fun ByteArray.minOf(selector: (Byte) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([BLkotlin/jvm/functions/Function1;)F
inline fun ByteArray.minOf(selector: (Byte) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([CLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> CharArray.minOf(selector: (Char) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([CLkotlin/jvm/functions/Function1;)D
inline fun CharArray.minOf(selector: (Char) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([CLkotlin/jvm/functions/Function1;)F
inline fun CharArray.minOf(selector: (Char) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([DLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> DoubleArray.minOf(selector: (Double) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([DLkotlin/jvm/functions/Function1;)D
inline fun DoubleArray.minOf(selector: (Double) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([DLkotlin/jvm/functions/Function1;)F
inline fun DoubleArray.minOf(selector: (Double) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([FLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> FloatArray.minOf(selector: (Float) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([FLkotlin/jvm/functions/Function1;)D
inline fun FloatArray.minOf(selector: (Float) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([FLkotlin/jvm/functions/Function1;)F
inline fun FloatArray.minOf(selector: (Float) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([ILkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> IntArray.minOf(selector: (Int) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([ILkotlin/jvm/functions/Function1;)D
inline fun IntArray.minOf(selector: (Int) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([ILkotlin/jvm/functions/Function1;)F
inline fun IntArray.minOf(selector: (Int) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([JLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> LongArray.minOf(selector: (Long) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([JLkotlin/jvm/functions/Function1;)D
inline fun LongArray.minOf(selector: (Long) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([JLkotlin/jvm/functions/Function1;)F
inline fun LongArray.minOf(selector: (Long) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([SLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> ShortArray.minOf(selector: (Short) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([SLkotlin/jvm/functions/Function1;)D
inline fun ShortArray.minOf(selector: (Short) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf([SLkotlin/jvm/functions/Function1;)F
inline fun ShortArray.minOf(selector: (Short) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <T, R : Comparable<R>> Array<out T>.minOfOrNull(selector: (T) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> BooleanArray.minOfOrNull(selector: (Boolean) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([BLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> ByteArray.minOfOrNull(selector: (Byte) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([BLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun ByteArray.minOfOrNull(selector: (Byte) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([BLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun ByteArray.minOfOrNull(selector: (Byte) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([CLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> CharArray.minOfOrNull(selector: (Char) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([CLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun CharArray.minOfOrNull(selector: (Char) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([CLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun CharArray.minOfOrNull(selector: (Char) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([DLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> DoubleArray.minOfOrNull(selector: (Double) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([DLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun DoubleArray.minOfOrNull(selector: (Double) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([DLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun DoubleArray.minOfOrNull(selector: (Double) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([FLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> FloatArray.minOfOrNull(selector: (Float) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([FLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun FloatArray.minOfOrNull(selector: (Float) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([FLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun FloatArray.minOfOrNull(selector: (Float) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([ILkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> IntArray.minOfOrNull(selector: (Int) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([ILkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun IntArray.minOfOrNull(selector: (Int) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([ILkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun IntArray.minOfOrNull(selector: (Int) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([JLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> LongArray.minOfOrNull(selector: (Long) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([JLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun LongArray.minOfOrNull(selector: (Long) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([JLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun LongArray.minOfOrNull(selector: (Long) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([SLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> ShortArray.minOfOrNull(selector: (Short) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([SLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun ShortArray.minOfOrNull(selector: (Short) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull([SLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun ShortArray.minOfOrNull(selector: (Short) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith([Ljava/lang/Object;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> Array<out T>.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (T) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith([ZLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> BooleanArray.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Boolean) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith([BLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> ByteArray.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Byte) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith([CLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> CharArray.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Char) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith([DLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> DoubleArray.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Double) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith([FLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> FloatArray.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Float) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith([ILjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> IntArray.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Int) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith([JLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> LongArray.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Long) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith([SLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> ShortArray.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Short) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull([Ljava/lang/Object;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> Array<out T>.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (T) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull([ZLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> BooleanArray.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Boolean) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull([BLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> ByteArray.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Byte) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull([CLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> CharArray.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Char) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull([DLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> DoubleArray.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Double) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull([FLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> FloatArray.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Float) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull([ILjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> IntArray.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Int) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull([JLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> LongArray.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Long) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull([SLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> ShortArray.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Short) -> R): R?

// JVM method = minOrNull([Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Array<out T : Comparable<T>>.minOrNull(): T : Comparable<T>?

// JVM method = minOrNull([Ljava/lang/Double;)Ljava/lang/Double;
fun Array<out Double>.minOrNull(): Double?

// JVM method = minOrNull([Ljava/lang/Float;)Ljava/lang/Float;
fun Array<out Float>.minOrNull(): Float?

// JVM method = minOrNull([B)Ljava/lang/Byte;
fun ByteArray.minOrNull(): Byte?

// JVM method = minOrNull([C)Ljava/lang/Character;
fun CharArray.minOrNull(): Char?

// JVM method = minOrNull([D)Ljava/lang/Double;
fun DoubleArray.minOrNull(): Double?

// JVM method = minOrNull([F)Ljava/lang/Float;
fun FloatArray.minOrNull(): Float?

// JVM method = minOrNull([I)Ljava/lang/Integer;
fun IntArray.minOrNull(): Int?

// JVM method = minOrNull([J)Ljava/lang/Long;
fun LongArray.minOrNull(): Long?

// JVM method = minOrNull([S)Ljava/lang/Short;
fun ShortArray.minOrNull(): Short?

// JVM method = minWithOrThrow([Ljava/lang/Object;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Array<out T>.minWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T

// JVM method = minWithOrThrow([ZLjava/util/Comparator;)Z
fun BooleanArray.minWith(comparator: Comparator<in Boolean> /* = java.util.Comparator<in Boolean> */): Boolean

// JVM method = minWithOrThrow([BLjava/util/Comparator;)B
fun ByteArray.minWith(comparator: Comparator<in Byte> /* = java.util.Comparator<in Byte> */): Byte

// JVM method = minWithOrThrow([CLjava/util/Comparator;)C
fun CharArray.minWith(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): Char

// JVM method = minWithOrThrow([DLjava/util/Comparator;)D
fun DoubleArray.minWith(comparator: Comparator<in Double> /* = java.util.Comparator<in Double> */): Double

// JVM method = minWithOrThrow([FLjava/util/Comparator;)F
fun FloatArray.minWith(comparator: Comparator<in Float> /* = java.util.Comparator<in Float> */): Float

// JVM method = minWithOrThrow([ILjava/util/Comparator;)I
fun IntArray.minWith(comparator: Comparator<in Int> /* = java.util.Comparator<in Int> */): Int

// JVM method = minWithOrThrow([JLjava/util/Comparator;)J
fun LongArray.minWith(comparator: Comparator<in Long> /* = java.util.Comparator<in Long> */): Long

// JVM method = minWithOrThrow([SLjava/util/Comparator;)S
fun ShortArray.minWith(comparator: Comparator<in Short> /* = java.util.Comparator<in Short> */): Short

// JVM method = minWithOrNull([Ljava/lang/Object;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Array<out T>.minWithOrNull(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T?

// JVM method = minWithOrNull([ZLjava/util/Comparator;)Ljava/lang/Boolean;
fun BooleanArray.minWithOrNull(comparator: Comparator<in Boolean> /* = java.util.Comparator<in Boolean> */): Boolean?

// JVM method = minWithOrNull([BLjava/util/Comparator;)Ljava/lang/Byte;
fun ByteArray.minWithOrNull(comparator: Comparator<in Byte> /* = java.util.Comparator<in Byte> */): Byte?

// JVM method = minWithOrNull([CLjava/util/Comparator;)Ljava/lang/Character;
fun CharArray.minWithOrNull(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): Char?

// JVM method = minWithOrNull([DLjava/util/Comparator;)Ljava/lang/Double;
fun DoubleArray.minWithOrNull(comparator: Comparator<in Double> /* = java.util.Comparator<in Double> */): Double?

// JVM method = minWithOrNull([FLjava/util/Comparator;)Ljava/lang/Float;
fun FloatArray.minWithOrNull(comparator: Comparator<in Float> /* = java.util.Comparator<in Float> */): Float?

// JVM method = minWithOrNull([ILjava/util/Comparator;)Ljava/lang/Integer;
fun IntArray.minWithOrNull(comparator: Comparator<in Int> /* = java.util.Comparator<in Int> */): Int?

// JVM method = minWithOrNull([JLjava/util/Comparator;)Ljava/lang/Long;
fun LongArray.minWithOrNull(comparator: Comparator<in Long> /* = java.util.Comparator<in Long> */): Long?

// JVM method = minWithOrNull([SLjava/util/Comparator;)Ljava/lang/Short;
fun ShortArray.minWithOrNull(comparator: Comparator<in Short> /* = java.util.Comparator<in Short> */): Short?

// JVM method = none([Ljava/lang/Object;)Z
fun <T> Array<out T>.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Z
inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean

// JVM method = none([Z)Z
fun BooleanArray.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none([ZLkotlin/jvm/functions/Function1;)Z
inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean

// JVM method = none([B)Z
fun ByteArray.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none([BLkotlin/jvm/functions/Function1;)Z
inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean

// JVM method = none([C)Z
fun CharArray.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none([CLkotlin/jvm/functions/Function1;)Z
inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean

// JVM method = none([D)Z
fun DoubleArray.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none([DLkotlin/jvm/functions/Function1;)Z
inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean

// JVM method = none([F)Z
fun FloatArray.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none([FLkotlin/jvm/functions/Function1;)Z
inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean

// JVM method = none([I)Z
fun IntArray.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none([ILkotlin/jvm/functions/Function1;)Z
inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean

// JVM method = none([J)Z
fun LongArray.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none([JLkotlin/jvm/functions/Function1;)Z
inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean

// JVM method = none([S)Z
fun ShortArray.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none([SLkotlin/jvm/functions/Function1;)Z
inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEach([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)[Ljava/lang/Object;
inline fun <T> Array<out T>.onEach(action: (T) -> Unit): Array<out T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEach([ZLkotlin/jvm/functions/Function1;)[Z
inline fun BooleanArray.onEach(action: (Boolean) -> Unit): BooleanArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEach([BLkotlin/jvm/functions/Function1;)[B
inline fun ByteArray.onEach(action: (Byte) -> Unit): ByteArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEach([CLkotlin/jvm/functions/Function1;)[C
inline fun CharArray.onEach(action: (Char) -> Unit): CharArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEach([DLkotlin/jvm/functions/Function1;)[D
inline fun DoubleArray.onEach(action: (Double) -> Unit): DoubleArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEach([FLkotlin/jvm/functions/Function1;)[F
inline fun FloatArray.onEach(action: (Float) -> Unit): FloatArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEach([ILkotlin/jvm/functions/Function1;)[I
inline fun IntArray.onEach(action: (Int) -> Unit): IntArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEach([JLkotlin/jvm/functions/Function1;)[J
inline fun LongArray.onEach(action: (Long) -> Unit): LongArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEach([SLkotlin/jvm/functions/Function1;)[S
inline fun ShortArray.onEach(action: (Short) -> Unit): ShortArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEachIndexed([Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)[Ljava/lang/Object;
inline fun <T> Array<out T>.onEachIndexed(action: (@ParameterName(name = "index") Int, T) -> Unit): Array<out T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEachIndexed([ZLkotlin/jvm/functions/Function2;)[Z
inline fun BooleanArray.onEachIndexed(action: (@ParameterName(name = "index") Int, Boolean) -> Unit): BooleanArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEachIndexed([BLkotlin/jvm/functions/Function2;)[B
inline fun ByteArray.onEachIndexed(action: (@ParameterName(name = "index") Int, Byte) -> Unit): ByteArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEachIndexed([CLkotlin/jvm/functions/Function2;)[C
inline fun CharArray.onEachIndexed(action: (@ParameterName(name = "index") Int, Char) -> Unit): CharArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEachIndexed([DLkotlin/jvm/functions/Function2;)[D
inline fun DoubleArray.onEachIndexed(action: (@ParameterName(name = "index") Int, Double) -> Unit): DoubleArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEachIndexed([FLkotlin/jvm/functions/Function2;)[F
inline fun FloatArray.onEachIndexed(action: (@ParameterName(name = "index") Int, Float) -> Unit): FloatArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEachIndexed([ILkotlin/jvm/functions/Function2;)[I
inline fun IntArray.onEachIndexed(action: (@ParameterName(name = "index") Int, Int) -> Unit): IntArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEachIndexed([JLkotlin/jvm/functions/Function2;)[J
inline fun LongArray.onEachIndexed(action: (@ParameterName(name = "index") Int, Long) -> Unit): LongArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEachIndexed([SLkotlin/jvm/functions/Function2;)[S
inline fun ShortArray.onEachIndexed(action: (@ParameterName(name = "index") Int, Short) -> Unit): ShortArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition([ZLkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition([BLkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition([CLkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition([DLkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition([FLkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition([ILkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition([JLkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition([SLkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>>

// JVM method = random([Ljava/lang/Object;)Ljava/lang/Object;
inline fun <T> Array<out T>.random(): T

// JVM method = random([Ljava/lang/Object;Lkotlin/random/Random;)Ljava/lang/Object;
fun <T> Array<out T>.random(random: kotlin.random.Random): T

// JVM method = random([Z)Z
inline fun BooleanArray.random(): Boolean

// JVM method = random([ZLkotlin/random/Random;)Z
fun BooleanArray.random(random: kotlin.random.Random): Boolean

// JVM method = random([B)B
inline fun ByteArray.random(): Byte

// JVM method = random([BLkotlin/random/Random;)B
fun ByteArray.random(random: kotlin.random.Random): Byte

// JVM method = random([C)C
inline fun CharArray.random(): Char

// JVM method = random([CLkotlin/random/Random;)C
fun CharArray.random(random: kotlin.random.Random): Char

// JVM method = random([D)D
inline fun DoubleArray.random(): Double

// JVM method = random([DLkotlin/random/Random;)D
fun DoubleArray.random(random: kotlin.random.Random): Double

// JVM method = random([F)F
inline fun FloatArray.random(): Float

// JVM method = random([FLkotlin/random/Random;)F
fun FloatArray.random(random: kotlin.random.Random): Float

// JVM method = random([I)I
inline fun IntArray.random(): Int

// JVM method = random([ILkotlin/random/Random;)I
fun IntArray.random(random: kotlin.random.Random): Int

// JVM method = random([J)J
inline fun LongArray.random(): Long

// JVM method = random([JLkotlin/random/Random;)J
fun LongArray.random(random: kotlin.random.Random): Long

// JVM method = random([S)S
inline fun ShortArray.random(): Short

// JVM method = random([SLkotlin/random/Random;)S
fun ShortArray.random(random: kotlin.random.Random): Short

// JVM method = randomOrNull([Ljava/lang/Object;)Ljava/lang/Object;
inline fun <T> Array<out T>.randomOrNull(): T?

// JVM method = randomOrNull([Ljava/lang/Object;Lkotlin/random/Random;)Ljava/lang/Object;
fun <T> Array<out T>.randomOrNull(random: kotlin.random.Random): T?

// JVM method = randomOrNull([Z)Ljava/lang/Boolean;
inline fun BooleanArray.randomOrNull(): Boolean?

// JVM method = randomOrNull([ZLkotlin/random/Random;)Ljava/lang/Boolean;
fun BooleanArray.randomOrNull(random: kotlin.random.Random): Boolean?

// JVM method = randomOrNull([B)Ljava/lang/Byte;
inline fun ByteArray.randomOrNull(): Byte?

// JVM method = randomOrNull([BLkotlin/random/Random;)Ljava/lang/Byte;
fun ByteArray.randomOrNull(random: kotlin.random.Random): Byte?

// JVM method = randomOrNull([C)Ljava/lang/Character;
inline fun CharArray.randomOrNull(): Char?

// JVM method = randomOrNull([CLkotlin/random/Random;)Ljava/lang/Character;
fun CharArray.randomOrNull(random: kotlin.random.Random): Char?

// JVM method = randomOrNull([D)Ljava/lang/Double;
inline fun DoubleArray.randomOrNull(): Double?

// JVM method = randomOrNull([DLkotlin/random/Random;)Ljava/lang/Double;
fun DoubleArray.randomOrNull(random: kotlin.random.Random): Double?

// JVM method = randomOrNull([F)Ljava/lang/Float;
inline fun FloatArray.randomOrNull(): Float?

// JVM method = randomOrNull([FLkotlin/random/Random;)Ljava/lang/Float;
fun FloatArray.randomOrNull(random: kotlin.random.Random): Float?

// JVM method = randomOrNull([I)Ljava/lang/Integer;
inline fun IntArray.randomOrNull(): Int?

// JVM method = randomOrNull([ILkotlin/random/Random;)Ljava/lang/Integer;
fun IntArray.randomOrNull(random: kotlin.random.Random): Int?

// JVM method = randomOrNull([J)Ljava/lang/Long;
inline fun LongArray.randomOrNull(): Long?

// JVM method = randomOrNull([JLkotlin/random/Random;)Ljava/lang/Long;
fun LongArray.randomOrNull(random: kotlin.random.Random): Long?

// JVM method = randomOrNull([S)Ljava/lang/Short;
inline fun ShortArray.randomOrNull(): Short?

// JVM method = randomOrNull([SLkotlin/random/Random;)Ljava/lang/Short;
fun ShortArray.randomOrNull(random: kotlin.random.Random): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce([Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <S, T : S> Array<out T : S>.reduce(operation: (@ParameterName(name = "acc") S, T : S) -> S): S

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce([ZLkotlin/jvm/functions/Function2;)Z
inline fun BooleanArray.reduce(operation: (@ParameterName(name = "acc") Boolean, Boolean) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce([BLkotlin/jvm/functions/Function2;)B
inline fun ByteArray.reduce(operation: (@ParameterName(name = "acc") Byte, Byte) -> Byte): Byte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce([CLkotlin/jvm/functions/Function2;)C
inline fun CharArray.reduce(operation: (@ParameterName(name = "acc") Char, Char) -> Char): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce([DLkotlin/jvm/functions/Function2;)D
inline fun DoubleArray.reduce(operation: (@ParameterName(name = "acc") Double, Double) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce([FLkotlin/jvm/functions/Function2;)F
inline fun FloatArray.reduce(operation: (@ParameterName(name = "acc") Float, Float) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce([ILkotlin/jvm/functions/Function2;)I
inline fun IntArray.reduce(operation: (@ParameterName(name = "acc") Int, Int) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce([JLkotlin/jvm/functions/Function2;)J
inline fun LongArray.reduce(operation: (@ParameterName(name = "acc") Long, Long) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce([SLkotlin/jvm/functions/Function2;)S
inline fun ShortArray.reduce(operation: (@ParameterName(name = "acc") Short, Short) -> Short): Short

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexed([Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <S, T : S> Array<out T : S>.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") S, T : S) -> S): S

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexed([ZLkotlin/jvm/functions/Function3;)Z
inline fun BooleanArray.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Boolean, Boolean) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexed([BLkotlin/jvm/functions/Function3;)B
inline fun ByteArray.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Byte, Byte) -> Byte): Byte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexed([CLkotlin/jvm/functions/Function3;)C
inline fun CharArray.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Char, Char) -> Char): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexed([DLkotlin/jvm/functions/Function3;)D
inline fun DoubleArray.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Double, Double) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexed([FLkotlin/jvm/functions/Function3;)F
inline fun FloatArray.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Float, Float) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexed([ILkotlin/jvm/functions/Function3;)I
inline fun IntArray.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Int, Int) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexed([JLkotlin/jvm/functions/Function3;)J
inline fun LongArray.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Long, Long) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexed([SLkotlin/jvm/functions/Function3;)S
inline fun ShortArray.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Short, Short) -> Short): Short

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexedOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <S, T : S> Array<out T : S>.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") S, T : S) -> S): S?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexedOrNull([ZLkotlin/jvm/functions/Function3;)Ljava/lang/Boolean;
inline fun BooleanArray.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Boolean, Boolean) -> Boolean): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexedOrNull([BLkotlin/jvm/functions/Function3;)Ljava/lang/Byte;
inline fun ByteArray.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Byte, Byte) -> Byte): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexedOrNull([CLkotlin/jvm/functions/Function3;)Ljava/lang/Character;
inline fun CharArray.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Char, Char) -> Char): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexedOrNull([DLkotlin/jvm/functions/Function3;)Ljava/lang/Double;
inline fun DoubleArray.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Double, Double) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexedOrNull([FLkotlin/jvm/functions/Function3;)Ljava/lang/Float;
inline fun FloatArray.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Float, Float) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexedOrNull([ILkotlin/jvm/functions/Function3;)Ljava/lang/Integer;
inline fun IntArray.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Int, Int) -> Int): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexedOrNull([JLkotlin/jvm/functions/Function3;)Ljava/lang/Long;
inline fun LongArray.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Long, Long) -> Long): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexedOrNull([SLkotlin/jvm/functions/Function3;)Ljava/lang/Short;
inline fun ShortArray.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Short, Short) -> Short): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <S, T : S> Array<out T : S>.reduceOrNull(operation: (@ParameterName(name = "acc") S, T : S) -> S): S?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceOrNull([ZLkotlin/jvm/functions/Function2;)Ljava/lang/Boolean;
inline fun BooleanArray.reduceOrNull(operation: (@ParameterName(name = "acc") Boolean, Boolean) -> Boolean): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceOrNull([BLkotlin/jvm/functions/Function2;)Ljava/lang/Byte;
inline fun ByteArray.reduceOrNull(operation: (@ParameterName(name = "acc") Byte, Byte) -> Byte): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceOrNull([CLkotlin/jvm/functions/Function2;)Ljava/lang/Character;
inline fun CharArray.reduceOrNull(operation: (@ParameterName(name = "acc") Char, Char) -> Char): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceOrNull([DLkotlin/jvm/functions/Function2;)Ljava/lang/Double;
inline fun DoubleArray.reduceOrNull(operation: (@ParameterName(name = "acc") Double, Double) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceOrNull([FLkotlin/jvm/functions/Function2;)Ljava/lang/Float;
inline fun FloatArray.reduceOrNull(operation: (@ParameterName(name = "acc") Float, Float) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceOrNull([ILkotlin/jvm/functions/Function2;)Ljava/lang/Integer;
inline fun IntArray.reduceOrNull(operation: (@ParameterName(name = "acc") Int, Int) -> Int): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceOrNull([JLkotlin/jvm/functions/Function2;)Ljava/lang/Long;
inline fun LongArray.reduceOrNull(operation: (@ParameterName(name = "acc") Long, Long) -> Long): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceOrNull([SLkotlin/jvm/functions/Function2;)Ljava/lang/Short;
inline fun ShortArray.reduceOrNull(operation: (@ParameterName(name = "acc") Short, Short) -> Short): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRight([Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <S, T : S> Array<out T : S>.reduceRight(operation: (T : S, @ParameterName(name = "acc") S) -> S): S

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRight([ZLkotlin/jvm/functions/Function2;)Z
inline fun BooleanArray.reduceRight(operation: (Boolean, @ParameterName(name = "acc") Boolean) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRight([BLkotlin/jvm/functions/Function2;)B
inline fun ByteArray.reduceRight(operation: (Byte, @ParameterName(name = "acc") Byte) -> Byte): Byte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRight([CLkotlin/jvm/functions/Function2;)C
inline fun CharArray.reduceRight(operation: (Char, @ParameterName(name = "acc") Char) -> Char): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRight([DLkotlin/jvm/functions/Function2;)D
inline fun DoubleArray.reduceRight(operation: (Double, @ParameterName(name = "acc") Double) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRight([FLkotlin/jvm/functions/Function2;)F
inline fun FloatArray.reduceRight(operation: (Float, @ParameterName(name = "acc") Float) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRight([ILkotlin/jvm/functions/Function2;)I
inline fun IntArray.reduceRight(operation: (Int, @ParameterName(name = "acc") Int) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRight([JLkotlin/jvm/functions/Function2;)J
inline fun LongArray.reduceRight(operation: (Long, @ParameterName(name = "acc") Long) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRight([SLkotlin/jvm/functions/Function2;)S
inline fun ShortArray.reduceRight(operation: (Short, @ParameterName(name = "acc") Short) -> Short): Short

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexed([Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <S, T : S> Array<out T : S>.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, T : S, @ParameterName(name = "acc") S) -> S): S

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexed([ZLkotlin/jvm/functions/Function3;)Z
inline fun BooleanArray.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, Boolean, @ParameterName(name = "acc") Boolean) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexed([BLkotlin/jvm/functions/Function3;)B
inline fun ByteArray.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, Byte, @ParameterName(name = "acc") Byte) -> Byte): Byte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexed([CLkotlin/jvm/functions/Function3;)C
inline fun CharArray.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, Char, @ParameterName(name = "acc") Char) -> Char): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexed([DLkotlin/jvm/functions/Function3;)D
inline fun DoubleArray.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, Double, @ParameterName(name = "acc") Double) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexed([FLkotlin/jvm/functions/Function3;)F
inline fun FloatArray.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, Float, @ParameterName(name = "acc") Float) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexed([ILkotlin/jvm/functions/Function3;)I
inline fun IntArray.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, Int, @ParameterName(name = "acc") Int) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexed([JLkotlin/jvm/functions/Function3;)J
inline fun LongArray.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, Long, @ParameterName(name = "acc") Long) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexed([SLkotlin/jvm/functions/Function3;)S
inline fun ShortArray.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, Short, @ParameterName(name = "acc") Short) -> Short): Short

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <S, T : S> Array<out T : S>.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, T : S, @ParameterName(name = "acc") S) -> S): S?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull([ZLkotlin/jvm/functions/Function3;)Ljava/lang/Boolean;
inline fun BooleanArray.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, Boolean, @ParameterName(name = "acc") Boolean) -> Boolean): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull([BLkotlin/jvm/functions/Function3;)Ljava/lang/Byte;
inline fun ByteArray.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, Byte, @ParameterName(name = "acc") Byte) -> Byte): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull([CLkotlin/jvm/functions/Function3;)Ljava/lang/Character;
inline fun CharArray.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, Char, @ParameterName(name = "acc") Char) -> Char): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull([DLkotlin/jvm/functions/Function3;)Ljava/lang/Double;
inline fun DoubleArray.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, Double, @ParameterName(name = "acc") Double) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull([FLkotlin/jvm/functions/Function3;)Ljava/lang/Float;
inline fun FloatArray.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, Float, @ParameterName(name = "acc") Float) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull([ILkotlin/jvm/functions/Function3;)Ljava/lang/Integer;
inline fun IntArray.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, Int, @ParameterName(name = "acc") Int) -> Int): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull([JLkotlin/jvm/functions/Function3;)Ljava/lang/Long;
inline fun LongArray.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, Long, @ParameterName(name = "acc") Long) -> Long): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull([SLkotlin/jvm/functions/Function3;)Ljava/lang/Short;
inline fun ShortArray.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, Short, @ParameterName(name = "acc") Short) -> Short): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <S, T : S> Array<out T : S>.reduceRightOrNull(operation: (T : S, @ParameterName(name = "acc") S) -> S): S?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightOrNull([ZLkotlin/jvm/functions/Function2;)Ljava/lang/Boolean;
inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, @ParameterName(name = "acc") Boolean) -> Boolean): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightOrNull([BLkotlin/jvm/functions/Function2;)Ljava/lang/Byte;
inline fun ByteArray.reduceRightOrNull(operation: (Byte, @ParameterName(name = "acc") Byte) -> Byte): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightOrNull([CLkotlin/jvm/functions/Function2;)Ljava/lang/Character;
inline fun CharArray.reduceRightOrNull(operation: (Char, @ParameterName(name = "acc") Char) -> Char): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightOrNull([DLkotlin/jvm/functions/Function2;)Ljava/lang/Double;
inline fun DoubleArray.reduceRightOrNull(operation: (Double, @ParameterName(name = "acc") Double) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightOrNull([FLkotlin/jvm/functions/Function2;)Ljava/lang/Float;
inline fun FloatArray.reduceRightOrNull(operation: (Float, @ParameterName(name = "acc") Float) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightOrNull([ILkotlin/jvm/functions/Function2;)Ljava/lang/Integer;
inline fun IntArray.reduceRightOrNull(operation: (Int, @ParameterName(name = "acc") Int) -> Int): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightOrNull([JLkotlin/jvm/functions/Function2;)Ljava/lang/Long;
inline fun LongArray.reduceRightOrNull(operation: (Long, @ParameterName(name = "acc") Long) -> Long): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightOrNull([SLkotlin/jvm/functions/Function2;)Ljava/lang/Short;
inline fun ShortArray.reduceRightOrNull(operation: (Short, @ParameterName(name = "acc") Short) -> Short): Short?

// JVM method = requireNoNulls([Ljava/lang/Object;)[Ljava/lang/Object;
fun <T : Any> Array<T : Any?>.requireNoNulls(): Array<T : Any>

// JVM method = reverse([Ljava/lang/Object;)V
fun <T> Array<T>.reverse()

// JVM method = reverse([Ljava/lang/Object;II)V
fun <T> Array<T>.reverse(fromIndex: Int, toIndex: Int)

// JVM method = reverse([Z)V
fun BooleanArray.reverse()

// JVM method = reverse([ZII)V
fun BooleanArray.reverse(fromIndex: Int, toIndex: Int)

// JVM method = reverse([B)V
fun ByteArray.reverse()

// JVM method = reverse([BII)V
fun ByteArray.reverse(fromIndex: Int, toIndex: Int)

// JVM method = reverse([C)V
fun CharArray.reverse()

// JVM method = reverse([CII)V
fun CharArray.reverse(fromIndex: Int, toIndex: Int)

// JVM method = reverse([D)V
fun DoubleArray.reverse()

// JVM method = reverse([DII)V
fun DoubleArray.reverse(fromIndex: Int, toIndex: Int)

// JVM method = reverse([F)V
fun FloatArray.reverse()

// JVM method = reverse([FII)V
fun FloatArray.reverse(fromIndex: Int, toIndex: Int)

// JVM method = reverse([I)V
fun IntArray.reverse()

// JVM method = reverse([III)V
fun IntArray.reverse(fromIndex: Int, toIndex: Int)

// JVM method = reverse([J)V
fun LongArray.reverse()

// JVM method = reverse([JII)V
fun LongArray.reverse(fromIndex: Int, toIndex: Int)

// JVM method = reverse([S)V
fun ShortArray.reverse()

// JVM method = reverse([SII)V
fun ShortArray.reverse(fromIndex: Int, toIndex: Int)

// JVM method = reversed([Ljava/lang/Object;)Ljava/util/List;
fun <T> Array<out T>.reversed(): List<T>

// JVM method = reversed([Z)Ljava/util/List;
fun BooleanArray.reversed(): List<Boolean>

// JVM method = reversed([B)Ljava/util/List;
fun ByteArray.reversed(): List<Byte>

// JVM method = reversed([C)Ljava/util/List;
fun CharArray.reversed(): List<Char>

// JVM method = reversed([D)Ljava/util/List;
fun DoubleArray.reversed(): List<Double>

// JVM method = reversed([F)Ljava/util/List;
fun FloatArray.reversed(): List<Float>

// JVM method = reversed([I)Ljava/util/List;
fun IntArray.reversed(): List<Int>

// JVM method = reversed([J)Ljava/util/List;
fun LongArray.reversed(): List<Long>

// JVM method = reversed([S)Ljava/util/List;
fun ShortArray.reversed(): List<Short>

// JVM method = reversedArray([Ljava/lang/Object;)[Ljava/lang/Object;
fun <T> Array<T>.reversedArray(): Array<T>

// JVM method = reversedArray([Z)[Z
fun BooleanArray.reversedArray(): BooleanArray

// JVM method = reversedArray([B)[B
fun ByteArray.reversedArray(): ByteArray

// JVM method = reversedArray([C)[C
fun CharArray.reversedArray(): CharArray

// JVM method = reversedArray([D)[D
fun DoubleArray.reversedArray(): DoubleArray

// JVM method = reversedArray([F)[F
fun FloatArray.reversedArray(): FloatArray

// JVM method = reversedArray([I)[I
fun IntArray.reversedArray(): IntArray

// JVM method = reversedArray([J)[J
fun LongArray.reversedArray(): LongArray

// JVM method = reversedArray([S)[S
fun ShortArray.reversedArray(): ShortArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFold([Ljava/lang/Object;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R> Array<out T>.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, T) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFold([ZLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> BooleanArray.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, Boolean) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFold([BLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> ByteArray.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, Byte) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFold([CLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> CharArray.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, Char) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFold([DLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> DoubleArray.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, Double) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFold([FLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> FloatArray.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, Float) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFold([ILjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> IntArray.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, Int) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFold([JLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> LongArray.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, Long) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFold([SLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> ShortArray.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, Short) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFoldIndexed([Ljava/lang/Object;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <T, R> Array<out T>.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, T) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFoldIndexed([ZLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> BooleanArray.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Boolean) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFoldIndexed([BLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> ByteArray.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Byte) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFoldIndexed([CLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> CharArray.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Char) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFoldIndexed([DLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> DoubleArray.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Double) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFoldIndexed([FLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> FloatArray.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Float) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFoldIndexed([ILjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> IntArray.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Int) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFoldIndexed([JLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> LongArray.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Long) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFoldIndexed([SLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> ShortArray.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Short) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduce([Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <S, T : S> Array<out T : S>.runningReduce(operation: (@ParameterName(name = "acc") S, T : S) -> S): List<S>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduce([ZLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun BooleanArray.runningReduce(operation: (@ParameterName(name = "acc") Boolean, Boolean) -> Boolean): List<Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduce([BLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun ByteArray.runningReduce(operation: (@ParameterName(name = "acc") Byte, Byte) -> Byte): List<Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduce([CLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun CharArray.runningReduce(operation: (@ParameterName(name = "acc") Char, Char) -> Char): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduce([DLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun DoubleArray.runningReduce(operation: (@ParameterName(name = "acc") Double, Double) -> Double): List<Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduce([FLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun FloatArray.runningReduce(operation: (@ParameterName(name = "acc") Float, Float) -> Float): List<Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduce([ILkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun IntArray.runningReduce(operation: (@ParameterName(name = "acc") Int, Int) -> Int): List<Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduce([JLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun LongArray.runningReduce(operation: (@ParameterName(name = "acc") Long, Long) -> Long): List<Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduce([SLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun ShortArray.runningReduce(operation: (@ParameterName(name = "acc") Short, Short) -> Short): List<Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduceIndexed([Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <S, T : S> Array<out T : S>.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") S, T : S) -> S): List<S>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduceIndexed([ZLkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun BooleanArray.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Boolean, Boolean) -> Boolean): List<Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduceIndexed([BLkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun ByteArray.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Byte, Byte) -> Byte): List<Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduceIndexed([CLkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun CharArray.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Char, Char) -> Char): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduceIndexed([DLkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun DoubleArray.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Double, Double) -> Double): List<Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduceIndexed([FLkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun FloatArray.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Float, Float) -> Float): List<Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduceIndexed([ILkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun IntArray.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Int, Int) -> Int): List<Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduceIndexed([JLkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun LongArray.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Long, Long) -> Long): List<Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduceIndexed([SLkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun ShortArray.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Short, Short) -> Short): List<Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scan([Ljava/lang/Object;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R> Array<out T>.scan(initial: R, operation: (@ParameterName(name = "acc") R, T) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scan([ZLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> BooleanArray.scan(initial: R, operation: (@ParameterName(name = "acc") R, Boolean) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scan([BLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> ByteArray.scan(initial: R, operation: (@ParameterName(name = "acc") R, Byte) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scan([CLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> CharArray.scan(initial: R, operation: (@ParameterName(name = "acc") R, Char) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scan([DLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> DoubleArray.scan(initial: R, operation: (@ParameterName(name = "acc") R, Double) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scan([FLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> FloatArray.scan(initial: R, operation: (@ParameterName(name = "acc") R, Float) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scan([ILjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> IntArray.scan(initial: R, operation: (@ParameterName(name = "acc") R, Int) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scan([JLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> LongArray.scan(initial: R, operation: (@ParameterName(name = "acc") R, Long) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scan([SLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> ShortArray.scan(initial: R, operation: (@ParameterName(name = "acc") R, Short) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scanIndexed([Ljava/lang/Object;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, T) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scanIndexed([ZLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Boolean) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scanIndexed([BLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> ByteArray.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Byte) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scanIndexed([CLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> CharArray.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Char) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scanIndexed([DLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Double) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scanIndexed([FLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> FloatArray.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Float) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scanIndexed([ILjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> IntArray.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Int) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scanIndexed([JLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> LongArray.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Long) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scanIndexed([SLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> ShortArray.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Short) -> R): List<R>

// JVM method = shuffle([Ljava/lang/Object;)V
fun <T> Array<T>.shuffle()

// JVM method = shuffle([Ljava/lang/Object;Lkotlin/random/Random;)V
fun <T> Array<T>.shuffle(random: kotlin.random.Random)

// JVM method = shuffle([Z)V
fun BooleanArray.shuffle()

// JVM method = shuffle([ZLkotlin/random/Random;)V
fun BooleanArray.shuffle(random: kotlin.random.Random)

// JVM method = shuffle([B)V
fun ByteArray.shuffle()

// JVM method = shuffle([BLkotlin/random/Random;)V
fun ByteArray.shuffle(random: kotlin.random.Random)

// JVM method = shuffle([C)V
fun CharArray.shuffle()

// JVM method = shuffle([CLkotlin/random/Random;)V
fun CharArray.shuffle(random: kotlin.random.Random)

// JVM method = shuffle([D)V
fun DoubleArray.shuffle()

// JVM method = shuffle([DLkotlin/random/Random;)V
fun DoubleArray.shuffle(random: kotlin.random.Random)

// JVM method = shuffle([F)V
fun FloatArray.shuffle()

// JVM method = shuffle([FLkotlin/random/Random;)V
fun FloatArray.shuffle(random: kotlin.random.Random)

// JVM method = shuffle([I)V
fun IntArray.shuffle()

// JVM method = shuffle([ILkotlin/random/Random;)V
fun IntArray.shuffle(random: kotlin.random.Random)

// JVM method = shuffle([J)V
fun LongArray.shuffle()

// JVM method = shuffle([JLkotlin/random/Random;)V
fun LongArray.shuffle(random: kotlin.random.Random)

// JVM method = shuffle([S)V
fun ShortArray.shuffle()

// JVM method = shuffle([SLkotlin/random/Random;)V
fun ShortArray.shuffle(random: kotlin.random.Random)

// JVM method = single([Ljava/lang/Object;)Ljava/lang/Object;
fun <T> Array<out T>.single(): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = single([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T

// JVM method = single([Z)Z
fun BooleanArray.single(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = single([ZLkotlin/jvm/functions/Function1;)Z
inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean

// JVM method = single([B)B
fun ByteArray.single(): Byte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = single([BLkotlin/jvm/functions/Function1;)B
inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte

// JVM method = single([C)C
fun CharArray.single(): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = single([CLkotlin/jvm/functions/Function1;)C
inline fun CharArray.single(predicate: (Char) -> Boolean): Char

// JVM method = single([D)D
fun DoubleArray.single(): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = single([DLkotlin/jvm/functions/Function1;)D
inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double

// JVM method = single([F)F
fun FloatArray.single(): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = single([FLkotlin/jvm/functions/Function1;)F
inline fun FloatArray.single(predicate: (Float) -> Boolean): Float

// JVM method = single([I)I
fun IntArray.single(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = single([ILkotlin/jvm/functions/Function1;)I
inline fun IntArray.single(predicate: (Int) -> Boolean): Int

// JVM method = single([J)J
fun LongArray.single(): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = single([JLkotlin/jvm/functions/Function1;)J
inline fun LongArray.single(predicate: (Long) -> Boolean): Long

// JVM method = single([S)S
fun ShortArray.single(): Short

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = single([SLkotlin/jvm/functions/Function1;)S
inline fun ShortArray.single(predicate: (Short) -> Boolean): Short

// JVM method = singleOrNull([Ljava/lang/Object;)Ljava/lang/Object;
fun <T> Array<out T>.singleOrNull(): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = singleOrNull([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T?

// JVM method = singleOrNull([Z)Ljava/lang/Boolean;
fun BooleanArray.singleOrNull(): Boolean?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = singleOrNull([ZLkotlin/jvm/functions/Function1;)Ljava/lang/Boolean;
inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean?

// JVM method = singleOrNull([B)Ljava/lang/Byte;
fun ByteArray.singleOrNull(): Byte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = singleOrNull([BLkotlin/jvm/functions/Function1;)Ljava/lang/Byte;
inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte?

// JVM method = singleOrNull([C)Ljava/lang/Character;
fun CharArray.singleOrNull(): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = singleOrNull([CLkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char?

// JVM method = singleOrNull([D)Ljava/lang/Double;
fun DoubleArray.singleOrNull(): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = singleOrNull([DLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double?

// JVM method = singleOrNull([F)Ljava/lang/Float;
fun FloatArray.singleOrNull(): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = singleOrNull([FLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float?

// JVM method = singleOrNull([I)Ljava/lang/Integer;
fun IntArray.singleOrNull(): Int?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = singleOrNull([ILkotlin/jvm/functions/Function1;)Ljava/lang/Integer;
inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int?

// JVM method = singleOrNull([J)Ljava/lang/Long;
fun LongArray.singleOrNull(): Long?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = singleOrNull([JLkotlin/jvm/functions/Function1;)Ljava/lang/Long;
inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long?

// JVM method = singleOrNull([S)Ljava/lang/Short;
fun ShortArray.singleOrNull(): Short?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = singleOrNull([SLkotlin/jvm/functions/Function1;)Ljava/lang/Short;
inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short?

// JVM method = slice([Ljava/lang/Object;Ljava/lang/Iterable;)Ljava/util/List;
fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T>

// JVM method = slice([Ljava/lang/Object;Lkotlin/ranges/IntRange;)Ljava/util/List;
fun <T> Array<out T>.slice(indices: IntRange): List<T>

// JVM method = slice([ZLjava/lang/Iterable;)Ljava/util/List;
fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean>

// JVM method = slice([ZLkotlin/ranges/IntRange;)Ljava/util/List;
fun BooleanArray.slice(indices: IntRange): List<Boolean>

// JVM method = slice([BLjava/lang/Iterable;)Ljava/util/List;
fun ByteArray.slice(indices: Iterable<Int>): List<Byte>

// JVM method = slice([BLkotlin/ranges/IntRange;)Ljava/util/List;
fun ByteArray.slice(indices: IntRange): List<Byte>

// JVM method = slice([CLjava/lang/Iterable;)Ljava/util/List;
fun CharArray.slice(indices: Iterable<Int>): List<Char>

// JVM method = slice([CLkotlin/ranges/IntRange;)Ljava/util/List;
fun CharArray.slice(indices: IntRange): List<Char>

// JVM method = slice([DLjava/lang/Iterable;)Ljava/util/List;
fun DoubleArray.slice(indices: Iterable<Int>): List<Double>

// JVM method = slice([DLkotlin/ranges/IntRange;)Ljava/util/List;
fun DoubleArray.slice(indices: IntRange): List<Double>

// JVM method = slice([FLjava/lang/Iterable;)Ljava/util/List;
fun FloatArray.slice(indices: Iterable<Int>): List<Float>

// JVM method = slice([FLkotlin/ranges/IntRange;)Ljava/util/List;
fun FloatArray.slice(indices: IntRange): List<Float>

// JVM method = slice([ILjava/lang/Iterable;)Ljava/util/List;
fun IntArray.slice(indices: Iterable<Int>): List<Int>

// JVM method = slice([ILkotlin/ranges/IntRange;)Ljava/util/List;
fun IntArray.slice(indices: IntRange): List<Int>

// JVM method = slice([JLjava/lang/Iterable;)Ljava/util/List;
fun LongArray.slice(indices: Iterable<Int>): List<Long>

// JVM method = slice([JLkotlin/ranges/IntRange;)Ljava/util/List;
fun LongArray.slice(indices: IntRange): List<Long>

// JVM method = slice([SLjava/lang/Iterable;)Ljava/util/List;
fun ShortArray.slice(indices: Iterable<Int>): List<Short>

// JVM method = slice([SLkotlin/ranges/IntRange;)Ljava/util/List;
fun ShortArray.slice(indices: IntRange): List<Short>

// JVM method = sliceArray([Ljava/lang/Object;Ljava/util/Collection;)[Ljava/lang/Object;
fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T>

// JVM method = sliceArray([Ljava/lang/Object;Lkotlin/ranges/IntRange;)[Ljava/lang/Object;
fun <T> Array<T>.sliceArray(indices: IntRange): Array<T>

// JVM method = sliceArray([ZLjava/util/Collection;)[Z
fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray

// JVM method = sliceArray([ZLkotlin/ranges/IntRange;)[Z
fun BooleanArray.sliceArray(indices: IntRange): BooleanArray

// JVM method = sliceArray([BLjava/util/Collection;)[B
fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray

// JVM method = sliceArray([BLkotlin/ranges/IntRange;)[B
fun ByteArray.sliceArray(indices: IntRange): ByteArray

// JVM method = sliceArray([CLjava/util/Collection;)[C
fun CharArray.sliceArray(indices: Collection<Int>): CharArray

// JVM method = sliceArray([CLkotlin/ranges/IntRange;)[C
fun CharArray.sliceArray(indices: IntRange): CharArray

// JVM method = sliceArray([DLjava/util/Collection;)[D
fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray

// JVM method = sliceArray([DLkotlin/ranges/IntRange;)[D
fun DoubleArray.sliceArray(indices: IntRange): DoubleArray

// JVM method = sliceArray([FLjava/util/Collection;)[F
fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray

// JVM method = sliceArray([FLkotlin/ranges/IntRange;)[F
fun FloatArray.sliceArray(indices: IntRange): FloatArray

// JVM method = sliceArray([ILjava/util/Collection;)[I
fun IntArray.sliceArray(indices: Collection<Int>): IntArray

// JVM method = sliceArray([ILkotlin/ranges/IntRange;)[I
fun IntArray.sliceArray(indices: IntRange): IntArray

// JVM method = sliceArray([JLjava/util/Collection;)[J
fun LongArray.sliceArray(indices: Collection<Int>): LongArray

// JVM method = sliceArray([JLkotlin/ranges/IntRange;)[J
fun LongArray.sliceArray(indices: IntRange): LongArray

// JVM method = sliceArray([SLjava/util/Collection;)[S
fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray

// JVM method = sliceArray([SLkotlin/ranges/IntRange;)[S
fun ShortArray.sliceArray(indices: IntRange): ShortArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortBy([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)V
inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R : Comparable<R>?)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortByDescending([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)V
inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R : Comparable<R>?)

// JVM method = sortDescending([Ljava/lang/Comparable;)V
fun <T : Comparable<T>> Array<out T : Comparable<T>>.sortDescending()

// JVM method = sortDescending([Ljava/lang/Comparable;II)V
fun <T : Comparable<T>> Array<out T : Comparable<T>>.sortDescending(fromIndex: Int, toIndex: Int)

// JVM method = sortDescending([B)V
fun ByteArray.sortDescending()

// JVM method = sortDescending([BII)V
fun ByteArray.sortDescending(fromIndex: Int, toIndex: Int)

// JVM method = sortDescending([C)V
fun CharArray.sortDescending()

// JVM method = sortDescending([CII)V
fun CharArray.sortDescending(fromIndex: Int, toIndex: Int)

// JVM method = sortDescending([D)V
fun DoubleArray.sortDescending()

// JVM method = sortDescending([DII)V
fun DoubleArray.sortDescending(fromIndex: Int, toIndex: Int)

// JVM method = sortDescending([F)V
fun FloatArray.sortDescending()

// JVM method = sortDescending([FII)V
fun FloatArray.sortDescending(fromIndex: Int, toIndex: Int)

// JVM method = sortDescending([I)V
fun IntArray.sortDescending()

// JVM method = sortDescending([III)V
fun IntArray.sortDescending(fromIndex: Int, toIndex: Int)

// JVM method = sortDescending([J)V
fun LongArray.sortDescending()

// JVM method = sortDescending([JII)V
fun LongArray.sortDescending(fromIndex: Int, toIndex: Int)

// JVM method = sortDescending([S)V
fun ShortArray.sortDescending()

// JVM method = sortDescending([SII)V
fun ShortArray.sortDescending(fromIndex: Int, toIndex: Int)

// JVM method = sorted([Ljava/lang/Comparable;)Ljava/util/List;
fun <T : Comparable<T>> Array<out T : Comparable<T>>.sorted(): List<T : Comparable<T>>

// JVM method = sorted([B)Ljava/util/List;
fun ByteArray.sorted(): List<Byte>

// JVM method = sorted([C)Ljava/util/List;
fun CharArray.sorted(): List<Char>

// JVM method = sorted([D)Ljava/util/List;
fun DoubleArray.sorted(): List<Double>

// JVM method = sorted([F)Ljava/util/List;
fun FloatArray.sorted(): List<Float>

// JVM method = sorted([I)Ljava/util/List;
fun IntArray.sorted(): List<Int>

// JVM method = sorted([J)Ljava/util/List;
fun LongArray.sorted(): List<Long>

// JVM method = sorted([S)Ljava/util/List;
fun ShortArray.sorted(): List<Short>

// JVM method = sortedArray([Ljava/lang/Comparable;)[Ljava/lang/Comparable;
fun <T : Comparable<T>> Array<T : Comparable<T>>.sortedArray(): Array<T : Comparable<T>>

// JVM method = sortedArray([B)[B
fun ByteArray.sortedArray(): ByteArray

// JVM method = sortedArray([C)[C
fun CharArray.sortedArray(): CharArray

// JVM method = sortedArray([D)[D
fun DoubleArray.sortedArray(): DoubleArray

// JVM method = sortedArray([F)[F
fun FloatArray.sortedArray(): FloatArray

// JVM method = sortedArray([I)[I
fun IntArray.sortedArray(): IntArray

// JVM method = sortedArray([J)[J
fun LongArray.sortedArray(): LongArray

// JVM method = sortedArray([S)[S
fun ShortArray.sortedArray(): ShortArray

// JVM method = sortedArrayDescending([Ljava/lang/Comparable;)[Ljava/lang/Comparable;
fun <T : Comparable<T>> Array<T : Comparable<T>>.sortedArrayDescending(): Array<T : Comparable<T>>

// JVM method = sortedArrayDescending([B)[B
fun ByteArray.sortedArrayDescending(): ByteArray

// JVM method = sortedArrayDescending([C)[C
fun CharArray.sortedArrayDescending(): CharArray

// JVM method = sortedArrayDescending([D)[D
fun DoubleArray.sortedArrayDescending(): DoubleArray

// JVM method = sortedArrayDescending([F)[F
fun FloatArray.sortedArrayDescending(): FloatArray

// JVM method = sortedArrayDescending([I)[I
fun IntArray.sortedArrayDescending(): IntArray

// JVM method = sortedArrayDescending([J)[J
fun LongArray.sortedArrayDescending(): LongArray

// JVM method = sortedArrayDescending([S)[S
fun ShortArray.sortedArrayDescending(): ShortArray

// JVM method = sortedArrayWith([Ljava/lang/Object;Ljava/util/Comparator;)[Ljava/lang/Object;
fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): Array<out T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedBy([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R : Comparable<R>?): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedBy([ZLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R : Comparable<R>?): List<Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedBy([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R : Comparable<R>?): List<Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedBy([CLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R : Comparable<R>?): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedBy([DLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R : Comparable<R>?): List<Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedBy([FLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R : Comparable<R>?): List<Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedBy([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R : Comparable<R>?): List<Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedBy([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R : Comparable<R>?): List<Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedBy([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R : Comparable<R>?): List<Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedByDescending([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R : Comparable<R>?): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedByDescending([ZLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R : Comparable<R>?): List<Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedByDescending([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R : Comparable<R>?): List<Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedByDescending([CLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R : Comparable<R>?): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedByDescending([DLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R : Comparable<R>?): List<Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedByDescending([FLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R : Comparable<R>?): List<Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedByDescending([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R : Comparable<R>?): List<Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedByDescending([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R : Comparable<R>?): List<Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedByDescending([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R : Comparable<R>?): List<Short>

// JVM method = sortedDescending([Ljava/lang/Comparable;)Ljava/util/List;
fun <T : Comparable<T>> Array<out T : Comparable<T>>.sortedDescending(): List<T : Comparable<T>>

// JVM method = sortedDescending([B)Ljava/util/List;
fun ByteArray.sortedDescending(): List<Byte>

// JVM method = sortedDescending([C)Ljava/util/List;
fun CharArray.sortedDescending(): List<Char>

// JVM method = sortedDescending([D)Ljava/util/List;
fun DoubleArray.sortedDescending(): List<Double>

// JVM method = sortedDescending([F)Ljava/util/List;
fun FloatArray.sortedDescending(): List<Float>

// JVM method = sortedDescending([I)Ljava/util/List;
fun IntArray.sortedDescending(): List<Int>

// JVM method = sortedDescending([J)Ljava/util/List;
fun LongArray.sortedDescending(): List<Long>

// JVM method = sortedDescending([S)Ljava/util/List;
fun ShortArray.sortedDescending(): List<Short>

// JVM method = sortedWith([Ljava/lang/Object;Ljava/util/Comparator;)Ljava/util/List;
fun <T> Array<out T>.sortedWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): List<T>

// JVM method = sortedWith([ZLjava/util/Comparator;)Ljava/util/List;
fun BooleanArray.sortedWith(comparator: Comparator<in Boolean> /* = java.util.Comparator<in Boolean> */): List<Boolean>

// JVM method = sortedWith([BLjava/util/Comparator;)Ljava/util/List;
fun ByteArray.sortedWith(comparator: Comparator<in Byte> /* = java.util.Comparator<in Byte> */): List<Byte>

// JVM method = sortedWith([CLjava/util/Comparator;)Ljava/util/List;
fun CharArray.sortedWith(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): List<Char>

// JVM method = sortedWith([DLjava/util/Comparator;)Ljava/util/List;
fun DoubleArray.sortedWith(comparator: Comparator<in Double> /* = java.util.Comparator<in Double> */): List<Double>

// JVM method = sortedWith([FLjava/util/Comparator;)Ljava/util/List;
fun FloatArray.sortedWith(comparator: Comparator<in Float> /* = java.util.Comparator<in Float> */): List<Float>

// JVM method = sortedWith([ILjava/util/Comparator;)Ljava/util/List;
fun IntArray.sortedWith(comparator: Comparator<in Int> /* = java.util.Comparator<in Int> */): List<Int>

// JVM method = sortedWith([JLjava/util/Comparator;)Ljava/util/List;
fun LongArray.sortedWith(comparator: Comparator<in Long> /* = java.util.Comparator<in Long> */): List<Long>

// JVM method = sortedWith([SLjava/util/Comparator;)Ljava/util/List;
fun ShortArray.sortedWith(comparator: Comparator<in Short> /* = java.util.Comparator<in Short> */): List<Short>

// JVM method = subtract([Ljava/lang/Object;Ljava/lang/Iterable;)Ljava/util/Set;
infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T>

// JVM method = subtract([ZLjava/lang/Iterable;)Ljava/util/Set;
infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean>

// JVM method = subtract([BLjava/lang/Iterable;)Ljava/util/Set;
infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte>

// JVM method = subtract([CLjava/lang/Iterable;)Ljava/util/Set;
infix fun CharArray.subtract(other: Iterable<Char>): Set<Char>

// JVM method = subtract([DLjava/lang/Iterable;)Ljava/util/Set;
infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double>

// JVM method = subtract([FLjava/lang/Iterable;)Ljava/util/Set;
infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float>

// JVM method = subtract([ILjava/lang/Iterable;)Ljava/util/Set;
infix fun IntArray.subtract(other: Iterable<Int>): Set<Int>

// JVM method = subtract([JLjava/lang/Iterable;)Ljava/util/Set;
infix fun LongArray.subtract(other: Iterable<Long>): Set<Long>

// JVM method = subtract([SLjava/lang/Iterable;)Ljava/util/Set;
infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short>

// JVM method = sumOfByte([Ljava/lang/Byte;)I
fun Array<out Byte>.sum(): Int

// JVM method = sumOfDouble([Ljava/lang/Double;)D
fun Array<out Double>.sum(): Double

// JVM method = sumOfFloat([Ljava/lang/Float;)F
fun Array<out Float>.sum(): Float

// JVM method = sumOfInt([Ljava/lang/Integer;)I
fun Array<out Int>.sum(): Int

// JVM method = sumOfLong([Ljava/lang/Long;)J
fun Array<out Long>.sum(): Long

// JVM method = sumOfShort([Ljava/lang/Short;)I
fun Array<out Short>.sum(): Int

// JVM method = sum([B)I
fun ByteArray.sum(): Int

// JVM method = sum([D)D
fun DoubleArray.sum(): Double

// JVM method = sum([F)F
fun FloatArray.sum(): Float

// JVM method = sum([I)I
fun IntArray.sum(): Int

// JVM method = sum([J)J
fun LongArray.sum(): Long

// JVM method = sum([S)I
fun ShortArray.sum(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumBy([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumBy([ZLkotlin/jvm/functions/Function1;)I
inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumBy([BLkotlin/jvm/functions/Function1;)I
inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumBy([CLkotlin/jvm/functions/Function1;)I
inline fun CharArray.sumBy(selector: (Char) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumBy([DLkotlin/jvm/functions/Function1;)I
inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumBy([FLkotlin/jvm/functions/Function1;)I
inline fun FloatArray.sumBy(selector: (Float) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumBy([ILkotlin/jvm/functions/Function1;)I
inline fun IntArray.sumBy(selector: (Int) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumBy([JLkotlin/jvm/functions/Function1;)I
inline fun LongArray.sumBy(selector: (Long) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumBy([SLkotlin/jvm/functions/Function1;)I
inline fun ShortArray.sumBy(selector: (Short) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumByDouble([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)D
inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumByDouble([ZLkotlin/jvm/functions/Function1;)D
inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumByDouble([BLkotlin/jvm/functions/Function1;)D
inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumByDouble([CLkotlin/jvm/functions/Function1;)D
inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumByDouble([DLkotlin/jvm/functions/Function1;)D
inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumByDouble([FLkotlin/jvm/functions/Function1;)D
inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumByDouble([ILkotlin/jvm/functions/Function1;)D
inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumByDouble([JLkotlin/jvm/functions/Function1;)D
inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumByDouble([SLkotlin/jvm/functions/Function1;)D
inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfDouble([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)D
inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfInt([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Array<out T>.sumOf(selector: (T) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfLong([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)J
inline fun <T> Array<out T>.sumOf(selector: (T) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Array<out T>.sumOf(selector: (T) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)J
inline fun <T> Array<out T>.sumOf(selector: (T) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfDouble([ZLkotlin/jvm/functions/Function1;)D
inline fun BooleanArray.sumOf(selector: (Boolean) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfInt([ZLkotlin/jvm/functions/Function1;)I
inline fun BooleanArray.sumOf(selector: (Boolean) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfLong([ZLkotlin/jvm/functions/Function1;)J
inline fun BooleanArray.sumOf(selector: (Boolean) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([ZLkotlin/jvm/functions/Function1;)I
inline fun BooleanArray.sumOf(selector: (Boolean) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([ZLkotlin/jvm/functions/Function1;)J
inline fun BooleanArray.sumOf(selector: (Boolean) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfDouble([BLkotlin/jvm/functions/Function1;)D
inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfInt([BLkotlin/jvm/functions/Function1;)I
inline fun ByteArray.sumOf(selector: (Byte) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfLong([BLkotlin/jvm/functions/Function1;)J
inline fun ByteArray.sumOf(selector: (Byte) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([BLkotlin/jvm/functions/Function1;)I
inline fun ByteArray.sumOf(selector: (Byte) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([BLkotlin/jvm/functions/Function1;)J
inline fun ByteArray.sumOf(selector: (Byte) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfDouble([CLkotlin/jvm/functions/Function1;)D
inline fun CharArray.sumOf(selector: (Char) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfInt([CLkotlin/jvm/functions/Function1;)I
inline fun CharArray.sumOf(selector: (Char) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfLong([CLkotlin/jvm/functions/Function1;)J
inline fun CharArray.sumOf(selector: (Char) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([CLkotlin/jvm/functions/Function1;)I
inline fun CharArray.sumOf(selector: (Char) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([CLkotlin/jvm/functions/Function1;)J
inline fun CharArray.sumOf(selector: (Char) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfDouble([DLkotlin/jvm/functions/Function1;)D
inline fun DoubleArray.sumOf(selector: (Double) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfInt([DLkotlin/jvm/functions/Function1;)I
inline fun DoubleArray.sumOf(selector: (Double) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfLong([DLkotlin/jvm/functions/Function1;)J
inline fun DoubleArray.sumOf(selector: (Double) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([DLkotlin/jvm/functions/Function1;)I
inline fun DoubleArray.sumOf(selector: (Double) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([DLkotlin/jvm/functions/Function1;)J
inline fun DoubleArray.sumOf(selector: (Double) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfDouble([FLkotlin/jvm/functions/Function1;)D
inline fun FloatArray.sumOf(selector: (Float) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfInt([FLkotlin/jvm/functions/Function1;)I
inline fun FloatArray.sumOf(selector: (Float) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfLong([FLkotlin/jvm/functions/Function1;)J
inline fun FloatArray.sumOf(selector: (Float) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([FLkotlin/jvm/functions/Function1;)I
inline fun FloatArray.sumOf(selector: (Float) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([FLkotlin/jvm/functions/Function1;)J
inline fun FloatArray.sumOf(selector: (Float) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfDouble([ILkotlin/jvm/functions/Function1;)D
inline fun IntArray.sumOf(selector: (Int) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfInt([ILkotlin/jvm/functions/Function1;)I
inline fun IntArray.sumOf(selector: (Int) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfLong([ILkotlin/jvm/functions/Function1;)J
inline fun IntArray.sumOf(selector: (Int) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([ILkotlin/jvm/functions/Function1;)I
inline fun IntArray.sumOf(selector: (Int) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([ILkotlin/jvm/functions/Function1;)J
inline fun IntArray.sumOf(selector: (Int) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfDouble([JLkotlin/jvm/functions/Function1;)D
inline fun LongArray.sumOf(selector: (Long) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfInt([JLkotlin/jvm/functions/Function1;)I
inline fun LongArray.sumOf(selector: (Long) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfLong([JLkotlin/jvm/functions/Function1;)J
inline fun LongArray.sumOf(selector: (Long) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([JLkotlin/jvm/functions/Function1;)I
inline fun LongArray.sumOf(selector: (Long) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([JLkotlin/jvm/functions/Function1;)J
inline fun LongArray.sumOf(selector: (Long) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfDouble([SLkotlin/jvm/functions/Function1;)D
inline fun ShortArray.sumOf(selector: (Short) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfInt([SLkotlin/jvm/functions/Function1;)I
inline fun ShortArray.sumOf(selector: (Short) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfLong([SLkotlin/jvm/functions/Function1;)J
inline fun ShortArray.sumOf(selector: (Short) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([SLkotlin/jvm/functions/Function1;)I
inline fun ShortArray.sumOf(selector: (Short) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([SLkotlin/jvm/functions/Function1;)J
inline fun ShortArray.sumOf(selector: (Short) -> ULong): ULong

// JVM method = take([Ljava/lang/Object;I)Ljava/util/List;
fun <T> Array<out T>.take(n: Int): List<T>

// JVM method = take([ZI)Ljava/util/List;
fun BooleanArray.take(n: Int): List<Boolean>

// JVM method = take([BI)Ljava/util/List;
fun ByteArray.take(n: Int): List<Byte>

// JVM method = take([CI)Ljava/util/List;
fun CharArray.take(n: Int): List<Char>

// JVM method = take([DI)Ljava/util/List;
fun DoubleArray.take(n: Int): List<Double>

// JVM method = take([FI)Ljava/util/List;
fun FloatArray.take(n: Int): List<Float>

// JVM method = take([II)Ljava/util/List;
fun IntArray.take(n: Int): List<Int>

// JVM method = take([JI)Ljava/util/List;
fun LongArray.take(n: Int): List<Long>

// JVM method = take([SI)Ljava/util/List;
fun ShortArray.take(n: Int): List<Short>

// JVM method = takeLast([Ljava/lang/Object;I)Ljava/util/List;
fun <T> Array<out T>.takeLast(n: Int): List<T>

// JVM method = takeLast([ZI)Ljava/util/List;
fun BooleanArray.takeLast(n: Int): List<Boolean>

// JVM method = takeLast([BI)Ljava/util/List;
fun ByteArray.takeLast(n: Int): List<Byte>

// JVM method = takeLast([CI)Ljava/util/List;
fun CharArray.takeLast(n: Int): List<Char>

// JVM method = takeLast([DI)Ljava/util/List;
fun DoubleArray.takeLast(n: Int): List<Double>

// JVM method = takeLast([FI)Ljava/util/List;
fun FloatArray.takeLast(n: Int): List<Float>

// JVM method = takeLast([II)Ljava/util/List;
fun IntArray.takeLast(n: Int): List<Int>

// JVM method = takeLast([JI)Ljava/util/List;
fun LongArray.takeLast(n: Int): List<Long>

// JVM method = takeLast([SI)Ljava/util/List;
fun ShortArray.takeLast(n: Int): List<Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeLastWhile([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeLastWhile([ZLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeLastWhile([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeLastWhile([CLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeLastWhile([DLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeLastWhile([FLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeLastWhile([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeLastWhile([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeLastWhile([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeWhile([Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeWhile([ZLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeWhile([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeWhile([CLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeWhile([DLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeWhile([FLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeWhile([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeWhile([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeWhile([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short>

// JVM method = toBooleanArray([Ljava/lang/Boolean;)[Z
fun Array<out Boolean>.toBooleanArray(): BooleanArray

// JVM method = toByteArray([Ljava/lang/Byte;)[B
fun Array<out Byte>.toByteArray(): ByteArray

// JVM method = toCharArray([Ljava/lang/Character;)[C
fun Array<out Char>.toCharArray(): CharArray

// JVM method = toCollection([Ljava/lang/Object;Ljava/util/Collection;)Ljava/util/Collection;
fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C : MutableCollection<in T>): C : MutableCollection<in T>

// JVM method = toCollection([ZLjava/util/Collection;)Ljava/util/Collection;
fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C : MutableCollection<in Boolean>): C : MutableCollection<in Boolean>

// JVM method = toCollection([BLjava/util/Collection;)Ljava/util/Collection;
fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C : MutableCollection<in Byte>): C : MutableCollection<in Byte>

// JVM method = toCollection([CLjava/util/Collection;)Ljava/util/Collection;
fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C : MutableCollection<in Char>): C : MutableCollection<in Char>

// JVM method = toCollection([DLjava/util/Collection;)Ljava/util/Collection;
fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C : MutableCollection<in Double>): C : MutableCollection<in Double>

// JVM method = toCollection([FLjava/util/Collection;)Ljava/util/Collection;
fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C : MutableCollection<in Float>): C : MutableCollection<in Float>

// JVM method = toCollection([ILjava/util/Collection;)Ljava/util/Collection;
fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C : MutableCollection<in Int>): C : MutableCollection<in Int>

// JVM method = toCollection([JLjava/util/Collection;)Ljava/util/Collection;
fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C : MutableCollection<in Long>): C : MutableCollection<in Long>

// JVM method = toCollection([SLjava/util/Collection;)Ljava/util/Collection;
fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C : MutableCollection<in Short>): C : MutableCollection<in Short>

// JVM method = toDoubleArray([Ljava/lang/Double;)[D
fun Array<out Double>.toDoubleArray(): DoubleArray

// JVM method = toFloatArray([Ljava/lang/Float;)[F
fun Array<out Float>.toFloatArray(): FloatArray

// JVM method = toHashSet([Ljava/lang/Object;)Ljava/util/HashSet;
fun <T> Array<out T>.toHashSet(): HashSet<T> /* = java.util.HashSet<T> */

// JVM method = toHashSet([Z)Ljava/util/HashSet;
fun BooleanArray.toHashSet(): HashSet<Boolean> /* = java.util.HashSet<Boolean> */

// JVM method = toHashSet([B)Ljava/util/HashSet;
fun ByteArray.toHashSet(): HashSet<Byte> /* = java.util.HashSet<Byte> */

// JVM method = toHashSet([C)Ljava/util/HashSet;
fun CharArray.toHashSet(): HashSet<Char> /* = java.util.HashSet<Char> */

// JVM method = toHashSet([D)Ljava/util/HashSet;
fun DoubleArray.toHashSet(): HashSet<Double> /* = java.util.HashSet<Double> */

// JVM method = toHashSet([F)Ljava/util/HashSet;
fun FloatArray.toHashSet(): HashSet<Float> /* = java.util.HashSet<Float> */

// JVM method = toHashSet([I)Ljava/util/HashSet;
fun IntArray.toHashSet(): HashSet<Int> /* = java.util.HashSet<Int> */

// JVM method = toHashSet([J)Ljava/util/HashSet;
fun LongArray.toHashSet(): HashSet<Long> /* = java.util.HashSet<Long> */

// JVM method = toHashSet([S)Ljava/util/HashSet;
fun ShortArray.toHashSet(): HashSet<Short> /* = java.util.HashSet<Short> */

// JVM method = toIntArray([Ljava/lang/Integer;)[I
fun Array<out Int>.toIntArray(): IntArray

// JVM method = toList([Ljava/lang/Object;)Ljava/util/List;
fun <T> Array<out T>.toList(): List<T>

// JVM method = toList([Z)Ljava/util/List;
fun BooleanArray.toList(): List<Boolean>

// JVM method = toList([B)Ljava/util/List;
fun ByteArray.toList(): List<Byte>

// JVM method = toList([C)Ljava/util/List;
fun CharArray.toList(): List<Char>

// JVM method = toList([D)Ljava/util/List;
fun DoubleArray.toList(): List<Double>

// JVM method = toList([F)Ljava/util/List;
fun FloatArray.toList(): List<Float>

// JVM method = toList([I)Ljava/util/List;
fun IntArray.toList(): List<Int>

// JVM method = toList([J)Ljava/util/List;
fun LongArray.toList(): List<Long>

// JVM method = toList([S)Ljava/util/List;
fun ShortArray.toList(): List<Short>

// JVM method = toLongArray([Ljava/lang/Long;)[J
fun Array<out Long>.toLongArray(): LongArray

// JVM method = toMutableList([Ljava/lang/Object;)Ljava/util/List;
fun <T> Array<out T>.toMutableList(): MutableList<T>

// JVM method = toMutableList([Z)Ljava/util/List;
fun BooleanArray.toMutableList(): MutableList<Boolean>

// JVM method = toMutableList([B)Ljava/util/List;
fun ByteArray.toMutableList(): MutableList<Byte>

// JVM method = toMutableList([C)Ljava/util/List;
fun CharArray.toMutableList(): MutableList<Char>

// JVM method = toMutableList([D)Ljava/util/List;
fun DoubleArray.toMutableList(): MutableList<Double>

// JVM method = toMutableList([F)Ljava/util/List;
fun FloatArray.toMutableList(): MutableList<Float>

// JVM method = toMutableList([I)Ljava/util/List;
fun IntArray.toMutableList(): MutableList<Int>

// JVM method = toMutableList([J)Ljava/util/List;
fun LongArray.toMutableList(): MutableList<Long>

// JVM method = toMutableList([S)Ljava/util/List;
fun ShortArray.toMutableList(): MutableList<Short>

// JVM method = toMutableSet([Ljava/lang/Object;)Ljava/util/Set;
fun <T> Array<out T>.toMutableSet(): MutableSet<T>

// JVM method = toMutableSet([Z)Ljava/util/Set;
fun BooleanArray.toMutableSet(): MutableSet<Boolean>

// JVM method = toMutableSet([B)Ljava/util/Set;
fun ByteArray.toMutableSet(): MutableSet<Byte>

// JVM method = toMutableSet([C)Ljava/util/Set;
fun CharArray.toMutableSet(): MutableSet<Char>

// JVM method = toMutableSet([D)Ljava/util/Set;
fun DoubleArray.toMutableSet(): MutableSet<Double>

// JVM method = toMutableSet([F)Ljava/util/Set;
fun FloatArray.toMutableSet(): MutableSet<Float>

// JVM method = toMutableSet([I)Ljava/util/Set;
fun IntArray.toMutableSet(): MutableSet<Int>

// JVM method = toMutableSet([J)Ljava/util/Set;
fun LongArray.toMutableSet(): MutableSet<Long>

// JVM method = toMutableSet([S)Ljava/util/Set;
fun ShortArray.toMutableSet(): MutableSet<Short>

// JVM method = toSet([Ljava/lang/Object;)Ljava/util/Set;
fun <T> Array<out T>.toSet(): Set<T>

// JVM method = toSet([Z)Ljava/util/Set;
fun BooleanArray.toSet(): Set<Boolean>

// JVM method = toSet([B)Ljava/util/Set;
fun ByteArray.toSet(): Set<Byte>

// JVM method = toSet([C)Ljava/util/Set;
fun CharArray.toSet(): Set<Char>

// JVM method = toSet([D)Ljava/util/Set;
fun DoubleArray.toSet(): Set<Double>

// JVM method = toSet([F)Ljava/util/Set;
fun FloatArray.toSet(): Set<Float>

// JVM method = toSet([I)Ljava/util/Set;
fun IntArray.toSet(): Set<Int>

// JVM method = toSet([J)Ljava/util/Set;
fun LongArray.toSet(): Set<Long>

// JVM method = toSet([S)Ljava/util/Set;
fun ShortArray.toSet(): Set<Short>

// JVM method = toShortArray([Ljava/lang/Short;)[S
fun Array<out Short>.toShortArray(): ShortArray

// JVM method = union([Ljava/lang/Object;Ljava/lang/Iterable;)Ljava/util/Set;
infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T>

// JVM method = union([ZLjava/lang/Iterable;)Ljava/util/Set;
infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean>

// JVM method = union([BLjava/lang/Iterable;)Ljava/util/Set;
infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte>

// JVM method = union([CLjava/lang/Iterable;)Ljava/util/Set;
infix fun CharArray.union(other: Iterable<Char>): Set<Char>

// JVM method = union([DLjava/lang/Iterable;)Ljava/util/Set;
infix fun DoubleArray.union(other: Iterable<Double>): Set<Double>

// JVM method = union([FLjava/lang/Iterable;)Ljava/util/Set;
infix fun FloatArray.union(other: Iterable<Float>): Set<Float>

// JVM method = union([ILjava/lang/Iterable;)Ljava/util/Set;
infix fun IntArray.union(other: Iterable<Int>): Set<Int>

// JVM method = union([JLjava/lang/Iterable;)Ljava/util/Set;
infix fun LongArray.union(other: Iterable<Long>): Set<Long>

// JVM method = union([SLjava/lang/Iterable;)Ljava/util/Set;
infix fun ShortArray.union(other: Iterable<Short>): Set<Short>

// JVM method = withIndex([Ljava/lang/Object;)Ljava/lang/Iterable;
fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>>

// JVM method = withIndex([Z)Ljava/lang/Iterable;
fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>>

// JVM method = withIndex([B)Ljava/lang/Iterable;
fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>>

// JVM method = withIndex([C)Ljava/lang/Iterable;
fun CharArray.withIndex(): Iterable<IndexedValue<Char>>

// JVM method = withIndex([D)Ljava/lang/Iterable;
fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>>

// JVM method = withIndex([F)Ljava/lang/Iterable;
fun FloatArray.withIndex(): Iterable<IndexedValue<Float>>

// JVM method = withIndex([I)Ljava/lang/Iterable;
fun IntArray.withIndex(): Iterable<IndexedValue<Int>>

// JVM method = withIndex([J)Ljava/lang/Iterable;
fun LongArray.withIndex(): Iterable<IndexedValue<Long>>

// JVM method = withIndex([S)Ljava/lang/Iterable;
fun ShortArray.withIndex(): Iterable<IndexedValue<Short>>

// JVM method = zip([Ljava/lang/Object;[Ljava/lang/Object;)Ljava/util/List;
infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([Ljava/lang/Object;[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (@ParameterName(name = "a") T, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([Ljava/lang/Object;Ljava/lang/Iterable;)Ljava/util/List;
infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([Ljava/lang/Object;Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") T, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([Z[Ljava/lang/Object;)Ljava/util/List;
infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([Z[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (@ParameterName(name = "a") Boolean, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([Z[Z)Ljava/util/List;
infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([Z[ZLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (@ParameterName(name = "a") Boolean, @ParameterName(name = "b") Boolean) -> V): List<V>

// JVM method = zip([ZLjava/lang/Iterable;)Ljava/util/List;
infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([ZLjava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") Boolean, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([B[Ljava/lang/Object;)Ljava/util/List;
infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([B[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (@ParameterName(name = "a") Byte, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([B[B)Ljava/util/List;
infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([B[BLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> ByteArray.zip(other: ByteArray, transform: (@ParameterName(name = "a") Byte, @ParameterName(name = "b") Byte) -> V): List<V>

// JVM method = zip([BLjava/lang/Iterable;)Ljava/util/List;
infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([BLjava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") Byte, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([C[Ljava/lang/Object;)Ljava/util/List;
infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([C[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (@ParameterName(name = "a") Char, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([C[C)Ljava/util/List;
infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([C[CLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> CharArray.zip(other: CharArray, transform: (@ParameterName(name = "a") Char, @ParameterName(name = "b") Char) -> V): List<V>

// JVM method = zip([CLjava/lang/Iterable;)Ljava/util/List;
infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([CLjava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") Char, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([D[Ljava/lang/Object;)Ljava/util/List;
infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([D[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (@ParameterName(name = "a") Double, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([D[D)Ljava/util/List;
infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([D[DLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (@ParameterName(name = "a") Double, @ParameterName(name = "b") Double) -> V): List<V>

// JVM method = zip([DLjava/lang/Iterable;)Ljava/util/List;
infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([DLjava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") Double, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([F[Ljava/lang/Object;)Ljava/util/List;
infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([F[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (@ParameterName(name = "a") Float, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([F[F)Ljava/util/List;
infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([F[FLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> FloatArray.zip(other: FloatArray, transform: (@ParameterName(name = "a") Float, @ParameterName(name = "b") Float) -> V): List<V>

// JVM method = zip([FLjava/lang/Iterable;)Ljava/util/List;
infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([FLjava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") Float, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([I[Ljava/lang/Object;)Ljava/util/List;
infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([I[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (@ParameterName(name = "a") Int, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([I[I)Ljava/util/List;
infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([I[ILkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> IntArray.zip(other: IntArray, transform: (@ParameterName(name = "a") Int, @ParameterName(name = "b") Int) -> V): List<V>

// JVM method = zip([ILjava/lang/Iterable;)Ljava/util/List;
infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([ILjava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") Int, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([J[Ljava/lang/Object;)Ljava/util/List;
infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([J[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (@ParameterName(name = "a") Long, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([J[J)Ljava/util/List;
infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([J[JLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> LongArray.zip(other: LongArray, transform: (@ParameterName(name = "a") Long, @ParameterName(name = "b") Long) -> V): List<V>

// JVM method = zip([JLjava/lang/Iterable;)Ljava/util/List;
infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([JLjava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") Long, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([S[Ljava/lang/Object;)Ljava/util/List;
infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([S[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (@ParameterName(name = "a") Short, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip([S[S)Ljava/util/List;
infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([S[SLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> ShortArray.zip(other: ShortArray, transform: (@ParameterName(name = "a") Short, @ParameterName(name = "b") Short) -> V): List<V>

// JVM method = zip([SLjava/lang/Iterable;)Ljava/util/List;
infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip([SLjava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") Short, @ParameterName(name = "b") R) -> V): List<V>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.CollectionsKt


// *** FUNCTIONS ***

// JVM method = build(Ljava/util/List;)Ljava/util/List;
internal fun <E> build(builder: MutableList<E>): List<E>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildListInternal(ILkotlin/jvm/functions/Function1;)Ljava/util/List;
internal inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildListInternal(Lkotlin/jvm/functions/Function1;)Ljava/util/List;
internal inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>

// JVM method = checkCountOverflow(I)I
internal inline fun checkCountOverflow(count: Int): Int

// JVM method = checkIndexOverflow(I)I
internal inline fun checkIndexOverflow(index: Int): Int

// JVM method = copyToArrayImpl(Ljava/util/Collection;)[Ljava/lang/Object;
internal inline fun copyToArrayImpl(collection: Collection<*>): Array<Any?>

// JVM method = copyToArrayImpl(Ljava/util/Collection;[Ljava/lang/Object;)[Ljava/lang/Object;
internal inline fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T>

// JVM method = createListBuilder()Ljava/util/List;
internal fun <E> createListBuilder(): MutableList<E>

// JVM method = createListBuilder(I)Ljava/util/List;
internal fun <E> createListBuilder(capacity: Int): MutableList<E>

// JVM method = listOf(Ljava/lang/Object;)Ljava/util/List;
fun <T> listOf(element: T): List<T>

// JVM method = copyToArrayOfAny([Ljava/lang/Object;Z)[Ljava/lang/Object;
internal fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?>

// JVM method = shuffled(Ljava/lang/Iterable;)Ljava/util/List;
fun <T> Iterable<T>.shuffled(): List<T>

// JVM method = shuffled(Ljava/lang/Iterable;Ljava/util/Random;)Ljava/util/List;
fun <T> Iterable<T>.shuffled(random: java.util.Random): List<T>

// JVM method = toList(Ljava/util/Enumeration;)Ljava/util/List;
inline fun <T> java.util.Enumeration<T>.toList(): List<T>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.CollectionsKt


// *** PROPERTIES ***

val Collection<*>.indices: IntRange
	// JVM method = getIndices(Ljava/util/Collection;)Lkotlin/ranges/IntRange;
	get() = /* non-default */

val <T> List<T>.lastIndex: Int
	// JVM method = getLastIndex(Ljava/util/List;)I
	get() = /* non-default */


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = List(ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> List(size: Int, init: (@ParameterName(name = "index") Int) -> T): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = MutableList(ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> MutableList(size: Int, init: (@ParameterName(name = "index") Int) -> T): MutableList<T>

// JVM method = arrayListOf()Ljava/util/ArrayList;
inline fun <T> arrayListOf(): ArrayList<T> /* = java.util.ArrayList<T> */

// JVM method = arrayListOf([Ljava/lang/Object;)Ljava/util/ArrayList;
fun <T> arrayListOf(vararg elements: T /* Array<out T> */): ArrayList<T> /* = java.util.ArrayList<T> */

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildList(ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <E> buildList(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {
	contract {
		callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildList(Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <E> buildList(builderAction: MutableList<E>.() -> Unit): List<E> {
	contract {
		callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE)
	}
}

// JVM method = emptyList()Ljava/util/List;
fun <T> emptyList(): List<T>

// JVM method = listOf()Ljava/util/List;
inline fun <T> listOf(): List<T>

// JVM method = listOf([Ljava/lang/Object;)Ljava/util/List;
fun <T> listOf(vararg elements: T /* Array<out T> */): List<T>

// JVM method = listOfNotNull(Ljava/lang/Object;)Ljava/util/List;
fun <T : Any> listOfNotNull(element: T : Any?): List<T : Any>

// JVM method = listOfNotNull([Ljava/lang/Object;)Ljava/util/List;
fun <T : Any> listOfNotNull(vararg elements: T : Any? /* Array<out T : Any?> */): List<T : Any>

// JVM method = mutableListOf()Ljava/util/List;
inline fun <T> mutableListOf(): MutableList<T>

// JVM method = mutableListOf([Ljava/lang/Object;)Ljava/util/List;
fun <T> mutableListOf(vararg elements: T /* Array<out T> */): MutableList<T>

// JVM method = rangeCheck$CollectionsKt__CollectionsKt(III)V
private fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int)

// JVM method = throwCountOverflow()V
internal fun throwCountOverflow()

// JVM method = throwIndexOverflow()V
internal fun throwIndexOverflow()

// JVM method = asCollection([Ljava/lang/Object;)Ljava/util/Collection;
internal fun <T> Array<out T>.asCollection(): Collection<T>

// JVM method = binarySearch(Ljava/util/List;Ljava/lang/Object;Ljava/util/Comparator;II)I
fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T> /* = java.util.Comparator<in T> */, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// JVM method = binarySearch(Ljava/util/List;IILkotlin/jvm/functions/Function1;)I
fun <T> List<T>.binarySearch(fromIndex: Int /* = default */, toIndex: Int /* = default */, comparison: (T) -> Int): Int

// JVM method = binarySearch(Ljava/util/List;Ljava/lang/Comparable;II)I
fun <T : Comparable<T>> List<T : Comparable<T>?>.binarySearch(element: T : Comparable<T>?, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = binarySearchBy(Ljava/util/List;Ljava/lang/Comparable;IILkotlin/jvm/functions/Function1;)I
inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(key: K : Comparable<K>?, fromIndex: Int /* = default */, toIndex: Int /* = default */, crossinline selector: (T) -> K : Comparable<K>?): Int

// JVM method = containsAll(Ljava/util/Collection;Ljava/util/Collection;)Z
inline fun <@kotlin.internal.OnlyInputTypes T> Collection<@kotlin.internal.OnlyInputTypes T>.containsAll(elements: Collection<@kotlin.internal.OnlyInputTypes T>): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = ifEmpty(Ljava/util/Collection;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where
	C : Collection<*>,
	C : R

// JVM method = isNotEmpty(Ljava/util/Collection;)Z
inline fun <T> Collection<T>.isNotEmpty(): Boolean

// JVM method = isNullOrEmpty(Ljava/util/Collection;)Z
inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {
	contract {
		returns(false) implies (this@isNullOrEmpty != null)
	}
}

// JVM method = optimizeReadOnlyList(Ljava/util/List;)Ljava/util/List;
internal fun <T> List<T>.optimizeReadOnlyList(): List<T>

// JVM method = orEmpty(Ljava/util/Collection;)Ljava/util/Collection;
inline fun <T> Collection<T>?.orEmpty(): Collection<T>

// JVM method = orEmpty(Ljava/util/List;)Ljava/util/List;
inline fun <T> List<T>?.orEmpty(): List<T>

// JVM method = shuffled(Ljava/lang/Iterable;Lkotlin/random/Random;)Ljava/util/List;
fun <T> Iterable<T>.shuffled(random: kotlin.random.Random): List<T>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.CollectionsKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = Iterable(Lkotlin/jvm/functions/Function0;)Ljava/lang/Iterable;
inline fun <T> Iterable(crossinline iterator: () -> Iterator<T>): Iterable<T>

// JVM method = collectionSizeOrDefault(Ljava/lang/Iterable;I)I
internal fun <T> Iterable<T>.collectionSizeOrDefault(default: Int): Int

// JVM method = collectionSizeOrNull(Ljava/lang/Iterable;)Ljava/lang/Integer;
internal fun <T> Iterable<T>.collectionSizeOrNull(): Int?

// JVM method = flatten(Ljava/lang/Iterable;)Ljava/util/List;
fun <T> Iterable<Iterable<T>>.flatten(): List<T>

// JVM method = unzip(Ljava/lang/Iterable;)Lkotlin/Pair;
fun <T, R> Iterable<Pair<T, R>>.unzip(): Pair<List<T>, List<R>>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.CollectionsKt


// *** FUNCTIONS ***

// JVM method = iterator(Ljava/util/Enumeration;)Ljava/util/Iterator;
operator fun <T> java.util.Enumeration<T>.iterator(): Iterator<T>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.CollectionsKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach(Ljava/util/Iterator;Lkotlin/jvm/functions/Function1;)V
inline fun <T> Iterator<T>.forEach(operation: (T) -> Unit)

// JVM method = iterator(Ljava/util/Iterator;)Ljava/util/Iterator;
inline operator fun <T> Iterator<T>.iterator(): Iterator<T>

// JVM method = withIndex(Ljava/util/Iterator;)Ljava/util/Iterator;
fun <T> Iterator<T>.withIndex(): Iterator<IndexedValue<T>>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.CollectionsKt


// *** FUNCTIONS ***

// JVM method = fill(Ljava/util/List;Ljava/lang/Object;)V
inline fun <T> MutableList<T>.fill(value: T)

// JVM method = shuffle(Ljava/util/List;)V
inline fun <T> MutableList<T>.shuffle()

// JVM method = shuffle(Ljava/util/List;Ljava/util/Random;)V
inline fun <T> MutableList<T>.shuffle(random: java.util.Random)

// JVM method = sort(Ljava/util/List;)V
fun <T : Comparable<T>> MutableList<T : Comparable<T>>.sort()

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sort(Ljava/util/List;Lkotlin/jvm/functions/Function2;)V
inline fun <T> MutableList<T>.sort(comparison: (T, T) -> Int)

// JVM method = sort(Ljava/util/List;Ljava/util/Comparator;)V
inline fun <T> MutableList<T>.sort(comparator: Comparator<in T> /* = java.util.Comparator<in T> */)

// JVM method = sortWith(Ljava/util/List;Ljava/util/Comparator;)V
fun <T> MutableList<T>.sortWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */)

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.CollectionsKt


// *** FUNCTIONS ***

// JVM method = addAll(Ljava/util/Collection;[Ljava/lang/Object;)Z
fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean

// JVM method = addAll(Ljava/util/Collection;Ljava/lang/Iterable;)Z
fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean

// JVM method = addAll(Ljava/util/Collection;Lkotlin/sequences/Sequence;)Z
fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean

// JVM method = convertToListIfNotCollection(Ljava/lang/Iterable;)Ljava/util/Collection;
internal fun <T> Iterable<T>.convertToListIfNotCollection(): Collection<T>

// JVM method = filterInPlace$CollectionsKt__MutableCollectionsKt(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;Z)Z
private fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean

// JVM method = filterInPlace$CollectionsKt__MutableCollectionsKt(Ljava/util/List;Lkotlin/jvm/functions/Function1;Z)Z
private fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean

// JVM method = minusAssign(Ljava/util/Collection;Ljava/lang/Object;)V
inline operator fun <T> MutableCollection<in T>.minusAssign(element: T)

// JVM method = minusAssign(Ljava/util/Collection;[Ljava/lang/Object;)V
inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>)

// JVM method = minusAssign(Ljava/util/Collection;Ljava/lang/Iterable;)V
inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>)

// JVM method = minusAssign(Ljava/util/Collection;Lkotlin/sequences/Sequence;)V
inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>)

// JVM method = plusAssign(Ljava/util/Collection;Ljava/lang/Object;)V
inline operator fun <T> MutableCollection<in T>.plusAssign(element: T)

// JVM method = plusAssign(Ljava/util/Collection;[Ljava/lang/Object;)V
inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>)

// JVM method = plusAssign(Ljava/util/Collection;Ljava/lang/Iterable;)V
inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>)

// JVM method = plusAssign(Ljava/util/Collection;Lkotlin/sequences/Sequence;)V
inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>)

// JVM method = remove(Ljava/util/Collection;Ljava/lang/Object;)Z
inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out @kotlin.internal.OnlyInputTypes T>.remove(element: @kotlin.internal.OnlyInputTypes T): Boolean

// JVM method = remove(Ljava/util/List;I)Ljava/lang/Object;
inline fun <T> MutableList<T>.remove(index: Int): T

// JVM method = removeAll(Ljava/util/Collection;[Ljava/lang/Object;)Z
fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean

// JVM method = removeAll(Ljava/util/Collection;Ljava/lang/Iterable;)Z
fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean

// JVM method = removeAll(Ljava/util/Collection;Lkotlin/sequences/Sequence;)Z
fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean

// JVM method = removeAll(Ljava/util/Collection;Ljava/util/Collection;)Z
inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out @kotlin.internal.OnlyInputTypes T>.removeAll(elements: Collection<@kotlin.internal.OnlyInputTypes T>): Boolean

// JVM method = removeAll(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Z
fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean

// JVM method = removeAll(Ljava/util/List;Lkotlin/jvm/functions/Function1;)Z
fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean

// JVM method = removeFirst(Ljava/util/List;)Ljava/lang/Object;
fun <T> MutableList<T>.removeFirst(): T

// JVM method = removeFirstOrNull(Ljava/util/List;)Ljava/lang/Object;
fun <T> MutableList<T>.removeFirstOrNull(): T?

// JVM method = removeLast(Ljava/util/List;)Ljava/lang/Object;
fun <T> MutableList<T>.removeLast(): T

// JVM method = removeLastOrNull(Ljava/util/List;)Ljava/lang/Object;
fun <T> MutableList<T>.removeLastOrNull(): T?

// JVM method = retainAll(Ljava/util/Collection;[Ljava/lang/Object;)Z
fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean

// JVM method = retainAll(Ljava/util/Collection;Ljava/lang/Iterable;)Z
fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean

// JVM method = retainAll(Ljava/util/Collection;Lkotlin/sequences/Sequence;)Z
fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean

// JVM method = retainAll(Ljava/util/Collection;Ljava/util/Collection;)Z
inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out @kotlin.internal.OnlyInputTypes T>.retainAll(elements: Collection<@kotlin.internal.OnlyInputTypes T>): Boolean

// JVM method = retainAll(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Z
fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean

// JVM method = retainAll(Ljava/util/List;Lkotlin/jvm/functions/Function1;)Z
fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean

// JVM method = retainNothing$CollectionsKt__MutableCollectionsKt(Ljava/util/Collection;)Z
private fun MutableCollection<*>.retainNothing(): Boolean

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.CollectionsKt


// *** FUNCTIONS ***

// JVM method = asReversed(Ljava/util/List;)Ljava/util/List;
fun <T> List<T>.asReversed(): List<T>

// JVM method = asReversedMutable(Ljava/util/List;)Ljava/util/List;
fun <T> MutableList<T>.asReversed(): MutableList<T>

// JVM method = reverseElementIndex$CollectionsKt__ReversedViewsKt(Ljava/util/List;I)I
private fun List<*>.reverseElementIndex(index: Int): Int

// JVM method = reversePositionIndex$CollectionsKt__ReversedViewsKt(Ljava/util/List;I)I
private fun List<*>.reversePositionIndex(index: Int): Int

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.CollectionsKt


// *** FUNCTIONS ***

// JVM method = filterIsInstance(Ljava/lang/Iterable;Ljava/lang/Class;)Ljava/util/List;
fun <R> Iterable<*>.filterIsInstance(klass: java.lang.Class<R>): List<R>

// JVM method = filterIsInstanceTo(Ljava/lang/Iterable;Ljava/util/Collection;Ljava/lang/Class;)Ljava/util/Collection;
fun <C : MutableCollection<in R>, R> Iterable<*>.filterIsInstanceTo(destination: C : MutableCollection<in R>, klass: java.lang.Class<R>): C : MutableCollection<in R>

// JVM method = max(Ljava/lang/Iterable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Iterable<T : Comparable<T>>.max(): T : Comparable<T>?

// JVM method = max(Ljava/lang/Iterable;)Ljava/lang/Double;
fun Iterable<Double>.max(): Double?

// JVM method = max(Ljava/lang/Iterable;)Ljava/lang/Float;
fun Iterable<Float>.max(): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R : Comparable<R>): T?

// JVM method = maxWith(Ljava/lang/Iterable;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Iterable<T>.maxWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T?

// JVM method = min(Ljava/lang/Iterable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Iterable<T : Comparable<T>>.min(): T : Comparable<T>?

// JVM method = min(Ljava/lang/Iterable;)Ljava/lang/Double;
fun Iterable<Double>.min(): Double?

// JVM method = min(Ljava/lang/Iterable;)Ljava/lang/Float;
fun Iterable<Float>.min(): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R : Comparable<R>): T?

// JVM method = minWith(Ljava/lang/Iterable;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Iterable<T>.minWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T?

// JVM method = reverse(Ljava/util/List;)V
fun <T> MutableList<T>.reverse()

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigDecimal(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun <T> Iterable<T>.sumOf(selector: (T) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigInteger(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun <T> Iterable<T>.sumOf(selector: (T) -> java.math.BigInteger): java.math.BigInteger

// JVM method = toSortedSet(Ljava/lang/Iterable;)Ljava/util/SortedSet;
fun <T : Comparable<T>> Iterable<T : Comparable<T>>.toSortedSet(): java.util.SortedSet<T : Comparable<T>>

// JVM method = toSortedSet(Ljava/lang/Iterable;Ljava/util/Comparator;)Ljava/util/SortedSet;
fun <T> Iterable<T>.toSortedSet(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): java.util.SortedSet<T>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.CollectionsKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Z
inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean

// JVM method = any(Ljava/lang/Iterable;)Z
fun <T> Iterable<T>.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Z
inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean

// JVM method = asIterable(Ljava/lang/Iterable;)Ljava/lang/Iterable;
inline fun <T> Iterable<T>.asIterable(): Iterable<T>

// JVM method = asSequence(Ljava/lang/Iterable;)Lkotlin/sequences/Sequence;
fun <T> Iterable<T>.asSequence(): Sequence<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associate(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo(Ljava/lang/Iterable;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M : MutableMap<in K, in T>, keySelector: (T) -> K): M : MutableMap<in K, in T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo(Ljava/lang/Iterable;Ljava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M : MutableMap<in K, in V>, keySelector: (T) -> K, valueTransform: (T) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateTo(Ljava/lang/Iterable;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M : MutableMap<in K, in V>, transform: (T) -> Pair<K, V>): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWith(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWithTo(Ljava/lang/Iterable;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M : MutableMap<in K, in V>, valueSelector: (K) -> V): M : MutableMap<in K, in V>

// JVM method = averageOfByte(Ljava/lang/Iterable;)D
fun Iterable<Byte>.average(): Double

// JVM method = averageOfDouble(Ljava/lang/Iterable;)D
fun Iterable<Double>.average(): Double

// JVM method = averageOfFloat(Ljava/lang/Iterable;)D
fun Iterable<Float>.average(): Double

// JVM method = averageOfInt(Ljava/lang/Iterable;)D
fun Iterable<Int>.average(): Double

// JVM method = averageOfLong(Ljava/lang/Iterable;)D
fun Iterable<Long>.average(): Double

// JVM method = averageOfShort(Ljava/lang/Iterable;)D
fun Iterable<Short>.average(): Double

// JVM method = chunked(Ljava/lang/Iterable;I)Ljava/util/List;
fun <T> Iterable<T>.chunked(size: Int): List<List<T>>

// JVM method = chunked(Ljava/lang/Iterable;ILkotlin/jvm/functions/Function1;)Ljava/util/List;
fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R>

// JVM method = component1(Ljava/util/List;)Ljava/lang/Object;
inline operator fun <T> List<T>.component1(): T

// JVM method = component2(Ljava/util/List;)Ljava/lang/Object;
inline operator fun <T> List<T>.component2(): T

// JVM method = component3(Ljava/util/List;)Ljava/lang/Object;
inline operator fun <T> List<T>.component3(): T

// JVM method = component4(Ljava/util/List;)Ljava/lang/Object;
inline operator fun <T> List<T>.component4(): T

// JVM method = component5(Ljava/util/List;)Ljava/lang/Object;
inline operator fun <T> List<T>.component5(): T

// JVM method = contains(Ljava/lang/Iterable;Ljava/lang/Object;)Z
operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<@kotlin.internal.OnlyInputTypes T>.contains(element: @kotlin.internal.OnlyInputTypes T): Boolean

// JVM method = count(Ljava/util/Collection;)I
inline fun <T> Collection<T>.count(): Int

// JVM method = count(Ljava/lang/Iterable;)I
fun <T> Iterable<T>.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int

// JVM method = distinct(Ljava/lang/Iterable;)Ljava/util/List;
fun <T> Iterable<T>.distinct(): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = distinctBy(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T>

// JVM method = drop(Ljava/lang/Iterable;I)Ljava/util/List;
fun <T> Iterable<T>.drop(n: Int): List<T>

// JVM method = dropLast(Ljava/util/List;I)Ljava/util/List;
fun <T> List<T>.dropLast(n: Int): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropLastWhile(Ljava/util/List;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropWhile(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T>

// JVM method = elementAt(Ljava/lang/Iterable;I)Ljava/lang/Object;
fun <T> Iterable<T>.elementAt(index: Int): T

// JVM method = elementAt(Ljava/util/List;I)Ljava/lang/Object;
inline fun <T> List<T>.elementAt(index: Int): T

// JVM method = elementAtOrElse(Ljava/lang/Iterable;ILkotlin/jvm/functions/Function1;)Ljava/lang/Object;
fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = elementAtOrElse(Ljava/util/List;ILkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T

// JVM method = elementAtOrNull(Ljava/lang/Iterable;I)Ljava/lang/Object;
fun <T> Iterable<T>.elementAtOrNull(index: Int): T?

// JVM method = elementAtOrNull(Ljava/util/List;I)Ljava/lang/Object;
inline fun <T> List<T>.elementAtOrNull(index: Int): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexed(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T> Iterable<T>.filterIndexed(predicate: (@ParameterName(name = "index") Int, T) -> Boolean): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexedTo(Ljava/lang/Iterable;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C : MutableCollection<in T>, predicate: (@ParameterName(name = "index") Int, T) -> Boolean): C : MutableCollection<in T>

// JVM method = filterIsInstance(Ljava/lang/Iterable;)Ljava/util/List;
inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer reified R>

// JVM method = filterIsInstanceTo(Ljava/lang/Iterable;Ljava/util/Collection;)Ljava/util/Collection;
inline fun <reified R, C : MutableCollection<in reified R>> Iterable<*>.filterIsInstanceTo(destination: C : MutableCollection<in reified R>): C : MutableCollection<in reified R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T>

// JVM method = filterNotNull(Ljava/lang/Iterable;)Ljava/util/List;
fun <T : Any> Iterable<T : Any?>.filterNotNull(): List<T : Any>

// JVM method = filterNotNullTo(Ljava/lang/Iterable;Ljava/util/Collection;)Ljava/util/Collection;
fun <C : MutableCollection<in T : Any>, T : Any> Iterable<T : Any?>.filterNotNullTo(destination: C : MutableCollection<in T : Any>): C : MutableCollection<in T : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo(Ljava/lang/Iterable;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C : MutableCollection<in T>, predicate: (T) -> Boolean): C : MutableCollection<in T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo(Ljava/lang/Iterable;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C : MutableCollection<in T>, predicate: (T) -> Boolean): C : MutableCollection<in T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = find(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast(Ljava/util/List;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T?

// JVM method = first(Ljava/lang/Iterable;)Ljava/lang/Object;
fun <T> Iterable<T>.first(): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = first(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T

// JVM method = first(Ljava/util/List;)Ljava/lang/Object;
fun <T> List<T>.first(): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstNotNullOf(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Any> Iterable<T>.firstNotNullOf(transform: (T) -> R : Any?): R : Any

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstNotNullOfOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Any> Iterable<T>.firstNotNullOfOrNull(transform: (T) -> R : Any?): R : Any?

// JVM method = firstOrNull(Ljava/lang/Iterable;)Ljava/lang/Object;
fun <T> Iterable<T>.firstOrNull(): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T?

// JVM method = firstOrNull(Ljava/util/List;)Ljava/lang/Object;
fun <T> List<T>.firstOrNull(): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMap(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapSequence(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterable(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (@ParameterName(name = "index") Int, T) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedSequence(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (@ParameterName(name = "index") Int, T) -> Sequence<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterableTo(Ljava/lang/Iterable;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, T) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedSequenceTo(Ljava/lang/Iterable;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, T) -> Sequence<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo(Ljava/lang/Iterable;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C : MutableCollection<in R>, transform: (T) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapSequenceTo(Ljava/lang/Iterable;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C : MutableCollection<in R>, transform: (T) -> Sequence<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold(Ljava/lang/Iterable;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <T, R> Iterable<T>.fold(initial: R, operation: (@ParameterName(name = "acc") R, T) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldIndexed(Ljava/lang/Iterable;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, T) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRight(Ljava/util/List;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRightIndexed(Ljava/util/List;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, T, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)V
inline fun <T> Iterable<T>.forEach(action: (T) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachIndexed(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)V
inline fun <T> Iterable<T>.forEachIndexed(action: (@ParameterName(name = "index") Int, T) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElse(Ljava/util/List;ILkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T

// JVM method = getOrNull(Ljava/util/List;I)Ljava/lang/Object;
fun <T> List<T>.getOrNull(index: Int): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo(Ljava/lang/Iterable;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M : MutableMap<in K, MutableList<T>>, keySelector: (T) -> K): M : MutableMap<in K, MutableList<T>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo(Ljava/lang/Iterable;Ljava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (T) -> K, valueTransform: (T) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupingBy(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Lkotlin/collections/Grouping;
inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K>

// JVM method = indexOf(Ljava/lang/Iterable;Ljava/lang/Object;)I
fun <@kotlin.internal.OnlyInputTypes T> Iterable<@kotlin.internal.OnlyInputTypes T>.indexOf(element: @kotlin.internal.OnlyInputTypes T): Int

// JVM method = indexOf(Ljava/util/List;Ljava/lang/Object;)I
fun <@kotlin.internal.OnlyInputTypes T> List<@kotlin.internal.OnlyInputTypes T>.indexOf(element: @kotlin.internal.OnlyInputTypes T): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst(Ljava/util/List;Lkotlin/jvm/functions/Function1;)I
inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast(Ljava/util/List;Lkotlin/jvm/functions/Function1;)I
inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int

// JVM method = intersect(Ljava/lang/Iterable;Ljava/lang/Iterable;)Ljava/util/Set;
infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T>

// JVM method = joinTo(Ljava/lang/Iterable;Ljava/lang/Appendable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
fun <T, A : Appendable /* = java.lang.Appendable */> Iterable<T>.joinTo(buffer: A : Appendable /* = java.lang.Appendable */, separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((T) -> CharSequence)? /* = default */): A : Appendable /* = java.lang.Appendable */

// JVM method = joinToString(Ljava/lang/Iterable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
fun <T> Iterable<T>.joinToString(separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((T) -> CharSequence)? /* = default */): String

// JVM method = last(Ljava/lang/Iterable;)Ljava/lang/Object;
fun <T> Iterable<T>.last(): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T

// JVM method = last(Ljava/util/List;)Ljava/lang/Object;
fun <T> List<T>.last(): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last(Ljava/util/List;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> List<T>.last(predicate: (T) -> Boolean): T

// JVM method = lastIndexOf(Ljava/lang/Iterable;Ljava/lang/Object;)I
fun <@kotlin.internal.OnlyInputTypes T> Iterable<@kotlin.internal.OnlyInputTypes T>.lastIndexOf(element: @kotlin.internal.OnlyInputTypes T): Int

// JVM method = lastIndexOf(Ljava/util/List;Ljava/lang/Object;)I
fun <@kotlin.internal.OnlyInputTypes T> List<@kotlin.internal.OnlyInputTypes T>.lastIndexOf(element: @kotlin.internal.OnlyInputTypes T): Int

// JVM method = lastOrNull(Ljava/lang/Iterable;)Ljava/lang/Object;
fun <T> Iterable<T>.lastOrNull(): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T?

// JVM method = lastOrNull(Ljava/util/List;)Ljava/lang/Object;
fun <T> List<T>.lastOrNull(): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull(Ljava/util/List;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = map(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexed(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R> Iterable<T>.mapIndexed(transform: (@ParameterName(name = "index") Int, T) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedNotNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (@ParameterName(name = "index") Int, T) -> R : Any?): List<R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedNotNullTo(Ljava/lang/Iterable;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, R : Any, C : MutableCollection<in R : Any>> Iterable<T>.mapIndexedNotNullTo(destination: C : MutableCollection<in R : Any>, transform: (@ParameterName(name = "index") Int, T) -> R : Any?): C : MutableCollection<in R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedTo(Ljava/lang/Iterable;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, T) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapNotNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R : Any?): List<R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapNotNullTo(Ljava/lang/Iterable;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, R : Any, C : MutableCollection<in R : Any>> Iterable<T>.mapNotNullTo(destination: C : MutableCollection<in R : Any>, transform: (T) -> R : Any?): C : MutableCollection<in R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo(Ljava/lang/Iterable;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C : MutableCollection<in R>, transform: (T) -> R): C : MutableCollection<in R>

// JVM method = maxOrThrow(Ljava/lang/Iterable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Iterable<T : Comparable<T>>.max(): T : Comparable<T>

// JVM method = maxOrThrow(Ljava/lang/Iterable;)D
fun Iterable<Double>.max(): Double

// JVM method = maxOrThrow(Ljava/lang/Iterable;)F
fun Iterable<Float>.max(): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R : Comparable<R>): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R : Comparable<R>): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)D
inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)F
inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith(Ljava/lang/Iterable;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (T) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull(Ljava/lang/Iterable;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (T) -> R): R?

// JVM method = maxOrNull(Ljava/lang/Iterable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Iterable<T : Comparable<T>>.maxOrNull(): T : Comparable<T>?

// JVM method = maxOrNull(Ljava/lang/Iterable;)Ljava/lang/Double;
fun Iterable<Double>.maxOrNull(): Double?

// JVM method = maxOrNull(Ljava/lang/Iterable;)Ljava/lang/Float;
fun Iterable<Float>.maxOrNull(): Float?

// JVM method = maxWithOrThrow(Ljava/lang/Iterable;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Iterable<T>.maxWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T

// JVM method = maxWithOrNull(Ljava/lang/Iterable;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T?

// JVM method = minOrThrow(Ljava/lang/Iterable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Iterable<T : Comparable<T>>.min(): T : Comparable<T>

// JVM method = minOrThrow(Ljava/lang/Iterable;)D
fun Iterable<Double>.min(): Double

// JVM method = minOrThrow(Ljava/lang/Iterable;)F
fun Iterable<Float>.min(): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R : Comparable<R>): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R : Comparable<R>): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)D
inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)F
inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith(Ljava/lang/Iterable;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (T) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull(Ljava/lang/Iterable;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (T) -> R): R?

// JVM method = minOrNull(Ljava/lang/Iterable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Iterable<T : Comparable<T>>.minOrNull(): T : Comparable<T>?

// JVM method = minOrNull(Ljava/lang/Iterable;)Ljava/lang/Double;
fun Iterable<Double>.minOrNull(): Double?

// JVM method = minOrNull(Ljava/lang/Iterable;)Ljava/lang/Float;
fun Iterable<Float>.minOrNull(): Float?

// JVM method = minWithOrThrow(Ljava/lang/Iterable;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Iterable<T>.minWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T

// JVM method = minWithOrNull(Ljava/lang/Iterable;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T?

// JVM method = minus(Ljava/lang/Iterable;Ljava/lang/Object;)Ljava/util/List;
operator fun <T> Iterable<T>.minus(element: T): List<T>

// JVM method = minus(Ljava/lang/Iterable;[Ljava/lang/Object;)Ljava/util/List;
operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T>

// JVM method = minus(Ljava/lang/Iterable;Ljava/lang/Iterable;)Ljava/util/List;
operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T>

// JVM method = minus(Ljava/lang/Iterable;Lkotlin/sequences/Sequence;)Ljava/util/List;
operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T>

// JVM method = minusElement(Ljava/lang/Iterable;Ljava/lang/Object;)Ljava/util/List;
inline fun <T> Iterable<T>.minusElement(element: T): List<T>

// JVM method = none(Ljava/lang/Iterable;)Z
fun <T> Iterable<T>.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Z
inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEach(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Iterable;
inline fun <T, C : Iterable<T>> C : Iterable<T>.onEach(action: (T) -> Unit): C : Iterable<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEachIndexed(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/lang/Iterable;
inline fun <T, C : Iterable<T>> C : Iterable<T>.onEachIndexed(action: (@ParameterName(name = "index") Int, T) -> Unit): C : Iterable<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>>

// JVM method = plus(Ljava/util/Collection;Ljava/lang/Object;)Ljava/util/List;
operator fun <T> Collection<T>.plus(element: T): List<T>

// JVM method = plus(Ljava/util/Collection;[Ljava/lang/Object;)Ljava/util/List;
operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T>

// JVM method = plus(Ljava/util/Collection;Ljava/lang/Iterable;)Ljava/util/List;
operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T>

// JVM method = plus(Ljava/util/Collection;Lkotlin/sequences/Sequence;)Ljava/util/List;
operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T>

// JVM method = plus(Ljava/lang/Iterable;Ljava/lang/Object;)Ljava/util/List;
operator fun <T> Iterable<T>.plus(element: T): List<T>

// JVM method = plus(Ljava/lang/Iterable;[Ljava/lang/Object;)Ljava/util/List;
operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T>

// JVM method = plus(Ljava/lang/Iterable;Ljava/lang/Iterable;)Ljava/util/List;
operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T>

// JVM method = plus(Ljava/lang/Iterable;Lkotlin/sequences/Sequence;)Ljava/util/List;
operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T>

// JVM method = plusElement(Ljava/util/Collection;Ljava/lang/Object;)Ljava/util/List;
inline fun <T> Collection<T>.plusElement(element: T): List<T>

// JVM method = plusElement(Ljava/lang/Iterable;Ljava/lang/Object;)Ljava/util/List;
inline fun <T> Iterable<T>.plusElement(element: T): List<T>

// JVM method = random(Ljava/util/Collection;)Ljava/lang/Object;
inline fun <T> Collection<T>.random(): T

// JVM method = random(Ljava/util/Collection;Lkotlin/random/Random;)Ljava/lang/Object;
fun <T> Collection<T>.random(random: kotlin.random.Random): T

// JVM method = randomOrNull(Ljava/util/Collection;)Ljava/lang/Object;
inline fun <T> Collection<T>.randomOrNull(): T?

// JVM method = randomOrNull(Ljava/util/Collection;Lkotlin/random/Random;)Ljava/lang/Object;
fun <T> Collection<T>.randomOrNull(random: kotlin.random.Random): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <S, T : S> Iterable<T : S>.reduce(operation: (@ParameterName(name = "acc") S, T : S) -> S): S

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexed(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <S, T : S> Iterable<T : S>.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") S, T : S) -> S): S

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexedOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <S, T : S> Iterable<T : S>.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") S, T : S) -> S): S?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <S, T : S> Iterable<T : S>.reduceOrNull(operation: (@ParameterName(name = "acc") S, T : S) -> S): S?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRight(Ljava/util/List;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <S, T : S> List<T : S>.reduceRight(operation: (T : S, @ParameterName(name = "acc") S) -> S): S

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexed(Ljava/util/List;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <S, T : S> List<T : S>.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, T : S, @ParameterName(name = "acc") S) -> S): S

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull(Ljava/util/List;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <S, T : S> List<T : S>.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, T : S, @ParameterName(name = "acc") S) -> S): S?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightOrNull(Ljava/util/List;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <S, T : S> List<T : S>.reduceRightOrNull(operation: (T : S, @ParameterName(name = "acc") S) -> S): S?

// JVM method = requireNoNulls(Ljava/lang/Iterable;)Ljava/lang/Iterable;
fun <T : Any> Iterable<T : Any?>.requireNoNulls(): Iterable<T : Any>

// JVM method = requireNoNulls(Ljava/util/List;)Ljava/util/List;
fun <T : Any> List<T : Any?>.requireNoNulls(): List<T : Any>

// JVM method = reversed(Ljava/lang/Iterable;)Ljava/util/List;
fun <T> Iterable<T>.reversed(): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFold(Ljava/lang/Iterable;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, T) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFoldIndexed(Ljava/lang/Iterable;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, T) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduce(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <S, T : S> Iterable<T : S>.runningReduce(operation: (@ParameterName(name = "acc") S, T : S) -> S): List<S>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduceIndexed(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <S, T : S> Iterable<T : S>.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") S, T : S) -> S): List<S>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scan(Ljava/lang/Iterable;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R> Iterable<T>.scan(initial: R, operation: (@ParameterName(name = "acc") R, T) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scanIndexed(Ljava/lang/Iterable;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, T) -> R): List<R>

// JVM method = shuffle(Ljava/util/List;Lkotlin/random/Random;)V
fun <T> MutableList<T>.shuffle(random: kotlin.random.Random)

// JVM method = single(Ljava/lang/Iterable;)Ljava/lang/Object;
fun <T> Iterable<T>.single(): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = single(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T

// JVM method = single(Ljava/util/List;)Ljava/lang/Object;
fun <T> List<T>.single(): T

// JVM method = singleOrNull(Ljava/lang/Iterable;)Ljava/lang/Object;
fun <T> Iterable<T>.singleOrNull(): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = singleOrNull(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T?

// JVM method = singleOrNull(Ljava/util/List;)Ljava/lang/Object;
fun <T> List<T>.singleOrNull(): T?

// JVM method = slice(Ljava/util/List;Ljava/lang/Iterable;)Ljava/util/List;
fun <T> List<T>.slice(indices: Iterable<Int>): List<T>

// JVM method = slice(Ljava/util/List;Lkotlin/ranges/IntRange;)Ljava/util/List;
fun <T> List<T>.slice(indices: IntRange): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortBy(Ljava/util/List;Lkotlin/jvm/functions/Function1;)V
inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R : Comparable<R>?)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortByDescending(Ljava/util/List;Lkotlin/jvm/functions/Function1;)V
inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R : Comparable<R>?)

// JVM method = sortDescending(Ljava/util/List;)V
fun <T : Comparable<T>> MutableList<T : Comparable<T>>.sortDescending()

// JVM method = sorted(Ljava/lang/Iterable;)Ljava/util/List;
fun <T : Comparable<T>> Iterable<T : Comparable<T>>.sorted(): List<T : Comparable<T>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedBy(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R : Comparable<R>?): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedByDescending(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R : Comparable<R>?): List<T>

// JVM method = sortedDescending(Ljava/lang/Iterable;)Ljava/util/List;
fun <T : Comparable<T>> Iterable<T : Comparable<T>>.sortedDescending(): List<T : Comparable<T>>

// JVM method = sortedWith(Ljava/lang/Iterable;Ljava/util/Comparator;)Ljava/util/List;
fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): List<T>

// JVM method = subtract(Ljava/lang/Iterable;Ljava/lang/Iterable;)Ljava/util/Set;
infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T>

// JVM method = sumOfByte(Ljava/lang/Iterable;)I
fun Iterable<Byte>.sum(): Int

// JVM method = sumOfDouble(Ljava/lang/Iterable;)D
fun Iterable<Double>.sum(): Double

// JVM method = sumOfFloat(Ljava/lang/Iterable;)F
fun Iterable<Float>.sum(): Float

// JVM method = sumOfInt(Ljava/lang/Iterable;)I
fun Iterable<Int>.sum(): Int

// JVM method = sumOfLong(Ljava/lang/Iterable;)J
fun Iterable<Long>.sum(): Long

// JVM method = sumOfShort(Ljava/lang/Iterable;)I
fun Iterable<Short>.sum(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumBy(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumByDouble(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)D
inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfDouble(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)D
inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfInt(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfLong(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)J
inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)J
inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong

// JVM method = take(Ljava/lang/Iterable;I)Ljava/util/List;
fun <T> Iterable<T>.take(n: Int): List<T>

// JVM method = takeLast(Ljava/util/List;I)Ljava/util/List;
fun <T> List<T>.takeLast(n: Int): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeLastWhile(Ljava/util/List;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeWhile(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T>

// JVM method = toBooleanArray(Ljava/util/Collection;)[Z
fun Collection<Boolean>.toBooleanArray(): BooleanArray

// JVM method = toByteArray(Ljava/util/Collection;)[B
fun Collection<Byte>.toByteArray(): ByteArray

// JVM method = toCharArray(Ljava/util/Collection;)[C
fun Collection<Char>.toCharArray(): CharArray

// JVM method = toCollection(Ljava/lang/Iterable;Ljava/util/Collection;)Ljava/util/Collection;
fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C : MutableCollection<in T>): C : MutableCollection<in T>

// JVM method = toDoubleArray(Ljava/util/Collection;)[D
fun Collection<Double>.toDoubleArray(): DoubleArray

// JVM method = toFloatArray(Ljava/util/Collection;)[F
fun Collection<Float>.toFloatArray(): FloatArray

// JVM method = toHashSet(Ljava/lang/Iterable;)Ljava/util/HashSet;
fun <T> Iterable<T>.toHashSet(): HashSet<T> /* = java.util.HashSet<T> */

// JVM method = toIntArray(Ljava/util/Collection;)[I
fun Collection<Int>.toIntArray(): IntArray

// JVM method = toList(Ljava/lang/Iterable;)Ljava/util/List;
fun <T> Iterable<T>.toList(): List<T>

// JVM method = toLongArray(Ljava/util/Collection;)[J
fun Collection<Long>.toLongArray(): LongArray

// JVM method = toMutableList(Ljava/util/Collection;)Ljava/util/List;
fun <T> Collection<T>.toMutableList(): MutableList<T>

// JVM method = toMutableList(Ljava/lang/Iterable;)Ljava/util/List;
fun <T> Iterable<T>.toMutableList(): MutableList<T>

// JVM method = toMutableSet(Ljava/lang/Iterable;)Ljava/util/Set;
fun <T> Iterable<T>.toMutableSet(): MutableSet<T>

// JVM method = toSet(Ljava/lang/Iterable;)Ljava/util/Set;
fun <T> Iterable<T>.toSet(): Set<T>

// JVM method = toShortArray(Ljava/util/Collection;)[S
fun Collection<Short>.toShortArray(): ShortArray

// JVM method = union(Ljava/lang/Iterable;Ljava/lang/Iterable;)Ljava/util/Set;
infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T>

// JVM method = windowed(Ljava/lang/Iterable;IIZ)Ljava/util/List;
fun <T> Iterable<T>.windowed(size: Int, step: Int /* = default */, partialWindows: Boolean /* = default */): List<List<T>>

// JVM method = windowed(Ljava/lang/Iterable;IIZLkotlin/jvm/functions/Function1;)Ljava/util/List;
fun <T, R> Iterable<T>.windowed(size: Int, step: Int /* = default */, partialWindows: Boolean /* = default */, transform: (List<T>) -> R): List<R>

// JVM method = withIndex(Ljava/lang/Iterable;)Ljava/lang/Iterable;
fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>>

// JVM method = zip(Ljava/lang/Iterable;[Ljava/lang/Object;)Ljava/util/List;
infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip(Ljava/lang/Iterable;[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (@ParameterName(name = "a") T, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zip(Ljava/lang/Iterable;Ljava/lang/Iterable;)Ljava/util/List;
infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip(Ljava/lang/Iterable;Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") T, @ParameterName(name = "b") R) -> V): List<V>

// JVM method = zipWithNext(Ljava/lang/Iterable;)Ljava/util/List;
fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zipWithNext(Ljava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <T, R> Iterable<T>.zipWithNext(transform: (@ParameterName(name = "a") T, @ParameterName(name = "b") T) -> R): List<R>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.GroupingKt


// *** FUNCTIONS ***

// JVM method = eachCount(Lkotlin/collections/Grouping;)Ljava/util/Map;
fun <T, K> Grouping<T, K>.eachCount(): Map<K, Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapValuesInPlace(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
internal inline fun <K, V, R> MutableMap<K, V>.mapValuesInPlace(f: (Map.Entry<K, V>) -> R): MutableMap<K, R>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.GroupingKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = aggregate(Lkotlin/collections/Grouping;Lkotlin/jvm/functions/Function4;)Ljava/util/Map;
inline fun <T, K, R> Grouping<T, K>.aggregate(operation: (@ParameterName(name = "key") K, @ParameterName(name = "accumulator") R?, @ParameterName(name = "element") T, @ParameterName(name = "first") Boolean) -> R): Map<K, R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = aggregateTo(Lkotlin/collections/Grouping;Ljava/util/Map;Lkotlin/jvm/functions/Function4;)Ljava/util/Map;
inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.aggregateTo(destination: M : MutableMap<in K, R>, operation: (@ParameterName(name = "key") K, @ParameterName(name = "accumulator") R?, @ParameterName(name = "element") T, @ParameterName(name = "first") Boolean) -> R): M : MutableMap<in K, R>

// JVM method = eachCountTo(Lkotlin/collections/Grouping;Ljava/util/Map;)Ljava/util/Map;
fun <T, K, M : MutableMap<in K, Int>> Grouping<T, K>.eachCountTo(destination: M : MutableMap<in K, Int>): M : MutableMap<in K, Int>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold(Lkotlin/collections/Grouping;Lkotlin/jvm/functions/Function2;Lkotlin/jvm/functions/Function3;)Ljava/util/Map;
inline fun <T, K, R> Grouping<T, K>.fold(initialValueSelector: (@ParameterName(name = "key") K, @ParameterName(name = "element") T) -> R, operation: (@ParameterName(name = "key") K, @ParameterName(name = "accumulator") R, @ParameterName(name = "element") T) -> R): Map<K, R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold(Lkotlin/collections/Grouping;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/Map;
inline fun <T, K, R> Grouping<T, K>.fold(initialValue: R, operation: (@ParameterName(name = "accumulator") R, @ParameterName(name = "element") T) -> R): Map<K, R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldTo(Lkotlin/collections/Grouping;Ljava/util/Map;Lkotlin/jvm/functions/Function2;Lkotlin/jvm/functions/Function3;)Ljava/util/Map;
inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(destination: M : MutableMap<in K, R>, initialValueSelector: (@ParameterName(name = "key") K, @ParameterName(name = "element") T) -> R, operation: (@ParameterName(name = "key") K, @ParameterName(name = "accumulator") R, @ParameterName(name = "element") T) -> R): M : MutableMap<in K, R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldTo(Lkotlin/collections/Grouping;Ljava/util/Map;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/Map;
inline fun <T, K, R, M : MutableMap<in K, R>> Grouping<T, K>.foldTo(destination: M : MutableMap<in K, R>, initialValue: R, operation: (@ParameterName(name = "accumulator") R, @ParameterName(name = "element") T) -> R): M : MutableMap<in K, R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce(Lkotlin/collections/Grouping;Lkotlin/jvm/functions/Function3;)Ljava/util/Map;
inline fun <S, T : S, K> Grouping<T : S, K>.reduce(operation: (@ParameterName(name = "key") K, @ParameterName(name = "accumulator") S, @ParameterName(name = "element") T : S) -> S): Map<K, S>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceTo(Lkotlin/collections/Grouping;Ljava/util/Map;Lkotlin/jvm/functions/Function3;)Ljava/util/Map;
inline fun <S, T : S, K, M : MutableMap<in K, S>> Grouping<T : S, K>.reduceTo(destination: M : MutableMap<in K, S>, operation: (@ParameterName(name = "key") K, @ParameterName(name = "accumulator") S, @ParameterName(name = "element") T : S) -> S): M : MutableMap<in K, S>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.MapsKt


// *** FUNCTIONS ***

// JVM method = getOrImplicitDefaultNullable(Ljava/util/Map;Ljava/lang/Object;)Ljava/lang/Object;
internal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V

// JVM method = withDefault(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
fun <K, V> Map<K, V>.withDefault(defaultValue: (@ParameterName(name = "key") K) -> V): Map<K, V>

// JVM method = withDefaultMutable(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
fun <K, V> MutableMap<K, V>.withDefault(defaultValue: (@ParameterName(name = "key") K) -> V): MutableMap<K, V>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.MapsKt


// *** PROPERTIES ***

// JVM field = INT_MAX_POWER_OF_TWO:I
private const val INT_MAX_POWER_OF_TWO: Int


// *** FUNCTIONS ***

// JVM method = build(Ljava/util/Map;)Ljava/util/Map;
internal fun <K, V> build(builder: MutableMap<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildMapInternal(ILkotlin/jvm/functions/Function1;)Ljava/util/Map;
internal inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildMapInternal(Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
internal inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>

// JVM method = createMapBuilder()Ljava/util/Map;
internal fun <K, V> createMapBuilder(): MutableMap<K, V>

// JVM method = createMapBuilder(I)Ljava/util/Map;
internal fun <K, V> createMapBuilder(capacity: Int): MutableMap<K, V>

// JVM method = mapCapacity(I)I
internal fun mapCapacity(expectedSize: Int): Int

// JVM method = mapOf(Lkotlin/Pair;)Ljava/util/Map;
fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V>

// JVM method = sortedMapOf(Ljava/util/Comparator;[Lkotlin/Pair;)Ljava/util/SortedMap;
fun <K, V> sortedMapOf(comparator: java.util.Comparator<in K>, vararg pairs: Pair<K, V> /* Array<out Pair<K, V>> */): java.util.SortedMap<K, V>

// JVM method = sortedMapOf([Lkotlin/Pair;)Ljava/util/SortedMap;
fun <K : Comparable<K>, V> sortedMapOf(vararg pairs: Pair<K : Comparable<K>, V> /* Array<out Pair<K : Comparable<K>, V>> */): java.util.SortedMap<K : Comparable<K>, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrPut(Ljava/util/concurrent/ConcurrentMap;Ljava/lang/Object;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <K, V> java.util.concurrent.ConcurrentMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V

// JVM method = toProperties(Ljava/util/Map;)Ljava/util/Properties;
inline fun Map<String, String>.toProperties(): java.util.Properties

// JVM method = toSingletonMap(Ljava/util/Map;)Ljava/util/Map;
internal fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V>

// JVM method = toSingletonMapOrSelf(Ljava/util/Map;)Ljava/util/Map;
internal inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V>

// JVM method = toSortedMap(Ljava/util/Map;)Ljava/util/SortedMap;
fun <K : Comparable<K>, V> Map<out K : Comparable<K>, V>.toSortedMap(): java.util.SortedMap<K : Comparable<K>, V>

// JVM method = toSortedMap(Ljava/util/Map;Ljava/util/Comparator;)Ljava/util/SortedMap;
fun <K, V> Map<out K, V>.toSortedMap(comparator: java.util.Comparator<in K>): java.util.SortedMap<K, V>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.MapsKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildMap(ILkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> buildMap(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {
	contract {
		callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildMap(Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> buildMap(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {
	contract {
		callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE)
	}
}

// JVM method = emptyMap()Ljava/util/Map;
fun <K, V> emptyMap(): Map<K, V>

// JVM method = hashMapOf()Ljava/util/HashMap;
inline fun <K, V> hashMapOf(): HashMap<K, V> /* = java.util.HashMap<K, V> */

// JVM method = hashMapOf([Lkotlin/Pair;)Ljava/util/HashMap;
fun <K, V> hashMapOf(vararg pairs: Pair<K, V> /* Array<out Pair<K, V>> */): HashMap<K, V> /* = java.util.HashMap<K, V> */

// JVM method = linkedMapOf()Ljava/util/LinkedHashMap;
inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> /* = java.util.LinkedHashMap<K, V> */

// JVM method = linkedMapOf([Lkotlin/Pair;)Ljava/util/LinkedHashMap;
fun <K, V> linkedMapOf(vararg pairs: Pair<K, V> /* Array<out Pair<K, V>> */): LinkedHashMap<K, V> /* = java.util.LinkedHashMap<K, V> */

// JVM method = mapOf()Ljava/util/Map;
inline fun <K, V> mapOf(): Map<K, V>

// JVM method = mapOf([Lkotlin/Pair;)Ljava/util/Map;
fun <K, V> mapOf(vararg pairs: Pair<K, V> /* Array<out Pair<K, V>> */): Map<K, V>

// JVM method = mutableMapOf()Ljava/util/Map;
inline fun <K, V> mutableMapOf(): MutableMap<K, V>

// JVM method = mutableMapOf([Lkotlin/Pair;)Ljava/util/Map;
fun <K, V> mutableMapOf(vararg pairs: Pair<K, V> /* Array<out Pair<K, V>> */): MutableMap<K, V>

// JVM method = component1(Ljava/util/Map$Entry;)Ljava/lang/Object;
inline operator fun <K, V> Map.Entry<K, V>.component1(): K

// JVM method = component2(Ljava/util/Map$Entry;)Ljava/lang/Object;
inline operator fun <K, V> Map.Entry<K, V>.component2(): V

// JVM method = contains(Ljava/util/Map;Ljava/lang/Object;)Z
inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out @kotlin.internal.OnlyInputTypes K, V>.contains(key: @kotlin.internal.OnlyInputTypes K): Boolean

// JVM method = containsKey(Ljava/util/Map;Ljava/lang/Object;)Z
inline fun <@kotlin.internal.OnlyInputTypes K> Map<out @kotlin.internal.OnlyInputTypes K, *>.containsKey(key: @kotlin.internal.OnlyInputTypes K): Boolean

// JVM method = containsValue(Ljava/util/Map;Ljava/lang/Object;)Z
inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, @kotlin.internal.OnlyInputTypes V>.containsValue(value: @kotlin.internal.OnlyInputTypes V): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterKeys(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo(Ljava/util/Map;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M : MutableMap<in K, in V>, predicate: (Map.Entry<K, V>) -> Boolean): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo(Ljava/util/Map;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M : MutableMap<in K, in V>, predicate: (Map.Entry<K, V>) -> Boolean): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterValues(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V>

// JVM method = get(Ljava/util/Map;Ljava/lang/Object;)Ljava/lang/Object;
inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out @kotlin.internal.OnlyInputTypes K, V>.get(key: @kotlin.internal.OnlyInputTypes K): V?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElse(Ljava/util/Map;Ljava/lang/Object;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElseNullable(Ljava/util/Map;Ljava/lang/Object;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
internal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrPut(Ljava/util/Map;Ljava/lang/Object;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V

// JVM method = getValue(Ljava/util/Map;Ljava/lang/Object;)Ljava/lang/Object;
fun <K, V> Map<K, V>.getValue(key: K): V

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = ifEmpty(Ljava/util/Map;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where
	M : Map<*, *>,
	M : R

// JVM method = isNotEmpty(Ljava/util/Map;)Z
inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean

// JVM method = isNullOrEmpty(Ljava/util/Map;)Z
inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {
	contract {
		returns(false) implies (this@isNullOrEmpty != null)
	}
}

// JVM method = iterator(Ljava/util/Map;)Ljava/util/Iterator;
inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>>

// JVM method = mutableIterator(Ljava/util/Map;)Ljava/util/Iterator;
inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapKeys(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapKeysTo(Ljava/util/Map;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M : MutableMap<in R, in V>, transform: (Map.Entry<K, V>) -> R): M : MutableMap<in R, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapValues(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapValuesTo(Ljava/util/Map;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M : MutableMap<in K, in R>, transform: (Map.Entry<K, V>) -> R): M : MutableMap<in K, in R>

// JVM method = minus(Ljava/util/Map;Ljava/lang/Object;)Ljava/util/Map;
operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V>

// JVM method = minus(Ljava/util/Map;[Ljava/lang/Object;)Ljava/util/Map;
operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V>

// JVM method = minus(Ljava/util/Map;Ljava/lang/Iterable;)Ljava/util/Map;
operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V>

// JVM method = minus(Ljava/util/Map;Lkotlin/sequences/Sequence;)Ljava/util/Map;
operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V>

// JVM method = minusAssign(Ljava/util/Map;Ljava/lang/Object;)V
inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K)

// JVM method = minusAssign(Ljava/util/Map;[Ljava/lang/Object;)V
inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>)

// JVM method = minusAssign(Ljava/util/Map;Ljava/lang/Iterable;)V
inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>)

// JVM method = minusAssign(Ljava/util/Map;Lkotlin/sequences/Sequence;)V
inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>)

// JVM method = optimizeReadOnlyMap(Ljava/util/Map;)Ljava/util/Map;
internal fun <K, V> Map<K, V>.optimizeReadOnlyMap(): Map<K, V>

// JVM method = orEmpty(Ljava/util/Map;)Ljava/util/Map;
inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V>

// JVM method = plus(Ljava/util/Map;[Lkotlin/Pair;)Ljava/util/Map;
operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V>

// JVM method = plus(Ljava/util/Map;Lkotlin/Pair;)Ljava/util/Map;
operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V>

// JVM method = plus(Ljava/util/Map;Ljava/lang/Iterable;)Ljava/util/Map;
operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V>

// JVM method = plus(Ljava/util/Map;Ljava/util/Map;)Ljava/util/Map;
operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V>

// JVM method = plus(Ljava/util/Map;Lkotlin/sequences/Sequence;)Ljava/util/Map;
operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V>

// JVM method = plusAssign(Ljava/util/Map;[Lkotlin/Pair;)V
inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>)

// JVM method = plusAssign(Ljava/util/Map;Lkotlin/Pair;)V
inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>)

// JVM method = plusAssign(Ljava/util/Map;Ljava/lang/Iterable;)V
inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>)

// JVM method = plusAssign(Ljava/util/Map;Ljava/util/Map;)V
inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>)

// JVM method = plusAssign(Ljava/util/Map;Lkotlin/sequences/Sequence;)V
inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>)

// JVM method = putAll(Ljava/util/Map;[Lkotlin/Pair;)V
fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>)

// JVM method = putAll(Ljava/util/Map;Ljava/lang/Iterable;)V
fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>)

// JVM method = putAll(Ljava/util/Map;Lkotlin/sequences/Sequence;)V
fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>)

// JVM method = remove(Ljava/util/Map;Ljava/lang/Object;)Ljava/lang/Object;
inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out @kotlin.internal.OnlyInputTypes K, V>.remove(key: @kotlin.internal.OnlyInputTypes K): V?

// JVM method = set(Ljava/util/Map;Ljava/lang/Object;Ljava/lang/Object;)V
inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V)

// JVM method = toMap([Lkotlin/Pair;)Ljava/util/Map;
fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V>

// JVM method = toMap([Lkotlin/Pair;Ljava/util/Map;)Ljava/util/Map;
fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M : MutableMap<in K, in V>): M : MutableMap<in K, in V>

// JVM method = toMap(Ljava/lang/Iterable;)Ljava/util/Map;
fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V>

// JVM method = toMap(Ljava/lang/Iterable;Ljava/util/Map;)Ljava/util/Map;
fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M : MutableMap<in K, in V>): M : MutableMap<in K, in V>

// JVM method = toMap(Ljava/util/Map;)Ljava/util/Map;
fun <K, V> Map<out K, V>.toMap(): Map<K, V>

// JVM method = toMap(Ljava/util/Map;Ljava/util/Map;)Ljava/util/Map;
fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M : MutableMap<in K, in V>): M : MutableMap<in K, in V>

// JVM method = toMap(Lkotlin/sequences/Sequence;)Ljava/util/Map;
fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V>

// JVM method = toMap(Lkotlin/sequences/Sequence;Ljava/util/Map;)Ljava/util/Map;
fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M : MutableMap<in K, in V>): M : MutableMap<in K, in V>

// JVM method = toMutableMap(Ljava/util/Map;)Ljava/util/Map;
fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V>

// JVM method = toPair(Ljava/util/Map$Entry;)Lkotlin/Pair;
inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.MapsKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map$Entry;
inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxBy(selector: (Map.Entry<K, V>) -> R : Comparable<R>): Map.Entry<K, V>?

// JVM method = maxWith(Ljava/util/Map;Ljava/util/Comparator;)Ljava/util/Map$Entry;
inline fun <K, V> Map<out K, V>.maxWith(comparator: Comparator<in Map.Entry<K, V>> /* = java.util.Comparator<in Map.Entry<K, V>> */): Map.Entry<K, V>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map$Entry;
inline fun <K, V, R : Comparable<R>> Map<out K, V>.minBy(selector: (Map.Entry<K, V>) -> R : Comparable<R>): Map.Entry<K, V>?

// JVM method = minWith(Ljava/util/Map;Ljava/util/Comparator;)Ljava/util/Map$Entry;
fun <K, V> Map<out K, V>.minWith(comparator: Comparator<in Map.Entry<K, V>> /* = java.util.Comparator<in Map.Entry<K, V>> */): Map.Entry<K, V>?

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.MapsKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Z
inline fun <K, V> Map<out K, V>.all(predicate: (Map.Entry<K, V>) -> Boolean): Boolean

// JVM method = any(Ljava/util/Map;)Z
fun <K, V> Map<out K, V>.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Z
inline fun <K, V> Map<out K, V>.any(predicate: (Map.Entry<K, V>) -> Boolean): Boolean

// JVM method = asIterable(Ljava/util/Map;)Ljava/lang/Iterable;
inline fun <K, V> Map<out K, V>.asIterable(): Iterable<Map.Entry<K, V>>

// JVM method = asSequence(Ljava/util/Map;)Lkotlin/sequences/Sequence;
fun <K, V> Map<out K, V>.asSequence(): Sequence<Map.Entry<K, V>>

// JVM method = count(Ljava/util/Map;)I
inline fun <K, V> Map<out K, V>.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)I
inline fun <K, V> Map<out K, V>.count(predicate: (Map.Entry<K, V>) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstNotNullOf(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <K, V, R : Any> Map<out K, V>.firstNotNullOf(transform: (Map.Entry<K, V>) -> R : Any?): R : Any

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstNotNullOfOrNull(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <K, V, R : Any> Map<out K, V>.firstNotNullOfOrNull(transform: (Map.Entry<K, V>) -> R : Any?): R : Any?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMap(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapSequence(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Sequence<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo(Ljava/util/Map;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C : MutableCollection<in R>, transform: (Map.Entry<K, V>) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapSequenceTo(Ljava/util/Map;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C : MutableCollection<in R>, transform: (Map.Entry<K, V>) -> Sequence<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)V
inline fun <K, V> Map<out K, V>.forEach(action: (Map.Entry<K, V>) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = map(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <K, V, R> Map<out K, V>.map(transform: (Map.Entry<K, V>) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapNotNull(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <K, V, R : Any> Map<out K, V>.mapNotNull(transform: (Map.Entry<K, V>) -> R : Any?): List<R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapNotNullTo(Ljava/util/Map;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <K, V, R : Any, C : MutableCollection<in R : Any>> Map<out K, V>.mapNotNullTo(destination: C : MutableCollection<in R : Any>, transform: (Map.Entry<K, V>) -> R : Any?): C : MutableCollection<in R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo(Ljava/util/Map;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.mapTo(destination: C : MutableCollection<in R>, transform: (Map.Entry<K, V>) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map$Entry;
inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxBy(selector: (Map.Entry<K, V>) -> R : Comparable<R>): Map.Entry<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map$Entry;
inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxByOrNull(selector: (Map.Entry<K, V>) -> R : Comparable<R>): Map.Entry<K, V>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)D
inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)F
inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith(Ljava/util/Map;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <K, V, R> Map<out K, V>.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Map.Entry<K, V>) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull(Ljava/util/Map;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <K, V, R> Map<out K, V>.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Map.Entry<K, V>) -> R): R?

// JVM method = maxWithOrThrow(Ljava/util/Map;Ljava/util/Comparator;)Ljava/util/Map$Entry;
inline fun <K, V> Map<out K, V>.maxWith(comparator: Comparator<in Map.Entry<K, V>> /* = java.util.Comparator<in Map.Entry<K, V>> */): Map.Entry<K, V>

// JVM method = maxWithOrNull(Ljava/util/Map;Ljava/util/Comparator;)Ljava/util/Map$Entry;
inline fun <K, V> Map<out K, V>.maxWithOrNull(comparator: Comparator<in Map.Entry<K, V>> /* = java.util.Comparator<in Map.Entry<K, V>> */): Map.Entry<K, V>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map$Entry;
inline fun <K, V, R : Comparable<R>> Map<out K, V>.minBy(selector: (Map.Entry<K, V>) -> R : Comparable<R>): Map.Entry<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map$Entry;
inline fun <K, V, R : Comparable<R>> Map<out K, V>.minByOrNull(selector: (Map.Entry<K, V>) -> R : Comparable<R>): Map.Entry<K, V>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)D
inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)F
inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith(Ljava/util/Map;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <K, V, R> Map<out K, V>.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Map.Entry<K, V>) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull(Ljava/util/Map;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <K, V, R> Map<out K, V>.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Map.Entry<K, V>) -> R): R?

// JVM method = minWithOrThrow(Ljava/util/Map;Ljava/util/Comparator;)Ljava/util/Map$Entry;
inline fun <K, V> Map<out K, V>.minWith(comparator: Comparator<in Map.Entry<K, V>> /* = java.util.Comparator<in Map.Entry<K, V>> */): Map.Entry<K, V>

// JVM method = minWithOrNull(Ljava/util/Map;Ljava/util/Comparator;)Ljava/util/Map$Entry;
inline fun <K, V> Map<out K, V>.minWithOrNull(comparator: Comparator<in Map.Entry<K, V>> /* = java.util.Comparator<in Map.Entry<K, V>> */): Map.Entry<K, V>?

// JVM method = none(Ljava/util/Map;)Z
fun <K, V> Map<out K, V>.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Z
inline fun <K, V> Map<out K, V>.none(predicate: (Map.Entry<K, V>) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEach(Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : Map<out K, V>> M : Map<out K, V>.onEach(action: (Map.Entry<K, V>) -> Unit): M : Map<out K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEachIndexed(Ljava/util/Map;Lkotlin/jvm/functions/Function2;)Ljava/util/Map;
inline fun <K, V, M : Map<out K, V>> M : Map<out K, V>.onEachIndexed(action: (@ParameterName(name = "index") Int, Map.Entry<K, V>) -> Unit): M : Map<out K, V>

// JVM method = toList(Ljava/util/Map;)Ljava/util/List;
fun <K, V> Map<out K, V>.toList(): List<Pair<K, V>>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.SetsKt


// *** FUNCTIONS ***

// JVM method = build(Ljava/util/Set;)Ljava/util/Set;
internal fun <E> build(builder: MutableSet<E>): Set<E>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildSetInternal(ILkotlin/jvm/functions/Function1;)Ljava/util/Set;
internal inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildSetInternal(Lkotlin/jvm/functions/Function1;)Ljava/util/Set;
internal inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E>

// JVM method = createSetBuilder()Ljava/util/Set;
internal fun <E> createSetBuilder(): MutableSet<E>

// JVM method = createSetBuilder(I)Ljava/util/Set;
internal fun <E> createSetBuilder(capacity: Int): MutableSet<E>

// JVM method = setOf(Ljava/lang/Object;)Ljava/util/Set;
fun <T> setOf(element: T): Set<T>

// JVM method = sortedSetOf([Ljava/lang/Object;)Ljava/util/TreeSet;
fun <T> sortedSetOf(vararg elements: T /* Array<out T> */): java.util.TreeSet<T>

// JVM method = sortedSetOf(Ljava/util/Comparator;[Ljava/lang/Object;)Ljava/util/TreeSet;
fun <T> sortedSetOf(comparator: Comparator<in T> /* = java.util.Comparator<in T> */, vararg elements: T /* Array<out T> */): java.util.TreeSet<T>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.SetsKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildSet(ILkotlin/jvm/functions/Function1;)Ljava/util/Set;
inline fun <E> buildSet(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {
	contract {
		callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildSet(Lkotlin/jvm/functions/Function1;)Ljava/util/Set;
inline fun <E> buildSet(builderAction: MutableSet<E>.() -> Unit): Set<E> {
	contract {
		callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE)
	}
}

// JVM method = emptySet()Ljava/util/Set;
fun <T> emptySet(): Set<T>

// JVM method = hashSetOf()Ljava/util/HashSet;
inline fun <T> hashSetOf(): HashSet<T> /* = java.util.HashSet<T> */

// JVM method = hashSetOf([Ljava/lang/Object;)Ljava/util/HashSet;
fun <T> hashSetOf(vararg elements: T /* Array<out T> */): HashSet<T> /* = java.util.HashSet<T> */

// JVM method = linkedSetOf()Ljava/util/LinkedHashSet;
inline fun <T> linkedSetOf(): LinkedHashSet<T> /* = java.util.LinkedHashSet<T> */

// JVM method = linkedSetOf([Ljava/lang/Object;)Ljava/util/LinkedHashSet;
fun <T> linkedSetOf(vararg elements: T /* Array<out T> */): LinkedHashSet<T> /* = java.util.LinkedHashSet<T> */

// JVM method = mutableSetOf()Ljava/util/Set;
inline fun <T> mutableSetOf(): MutableSet<T>

// JVM method = mutableSetOf([Ljava/lang/Object;)Ljava/util/Set;
fun <T> mutableSetOf(vararg elements: T /* Array<out T> */): MutableSet<T>

// JVM method = setOf()Ljava/util/Set;
inline fun <T> setOf(): Set<T>

// JVM method = setOf([Ljava/lang/Object;)Ljava/util/Set;
fun <T> setOf(vararg elements: T /* Array<out T> */): Set<T>

// JVM method = setOfNotNull(Ljava/lang/Object;)Ljava/util/Set;
fun <T : Any> setOfNotNull(element: T : Any?): Set<T : Any>

// JVM method = setOfNotNull([Ljava/lang/Object;)Ljava/util/Set;
fun <T : Any> setOfNotNull(vararg elements: T : Any? /* Array<out T : Any?> */): Set<T : Any>

// JVM method = optimizeReadOnlySet(Ljava/util/Set;)Ljava/util/Set;
internal fun <T> Set<T>.optimizeReadOnlySet(): Set<T>

// JVM method = orEmpty(Ljava/util/Set;)Ljava/util/Set;
inline fun <T> Set<T>?.orEmpty(): Set<T>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.SetsKt


// *** FUNCTIONS ***

// JVM method = minus(Ljava/util/Set;Ljava/lang/Object;)Ljava/util/Set;
operator fun <T> Set<T>.minus(element: T): Set<T>

// JVM method = minus(Ljava/util/Set;[Ljava/lang/Object;)Ljava/util/Set;
operator fun <T> Set<T>.minus(elements: Array<out T>): Set<T>

// JVM method = minus(Ljava/util/Set;Ljava/lang/Iterable;)Ljava/util/Set;
operator fun <T> Set<T>.minus(elements: Iterable<T>): Set<T>

// JVM method = minus(Ljava/util/Set;Lkotlin/sequences/Sequence;)Ljava/util/Set;
operator fun <T> Set<T>.minus(elements: Sequence<T>): Set<T>

// JVM method = minusElement(Ljava/util/Set;Ljava/lang/Object;)Ljava/util/Set;
inline fun <T> Set<T>.minusElement(element: T): Set<T>

// JVM method = plus(Ljava/util/Set;Ljava/lang/Object;)Ljava/util/Set;
operator fun <T> Set<T>.plus(element: T): Set<T>

// JVM method = plus(Ljava/util/Set;[Ljava/lang/Object;)Ljava/util/Set;
operator fun <T> Set<T>.plus(elements: Array<out T>): Set<T>

// JVM method = plus(Ljava/util/Set;Ljava/lang/Iterable;)Ljava/util/Set;
operator fun <T> Set<T>.plus(elements: Iterable<T>): Set<T>

// JVM method = plus(Ljava/util/Set;Lkotlin/sequences/Sequence;)Ljava/util/Set;
operator fun <T> Set<T>.plus(elements: Sequence<T>): Set<T>

// JVM method = plusElement(Ljava/util/Set;Ljava/lang/Object;)Ljava/util/Set;
inline fun <T> Set<T>.plusElement(element: T): Set<T>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.collections.UCollectionsKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUByte(Ljava/lang/Iterable;)I
fun Iterable<UByte>.sum(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt(Ljava/lang/Iterable;)I
fun Iterable<UInt>.sum(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong(Ljava/lang/Iterable;)J
fun Iterable<ULong>.sum(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUShort(Ljava/lang/Iterable;)I
fun Iterable<UShort>.sum(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUByteArray(Ljava/util/Collection;)[B
fun Collection<UByte>.toUByteArray(): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUIntArray(Ljava/util/Collection;)[I
fun Collection<UInt>.toUIntArray(): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULongArray(Ljava/util/Collection;)[J
fun Collection<ULong>.toULongArray(): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUShortArray(Ljava/util/Collection;)[S
fun Collection<UShort>.toUShortArray(): UShortArray

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

// JVM: kotlin/collections/unsigned/UArraysKt
/* facade */ class kotlin.collections.UArraysKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = asList-GBYM_sE([B)Ljava/util/List;
fun UByteArray.asList(): List<UByte>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = asList--ajY-9A([I)Ljava/util/List;
fun UIntArray.asList(): List<UInt>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = asList-QwZRm1k([J)Ljava/util/List;
fun ULongArray.asList(): List<ULong>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = asList-rL5Bavg([S)Ljava/util/List;
fun UShortArray.asList(): List<UShort>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = binarySearch-WpHrYlw([BBII)I
fun UByteArray.binarySearch(element: UByte, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = binarySearch-2fe2U9s([IIII)I
fun UIntArray.binarySearch(element: UInt, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = binarySearch-K6DWlUc([JJII)I
fun ULongArray.binarySearch(element: ULong, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = binarySearch-EtDCXyQ([SSII)I
fun UShortArray.binarySearch(element: UShort, fromIndex: Int /* = default */, toIndex: Int /* = default */): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = elementAt-PpDY95g([BI)B
inline fun UByteArray.elementAt(index: Int): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = elementAt-qFRl0hI([II)I
inline fun UIntArray.elementAt(index: Int): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = elementAt-r7IrZao([JI)J
inline fun ULongArray.elementAt(index: Int): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = elementAt-nggk6HY([SI)S
inline fun UShortArray.elementAt(index: Int): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = max-GBYM_sE([B)Lkotlin/UByte;
fun UByteArray.max(): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = max--ajY-9A([I)Lkotlin/UInt;
fun UIntArray.max(): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = max-QwZRm1k([J)Lkotlin/ULong;
fun ULongArray.max(): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = max-rL5Bavg([S)Lkotlin/UShort;
fun UShortArray.max(): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxBy-JOV_ifY([BLkotlin/jvm/functions/Function1;)Lkotlin/UByte;
inline fun <R : Comparable<R>> UByteArray.maxBy(selector: (UByte) -> R : Comparable<R>): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxBy-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Lkotlin/UInt;
inline fun <R : Comparable<R>> UIntArray.maxBy(selector: (UInt) -> R : Comparable<R>): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxBy-MShoTSo([JLkotlin/jvm/functions/Function1;)Lkotlin/ULong;
inline fun <R : Comparable<R>> ULongArray.maxBy(selector: (ULong) -> R : Comparable<R>): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxBy-xTcfx_M([SLkotlin/jvm/functions/Function1;)Lkotlin/UShort;
inline fun <R : Comparable<R>> UShortArray.maxBy(selector: (UShort) -> R : Comparable<R>): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxWith-XMRcp5o([BLjava/util/Comparator;)Lkotlin/UByte;
fun UByteArray.maxWith(comparator: Comparator<in UByte> /* = java.util.Comparator<in UByte> */): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxWith-YmdZ_VM([ILjava/util/Comparator;)Lkotlin/UInt;
fun UIntArray.maxWith(comparator: Comparator<in UInt> /* = java.util.Comparator<in UInt> */): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxWith-zrEWJaI([JLjava/util/Comparator;)Lkotlin/ULong;
fun ULongArray.maxWith(comparator: Comparator<in ULong> /* = java.util.Comparator<in ULong> */): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxWith-eOHTfZs([SLjava/util/Comparator;)Lkotlin/UShort;
fun UShortArray.maxWith(comparator: Comparator<in UShort> /* = java.util.Comparator<in UShort> */): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = min-GBYM_sE([B)Lkotlin/UByte;
fun UByteArray.min(): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = min--ajY-9A([I)Lkotlin/UInt;
fun UIntArray.min(): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = min-QwZRm1k([J)Lkotlin/ULong;
fun ULongArray.min(): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = min-rL5Bavg([S)Lkotlin/UShort;
fun UShortArray.min(): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minBy-JOV_ifY([BLkotlin/jvm/functions/Function1;)Lkotlin/UByte;
inline fun <R : Comparable<R>> UByteArray.minBy(selector: (UByte) -> R : Comparable<R>): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minBy-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Lkotlin/UInt;
inline fun <R : Comparable<R>> UIntArray.minBy(selector: (UInt) -> R : Comparable<R>): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minBy-MShoTSo([JLkotlin/jvm/functions/Function1;)Lkotlin/ULong;
inline fun <R : Comparable<R>> ULongArray.minBy(selector: (ULong) -> R : Comparable<R>): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minBy-xTcfx_M([SLkotlin/jvm/functions/Function1;)Lkotlin/UShort;
inline fun <R : Comparable<R>> UShortArray.minBy(selector: (UShort) -> R : Comparable<R>): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minWith-XMRcp5o([BLjava/util/Comparator;)Lkotlin/UByte;
fun UByteArray.minWith(comparator: Comparator<in UByte> /* = java.util.Comparator<in UByte> */): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minWith-YmdZ_VM([ILjava/util/Comparator;)Lkotlin/UInt;
fun UIntArray.minWith(comparator: Comparator<in UInt> /* = java.util.Comparator<in UInt> */): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minWith-zrEWJaI([JLjava/util/Comparator;)Lkotlin/ULong;
fun ULongArray.minWith(comparator: Comparator<in ULong> /* = java.util.Comparator<in ULong> */): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minWith-eOHTfZs([SLjava/util/Comparator;)Lkotlin/UShort;
fun UShortArray.minWith(comparator: Comparator<in UShort> /* = java.util.Comparator<in UShort> */): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfBigDecimal([BLkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun UByteArray.sumOf(selector: (UByte) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfBigInteger([BLkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun UByteArray.sumOf(selector: (UByte) -> java.math.BigInteger): java.math.BigInteger

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfBigDecimal([ILkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun UIntArray.sumOf(selector: (UInt) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfBigInteger([ILkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun UIntArray.sumOf(selector: (UInt) -> java.math.BigInteger): java.math.BigInteger

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfBigDecimal([JLkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun ULongArray.sumOf(selector: (ULong) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfBigInteger([JLkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun ULongArray.sumOf(selector: (ULong) -> java.math.BigInteger): java.math.BigInteger

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfBigDecimal([SLkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun UShortArray.sumOf(selector: (UShort) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfBigInteger([SLkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun UShortArray.sumOf(selector: (UShort) -> java.math.BigInteger): java.math.BigInteger

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

// JVM: kotlin/collections/unsigned/UArraysKt
/* facade */ class kotlin.collections.UArraysKt


// *** PROPERTIES ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getIndices-GBYM_sE$annotations([B)V
inline val UByteArray.indices: IntRange
	// JVM method = getIndices-GBYM_sE([B)Lkotlin/ranges/IntRange;
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getIndices--ajY-9A$annotations([I)V
inline val UIntArray.indices: IntRange
	// JVM method = getIndices--ajY-9A([I)Lkotlin/ranges/IntRange;
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getIndices-QwZRm1k$annotations([J)V
inline val ULongArray.indices: IntRange
	// JVM method = getIndices-QwZRm1k([J)Lkotlin/ranges/IntRange;
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getIndices-rL5Bavg$annotations([S)V
inline val UShortArray.indices: IntRange
	// JVM method = getIndices-rL5Bavg([S)Lkotlin/ranges/IntRange;
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getLastIndex-GBYM_sE$annotations([B)V
inline val UByteArray.lastIndex: Int
	// JVM method = getLastIndex-GBYM_sE([B)I
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getLastIndex--ajY-9A$annotations([I)V
inline val UIntArray.lastIndex: Int
	// JVM method = getLastIndex--ajY-9A([I)I
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getLastIndex-QwZRm1k$annotations([J)V
inline val ULongArray.lastIndex: Int
	// JVM method = getLastIndex-QwZRm1k([J)I
	get() = /* non-default */

// requires language version >= 1.3, otherwise diagnostic error
// JVM annotation-holding method = getLastIndex-rL5Bavg$annotations([S)V
inline val UShortArray.lastIndex: Int
	// JVM method = getLastIndex-rL5Bavg([S)I
	get() = /* non-default */


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = all-JOV_ifY([BLkotlin/jvm/functions/Function1;)Z
inline fun UByteArray.all(predicate: (UByte) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = all-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Z
inline fun UIntArray.all(predicate: (UInt) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = all-MShoTSo([JLkotlin/jvm/functions/Function1;)Z
inline fun ULongArray.all(predicate: (ULong) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = all-xTcfx_M([SLkotlin/jvm/functions/Function1;)Z
inline fun UShortArray.all(predicate: (UShort) -> Boolean): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = any-GBYM_sE([B)Z
inline fun UByteArray.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = any-JOV_ifY([BLkotlin/jvm/functions/Function1;)Z
inline fun UByteArray.any(predicate: (UByte) -> Boolean): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = any--ajY-9A([I)Z
inline fun UIntArray.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = any-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Z
inline fun UIntArray.any(predicate: (UInt) -> Boolean): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = any-QwZRm1k([J)Z
inline fun ULongArray.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = any-MShoTSo([JLkotlin/jvm/functions/Function1;)Z
inline fun ULongArray.any(predicate: (ULong) -> Boolean): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = any-rL5Bavg([S)Z
inline fun UShortArray.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = any-xTcfx_M([SLkotlin/jvm/functions/Function1;)Z
inline fun UShortArray.any(predicate: (UShort) -> Boolean): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = asByteArray-GBYM_sE([B)[B
inline fun UByteArray.asByteArray(): ByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = asIntArray--ajY-9A([I)[I
inline fun UIntArray.asIntArray(): IntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = asLongArray-QwZRm1k([J)[J
inline fun ULongArray.asLongArray(): LongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = asShortArray-rL5Bavg([S)[S
inline fun UShortArray.asShortArray(): ShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = asUByteArray([B)[B
inline fun ByteArray.asUByteArray(): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = asUIntArray([I)[I
inline fun IntArray.asUIntArray(): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = asULongArray([J)[J
inline fun LongArray.asULongArray(): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = asUShortArray([S)[S
inline fun ShortArray.asUShortArray(): UShortArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = associateWith-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> UByteArray.associateWith(valueSelector: (UByte) -> V): Map<UByte, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = associateWith-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> UIntArray.associateWith(valueSelector: (UInt) -> V): Map<UInt, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = associateWith-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> ULongArray.associateWith(valueSelector: (ULong) -> V): Map<ULong, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = associateWith-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> UShortArray.associateWith(valueSelector: (UShort) -> V): Map<UShort, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = associateWithTo-H21X9dk([BLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in UByte, in V>> UByteArray.associateWithTo(destination: M : MutableMap<in UByte, in V>, valueSelector: (UByte) -> V): M : MutableMap<in UByte, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = associateWithTo-4D70W2E([ILjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in UInt, in V>> UIntArray.associateWithTo(destination: M : MutableMap<in UInt, in V>, valueSelector: (UInt) -> V): M : MutableMap<in UInt, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = associateWithTo-X6OPwNk([JLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in ULong, in V>> ULongArray.associateWithTo(destination: M : MutableMap<in ULong, in V>, valueSelector: (ULong) -> V): M : MutableMap<in ULong, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = associateWithTo-ciTST-8([SLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in UShort, in V>> UShortArray.associateWithTo(destination: M : MutableMap<in UShort, in V>, valueSelector: (UShort) -> V): M : MutableMap<in UShort, in V>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component1-GBYM_sE([B)B
inline operator fun UByteArray.component1(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component1--ajY-9A([I)I
inline operator fun UIntArray.component1(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component1-QwZRm1k([J)J
inline operator fun ULongArray.component1(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component1-rL5Bavg([S)S
inline operator fun UShortArray.component1(): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component2-GBYM_sE([B)B
inline operator fun UByteArray.component2(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component2--ajY-9A([I)I
inline operator fun UIntArray.component2(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component2-QwZRm1k([J)J
inline operator fun ULongArray.component2(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component2-rL5Bavg([S)S
inline operator fun UShortArray.component2(): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component3-GBYM_sE([B)B
inline operator fun UByteArray.component3(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component3--ajY-9A([I)I
inline operator fun UIntArray.component3(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component3-QwZRm1k([J)J
inline operator fun ULongArray.component3(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component3-rL5Bavg([S)S
inline operator fun UShortArray.component3(): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component4-GBYM_sE([B)B
inline operator fun UByteArray.component4(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component4--ajY-9A([I)I
inline operator fun UIntArray.component4(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component4-QwZRm1k([J)J
inline operator fun ULongArray.component4(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component4-rL5Bavg([S)S
inline operator fun UShortArray.component4(): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component5-GBYM_sE([B)B
inline operator fun UByteArray.component5(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component5--ajY-9A([I)I
inline operator fun UIntArray.component5(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component5-QwZRm1k([J)J
inline operator fun ULongArray.component5(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = component5-rL5Bavg([S)S
inline operator fun UShortArray.component5(): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentEquals-kdPth3s([B[B)Z
infix fun UByteArray.contentEquals(other: UByteArray): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentEquals-kV0jMPg([B[B)Z
infix fun UByteArray?.contentEquals(other: UByteArray?): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentEquals-ctEhBpI([I[I)Z
infix fun UIntArray.contentEquals(other: UIntArray): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentEquals-KJPZfPQ([I[I)Z
infix fun UIntArray?.contentEquals(other: UIntArray?): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentEquals-us8wMrg([J[J)Z
infix fun ULongArray.contentEquals(other: ULongArray): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentEquals-lec5QzE([J[J)Z
infix fun ULongArray?.contentEquals(other: ULongArray?): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentEquals-mazbYpA([S[S)Z
infix fun UShortArray.contentEquals(other: UShortArray): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentEquals-FGO6Aew([S[S)Z
infix fun UShortArray?.contentEquals(other: UShortArray?): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentHashCode-GBYM_sE([B)I
fun UByteArray.contentHashCode(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentHashCode-2csIQuQ([B)I
fun UByteArray?.contentHashCode(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentHashCode--ajY-9A([I)I
fun UIntArray.contentHashCode(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentHashCode-XUkPCBk([I)I
fun UIntArray?.contentHashCode(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentHashCode-QwZRm1k([J)I
fun ULongArray.contentHashCode(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentHashCode-uLth9ew([J)I
fun ULongArray?.contentHashCode(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentHashCode-rL5Bavg([S)I
fun UShortArray.contentHashCode(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentHashCode-d-6D3K8([S)I
fun UShortArray?.contentHashCode(): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentToString-GBYM_sE([B)Ljava/lang/String;
fun UByteArray.contentToString(): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentToString-2csIQuQ([B)Ljava/lang/String;
fun UByteArray?.contentToString(): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentToString--ajY-9A([I)Ljava/lang/String;
fun UIntArray.contentToString(): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentToString-XUkPCBk([I)Ljava/lang/String;
fun UIntArray?.contentToString(): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentToString-QwZRm1k([J)Ljava/lang/String;
fun ULongArray.contentToString(): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentToString-uLth9ew([J)Ljava/lang/String;
fun ULongArray?.contentToString(): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentToString-rL5Bavg([S)Ljava/lang/String;
fun UShortArray.contentToString(): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contentToString-d-6D3K8([S)Ljava/lang/String;
fun UShortArray?.contentToString(): String

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyInto-FUQE5sA([B[BIII)[B
inline fun UByteArray.copyInto(destination: UByteArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyInto-sIZ3KeM([I[IIII)[I
inline fun UIntArray.copyInto(destination: UIntArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyInto--B0-L2c([J[JIII)[J
inline fun ULongArray.copyInto(destination: ULongArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyInto-9-ak10g([S[SIII)[S
inline fun UShortArray.copyInto(destination: UShortArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyOf-GBYM_sE([B)[B
inline fun UByteArray.copyOf(): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyOf-PpDY95g([BI)[B
inline fun UByteArray.copyOf(newSize: Int): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyOf--ajY-9A([I)[I
inline fun UIntArray.copyOf(): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyOf-qFRl0hI([II)[I
inline fun UIntArray.copyOf(newSize: Int): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyOf-QwZRm1k([J)[J
inline fun ULongArray.copyOf(): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyOf-r7IrZao([JI)[J
inline fun ULongArray.copyOf(newSize: Int): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyOf-rL5Bavg([S)[S
inline fun UShortArray.copyOf(): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyOf-nggk6HY([SI)[S
inline fun UShortArray.copyOf(newSize: Int): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyOfRange-4UcCI2c([BII)[B
inline fun UByteArray.copyOfRange(fromIndex: Int, toIndex: Int): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyOfRange-oBK06Vg([III)[I
inline fun UIntArray.copyOfRange(fromIndex: Int, toIndex: Int): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyOfRange--nroSd4([JII)[J
inline fun ULongArray.copyOfRange(fromIndex: Int, toIndex: Int): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = copyOfRange-Aa5vz7o([SII)[S
inline fun UShortArray.copyOfRange(fromIndex: Int, toIndex: Int): UShortArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = count-JOV_ifY([BLkotlin/jvm/functions/Function1;)I
inline fun UByteArray.count(predicate: (UByte) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = count-jgv0xPQ([ILkotlin/jvm/functions/Function1;)I
inline fun UIntArray.count(predicate: (UInt) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = count-MShoTSo([JLkotlin/jvm/functions/Function1;)I
inline fun ULongArray.count(predicate: (ULong) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = count-xTcfx_M([SLkotlin/jvm/functions/Function1;)I
inline fun UShortArray.count(predicate: (UShort) -> Boolean): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = drop-PpDY95g([BI)Ljava/util/List;
fun UByteArray.drop(n: Int): List<UByte>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = drop-qFRl0hI([II)Ljava/util/List;
fun UIntArray.drop(n: Int): List<UInt>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = drop-r7IrZao([JI)Ljava/util/List;
fun ULongArray.drop(n: Int): List<ULong>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = drop-nggk6HY([SI)Ljava/util/List;
fun UShortArray.drop(n: Int): List<UShort>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = dropLast-PpDY95g([BI)Ljava/util/List;
fun UByteArray.dropLast(n: Int): List<UByte>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = dropLast-qFRl0hI([II)Ljava/util/List;
fun UIntArray.dropLast(n: Int): List<UInt>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = dropLast-r7IrZao([JI)Ljava/util/List;
fun ULongArray.dropLast(n: Int): List<ULong>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = dropLast-nggk6HY([SI)Ljava/util/List;
fun UShortArray.dropLast(n: Int): List<UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = dropLastWhile-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UByteArray.dropLastWhile(predicate: (UByte) -> Boolean): List<UByte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = dropLastWhile-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UIntArray.dropLastWhile(predicate: (UInt) -> Boolean): List<UInt>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = dropLastWhile-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ULongArray.dropLastWhile(predicate: (ULong) -> Boolean): List<ULong>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = dropLastWhile-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UShortArray.dropLastWhile(predicate: (UShort) -> Boolean): List<UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = dropWhile-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UByteArray.dropWhile(predicate: (UByte) -> Boolean): List<UByte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = dropWhile-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UIntArray.dropWhile(predicate: (UInt) -> Boolean): List<UInt>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = dropWhile-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ULongArray.dropWhile(predicate: (ULong) -> Boolean): List<ULong>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = dropWhile-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UShortArray.dropWhile(predicate: (UShort) -> Boolean): List<UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = elementAtOrElse-cO-VybQ([BILkotlin/jvm/functions/Function1;)B
inline fun UByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UByte): UByte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = elementAtOrElse-QxvSvLU([IILkotlin/jvm/functions/Function1;)I
inline fun UIntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = elementAtOrElse-Xw8i6dc([JILkotlin/jvm/functions/Function1;)J
inline fun ULongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = elementAtOrElse-CVVdw08([SILkotlin/jvm/functions/Function1;)S
inline fun UShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UShort): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = elementAtOrNull-PpDY95g([BI)Lkotlin/UByte;
inline fun UByteArray.elementAtOrNull(index: Int): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = elementAtOrNull-qFRl0hI([II)Lkotlin/UInt;
inline fun UIntArray.elementAtOrNull(index: Int): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = elementAtOrNull-r7IrZao([JI)Lkotlin/ULong;
inline fun ULongArray.elementAtOrNull(index: Int): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = elementAtOrNull-nggk6HY([SI)Lkotlin/UShort;
inline fun UShortArray.elementAtOrNull(index: Int): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = fill-WpHrYlw([BBII)V
fun UByteArray.fill(element: UByte, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = fill-2fe2U9s([IIII)V
fun UIntArray.fill(element: UInt, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = fill-K6DWlUc([JJII)V
fun ULongArray.fill(element: ULong, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = fill-EtDCXyQ([SSII)V
fun UShortArray.fill(element: UShort, fromIndex: Int /* = default */, toIndex: Int /* = default */)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filter-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UByteArray.filter(predicate: (UByte) -> Boolean): List<UByte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filter-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UIntArray.filter(predicate: (UInt) -> Boolean): List<UInt>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filter-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ULongArray.filter(predicate: (ULong) -> Boolean): List<ULong>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filter-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UShortArray.filter(predicate: (UShort) -> Boolean): List<UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterIndexed-ELGow60([BLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun UByteArray.filterIndexed(predicate: (@ParameterName(name = "index") Int, UByte) -> Boolean): List<UByte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterIndexed-WyvcNBI([ILkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun UIntArray.filterIndexed(predicate: (@ParameterName(name = "index") Int, UInt) -> Boolean): List<UInt>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterIndexed-s8dVfGU([JLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun ULongArray.filterIndexed(predicate: (@ParameterName(name = "index") Int, ULong) -> Boolean): List<ULong>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterIndexed-xzaTVY8([SLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun UShortArray.filterIndexed(predicate: (@ParameterName(name = "index") Int, UShort) -> Boolean): List<UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterIndexedTo-eNpIKz8([BLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <C : MutableCollection<in UByte>> UByteArray.filterIndexedTo(destination: C : MutableCollection<in UByte>, predicate: (@ParameterName(name = "index") Int, UByte) -> Boolean): C : MutableCollection<in UByte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterIndexedTo--6EtJGI([ILjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <C : MutableCollection<in UInt>> UIntArray.filterIndexedTo(destination: C : MutableCollection<in UInt>, predicate: (@ParameterName(name = "index") Int, UInt) -> Boolean): C : MutableCollection<in UInt>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterIndexedTo-pe2Q0Dw([JLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <C : MutableCollection<in ULong>> ULongArray.filterIndexedTo(destination: C : MutableCollection<in ULong>, predicate: (@ParameterName(name = "index") Int, ULong) -> Boolean): C : MutableCollection<in ULong>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterIndexedTo-QqktQ3k([SLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <C : MutableCollection<in UShort>> UShortArray.filterIndexedTo(destination: C : MutableCollection<in UShort>, predicate: (@ParameterName(name = "index") Int, UShort) -> Boolean): C : MutableCollection<in UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterNot-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UByteArray.filterNot(predicate: (UByte) -> Boolean): List<UByte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterNot-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UIntArray.filterNot(predicate: (UInt) -> Boolean): List<UInt>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterNot-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ULongArray.filterNot(predicate: (ULong) -> Boolean): List<ULong>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterNot-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UShortArray.filterNot(predicate: (UShort) -> Boolean): List<UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterNotTo-wzUQCXU([BLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in UByte>> UByteArray.filterNotTo(destination: C : MutableCollection<in UByte>, predicate: (UByte) -> Boolean): C : MutableCollection<in UByte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterNotTo-wU5IKMo([ILjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in UInt>> UIntArray.filterNotTo(destination: C : MutableCollection<in UInt>, predicate: (UInt) -> Boolean): C : MutableCollection<in UInt>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterNotTo-HqK1JgA([JLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in ULong>> ULongArray.filterNotTo(destination: C : MutableCollection<in ULong>, predicate: (ULong) -> Boolean): C : MutableCollection<in ULong>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterNotTo-oEOeDjA([SLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in UShort>> UShortArray.filterNotTo(destination: C : MutableCollection<in UShort>, predicate: (UShort) -> Boolean): C : MutableCollection<in UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterTo-wzUQCXU([BLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in UByte>> UByteArray.filterTo(destination: C : MutableCollection<in UByte>, predicate: (UByte) -> Boolean): C : MutableCollection<in UByte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterTo-wU5IKMo([ILjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in UInt>> UIntArray.filterTo(destination: C : MutableCollection<in UInt>, predicate: (UInt) -> Boolean): C : MutableCollection<in UInt>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterTo-HqK1JgA([JLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in ULong>> ULongArray.filterTo(destination: C : MutableCollection<in ULong>, predicate: (ULong) -> Boolean): C : MutableCollection<in ULong>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = filterTo-oEOeDjA([SLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <C : MutableCollection<in UShort>> UShortArray.filterTo(destination: C : MutableCollection<in UShort>, predicate: (UShort) -> Boolean): C : MutableCollection<in UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = find-JOV_ifY([BLkotlin/jvm/functions/Function1;)Lkotlin/UByte;
inline fun UByteArray.find(predicate: (UByte) -> Boolean): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = find-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Lkotlin/UInt;
inline fun UIntArray.find(predicate: (UInt) -> Boolean): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = find-MShoTSo([JLkotlin/jvm/functions/Function1;)Lkotlin/ULong;
inline fun ULongArray.find(predicate: (ULong) -> Boolean): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = find-xTcfx_M([SLkotlin/jvm/functions/Function1;)Lkotlin/UShort;
inline fun UShortArray.find(predicate: (UShort) -> Boolean): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = findLast-JOV_ifY([BLkotlin/jvm/functions/Function1;)Lkotlin/UByte;
inline fun UByteArray.findLast(predicate: (UByte) -> Boolean): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = findLast-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Lkotlin/UInt;
inline fun UIntArray.findLast(predicate: (UInt) -> Boolean): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = findLast-MShoTSo([JLkotlin/jvm/functions/Function1;)Lkotlin/ULong;
inline fun ULongArray.findLast(predicate: (ULong) -> Boolean): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = findLast-xTcfx_M([SLkotlin/jvm/functions/Function1;)Lkotlin/UShort;
inline fun UShortArray.findLast(predicate: (UShort) -> Boolean): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = first-GBYM_sE([B)B
inline fun UByteArray.first(): UByte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = first-JOV_ifY([BLkotlin/jvm/functions/Function1;)B
inline fun UByteArray.first(predicate: (UByte) -> Boolean): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = first--ajY-9A([I)I
inline fun UIntArray.first(): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = first-jgv0xPQ([ILkotlin/jvm/functions/Function1;)I
inline fun UIntArray.first(predicate: (UInt) -> Boolean): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = first-QwZRm1k([J)J
inline fun ULongArray.first(): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = first-MShoTSo([JLkotlin/jvm/functions/Function1;)J
inline fun ULongArray.first(predicate: (ULong) -> Boolean): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = first-rL5Bavg([S)S
inline fun UShortArray.first(): UShort

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = first-xTcfx_M([SLkotlin/jvm/functions/Function1;)S
inline fun UShortArray.first(predicate: (UShort) -> Boolean): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = firstOrNull-GBYM_sE([B)Lkotlin/UByte;
fun UByteArray.firstOrNull(): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = firstOrNull-JOV_ifY([BLkotlin/jvm/functions/Function1;)Lkotlin/UByte;
inline fun UByteArray.firstOrNull(predicate: (UByte) -> Boolean): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = firstOrNull--ajY-9A([I)Lkotlin/UInt;
fun UIntArray.firstOrNull(): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = firstOrNull-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Lkotlin/UInt;
inline fun UIntArray.firstOrNull(predicate: (UInt) -> Boolean): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = firstOrNull-QwZRm1k([J)Lkotlin/ULong;
fun ULongArray.firstOrNull(): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = firstOrNull-MShoTSo([JLkotlin/jvm/functions/Function1;)Lkotlin/ULong;
inline fun ULongArray.firstOrNull(predicate: (ULong) -> Boolean): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = firstOrNull-rL5Bavg([S)Lkotlin/UShort;
fun UShortArray.firstOrNull(): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = firstOrNull-xTcfx_M([SLkotlin/jvm/functions/Function1;)Lkotlin/UShort;
inline fun UShortArray.firstOrNull(predicate: (UShort) -> Boolean): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMap-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> UByteArray.flatMap(transform: (UByte) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMap-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> UIntArray.flatMap(transform: (UInt) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMap-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> ULongArray.flatMap(transform: (ULong) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMap-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> UShortArray.flatMap(transform: (UShort) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMapIndexed-ELGow60([BLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> UByteArray.flatMapIndexed(transform: (@ParameterName(name = "index") Int, UByte) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMapIndexed-WyvcNBI([ILkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> UIntArray.flatMapIndexed(transform: (@ParameterName(name = "index") Int, UInt) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMapIndexed-s8dVfGU([JLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> ULongArray.flatMapIndexed(transform: (@ParameterName(name = "index") Int, ULong) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMapIndexed-xzaTVY8([SLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> UShortArray.flatMapIndexed(transform: (@ParameterName(name = "index") Int, UShort) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMapIndexedTo-eNpIKz8([BLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, UByte) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMapIndexedTo--6EtJGI([ILjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, UInt) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMapIndexedTo-pe2Q0Dw([JLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, ULong) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMapIndexedTo-QqktQ3k([SLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, UShort) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMapTo-wzUQCXU([BLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapTo(destination: C : MutableCollection<in R>, transform: (UByte) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMapTo-wU5IKMo([ILjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapTo(destination: C : MutableCollection<in R>, transform: (UInt) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMapTo-HqK1JgA([JLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapTo(destination: C : MutableCollection<in R>, transform: (ULong) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = flatMapTo-oEOeDjA([SLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapTo(destination: C : MutableCollection<in R>, transform: (UShort) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = fold-yXmHNn8([BLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> UByteArray.fold(initial: R, operation: (@ParameterName(name = "acc") R, UByte) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = fold-zi1B2BA([ILjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> UIntArray.fold(initial: R, operation: (@ParameterName(name = "acc") R, UInt) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = fold-A8wKCXQ([JLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> ULongArray.fold(initial: R, operation: (@ParameterName(name = "acc") R, ULong) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = fold-zww5nb8([SLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> UShortArray.fold(initial: R, operation: (@ParameterName(name = "acc") R, UShort) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = foldIndexed-3iWJZGE([BLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> UByteArray.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, UByte) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = foldIndexed-yVwIW0Q([ILjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> UIntArray.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, UInt) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = foldIndexed-mwnnOCs([JLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> ULongArray.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, ULong) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = foldIndexed-bzxtMww([SLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> UShortArray.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, UShort) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = foldRight-yXmHNn8([BLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> UByteArray.foldRight(initial: R, operation: (UByte, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = foldRight-zi1B2BA([ILjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> UIntArray.foldRight(initial: R, operation: (UInt, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = foldRight-A8wKCXQ([JLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> ULongArray.foldRight(initial: R, operation: (ULong, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = foldRight-zww5nb8([SLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> UShortArray.foldRight(initial: R, operation: (UShort, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = foldRightIndexed-3iWJZGE([BLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> UByteArray.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, UByte, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = foldRightIndexed-yVwIW0Q([ILjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> UIntArray.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, UInt, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = foldRightIndexed-mwnnOCs([JLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> ULongArray.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, ULong, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = foldRightIndexed-bzxtMww([SLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> UShortArray.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, UShort, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = forEach-JOV_ifY([BLkotlin/jvm/functions/Function1;)V
inline fun UByteArray.forEach(action: (UByte) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = forEach-jgv0xPQ([ILkotlin/jvm/functions/Function1;)V
inline fun UIntArray.forEach(action: (UInt) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = forEach-MShoTSo([JLkotlin/jvm/functions/Function1;)V
inline fun ULongArray.forEach(action: (ULong) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = forEach-xTcfx_M([SLkotlin/jvm/functions/Function1;)V
inline fun UShortArray.forEach(action: (UShort) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = forEachIndexed-ELGow60([BLkotlin/jvm/functions/Function2;)V
inline fun UByteArray.forEachIndexed(action: (@ParameterName(name = "index") Int, UByte) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = forEachIndexed-WyvcNBI([ILkotlin/jvm/functions/Function2;)V
inline fun UIntArray.forEachIndexed(action: (@ParameterName(name = "index") Int, UInt) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = forEachIndexed-s8dVfGU([JLkotlin/jvm/functions/Function2;)V
inline fun ULongArray.forEachIndexed(action: (@ParameterName(name = "index") Int, ULong) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = forEachIndexed-xzaTVY8([SLkotlin/jvm/functions/Function2;)V
inline fun UShortArray.forEachIndexed(action: (@ParameterName(name = "index") Int, UShort) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getOrElse-cO-VybQ([BILkotlin/jvm/functions/Function1;)B
inline fun UByteArray.getOrElse(index: Int, defaultValue: (Int) -> UByte): UByte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getOrElse-QxvSvLU([IILkotlin/jvm/functions/Function1;)I
inline fun UIntArray.getOrElse(index: Int, defaultValue: (Int) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getOrElse-Xw8i6dc([JILkotlin/jvm/functions/Function1;)J
inline fun ULongArray.getOrElse(index: Int, defaultValue: (Int) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getOrElse-CVVdw08([SILkotlin/jvm/functions/Function1;)S
inline fun UShortArray.getOrElse(index: Int, defaultValue: (Int) -> UShort): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getOrNull-PpDY95g([BI)Lkotlin/UByte;
fun UByteArray.getOrNull(index: Int): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getOrNull-qFRl0hI([II)Lkotlin/UInt;
fun UIntArray.getOrNull(index: Int): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getOrNull-r7IrZao([JI)Lkotlin/ULong;
fun ULongArray.getOrNull(index: Int): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = getOrNull-nggk6HY([SI)Lkotlin/UShort;
fun UShortArray.getOrNull(index: Int): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupBy-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> UByteArray.groupBy(keySelector: (UByte) -> K): Map<K, List<UByte>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupBy-bBsjw1Y([BLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> UByteArray.groupBy(keySelector: (UByte) -> K, valueTransform: (UByte) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupBy-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> UIntArray.groupBy(keySelector: (UInt) -> K): Map<K, List<UInt>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupBy-L4rlFek([ILkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> UIntArray.groupBy(keySelector: (UInt) -> K, valueTransform: (UInt) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupBy-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> ULongArray.groupBy(keySelector: (ULong) -> K): Map<K, List<ULong>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupBy--_j2Y-Q([JLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> ULongArray.groupBy(keySelector: (ULong) -> K, valueTransform: (ULong) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupBy-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> UShortArray.groupBy(keySelector: (UShort) -> K): Map<K, List<UShort>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupBy-3bBvP4M([SLkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> UShortArray.groupBy(keySelector: (UShort) -> K, valueTransform: (UShort) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupByTo-H21X9dk([BLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<UByte>>> UByteArray.groupByTo(destination: M : MutableMap<in K, MutableList<UByte>>, keySelector: (UByte) -> K): M : MutableMap<in K, MutableList<UByte>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupByTo-qOZmbk8([BLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UByteArray.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (UByte) -> K, valueTransform: (UByte) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupByTo-4D70W2E([ILjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<UInt>>> UIntArray.groupByTo(destination: M : MutableMap<in K, MutableList<UInt>>, keySelector: (UInt) -> K): M : MutableMap<in K, MutableList<UInt>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupByTo-JM6gNCM([ILjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UIntArray.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (UInt) -> K, valueTransform: (UInt) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupByTo-X6OPwNk([JLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<ULong>>> ULongArray.groupByTo(destination: M : MutableMap<in K, MutableList<ULong>>, keySelector: (ULong) -> K): M : MutableMap<in K, MutableList<ULong>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupByTo-QxgOkWg([JLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ULongArray.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (ULong) -> K, valueTransform: (ULong) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupByTo-ciTST-8([SLjava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<UShort>>> UShortArray.groupByTo(destination: M : MutableMap<in K, MutableList<UShort>>, keySelector: (UShort) -> K): M : MutableMap<in K, MutableList<UShort>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = groupByTo-q8RuPII([SLjava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UShortArray.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (UShort) -> K, valueTransform: (UShort) -> V): M : MutableMap<in K, MutableList<V>>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = indexOf-gMuBH34([BB)I
inline fun UByteArray.indexOf(element: UByte): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = indexOf-uWY9BYg([II)I
inline fun UIntArray.indexOf(element: UInt): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = indexOf-3uqUaXg([JJ)I
inline fun ULongArray.indexOf(element: ULong): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = indexOf-XzdR7RA([SS)I
inline fun UShortArray.indexOf(element: UShort): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = indexOfFirst-JOV_ifY([BLkotlin/jvm/functions/Function1;)I
inline fun UByteArray.indexOfFirst(predicate: (UByte) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = indexOfFirst-jgv0xPQ([ILkotlin/jvm/functions/Function1;)I
inline fun UIntArray.indexOfFirst(predicate: (UInt) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = indexOfFirst-MShoTSo([JLkotlin/jvm/functions/Function1;)I
inline fun ULongArray.indexOfFirst(predicate: (ULong) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = indexOfFirst-xTcfx_M([SLkotlin/jvm/functions/Function1;)I
inline fun UShortArray.indexOfFirst(predicate: (UShort) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = indexOfLast-JOV_ifY([BLkotlin/jvm/functions/Function1;)I
inline fun UByteArray.indexOfLast(predicate: (UByte) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = indexOfLast-jgv0xPQ([ILkotlin/jvm/functions/Function1;)I
inline fun UIntArray.indexOfLast(predicate: (UInt) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = indexOfLast-MShoTSo([JLkotlin/jvm/functions/Function1;)I
inline fun ULongArray.indexOfLast(predicate: (ULong) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = indexOfLast-xTcfx_M([SLkotlin/jvm/functions/Function1;)I
inline fun UShortArray.indexOfLast(predicate: (UShort) -> Boolean): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = last-GBYM_sE([B)B
inline fun UByteArray.last(): UByte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = last-JOV_ifY([BLkotlin/jvm/functions/Function1;)B
inline fun UByteArray.last(predicate: (UByte) -> Boolean): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = last--ajY-9A([I)I
inline fun UIntArray.last(): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = last-jgv0xPQ([ILkotlin/jvm/functions/Function1;)I
inline fun UIntArray.last(predicate: (UInt) -> Boolean): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = last-QwZRm1k([J)J
inline fun ULongArray.last(): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = last-MShoTSo([JLkotlin/jvm/functions/Function1;)J
inline fun ULongArray.last(predicate: (ULong) -> Boolean): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = last-rL5Bavg([S)S
inline fun UShortArray.last(): UShort

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = last-xTcfx_M([SLkotlin/jvm/functions/Function1;)S
inline fun UShortArray.last(predicate: (UShort) -> Boolean): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastIndexOf-gMuBH34([BB)I
inline fun UByteArray.lastIndexOf(element: UByte): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastIndexOf-uWY9BYg([II)I
inline fun UIntArray.lastIndexOf(element: UInt): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastIndexOf-3uqUaXg([JJ)I
inline fun ULongArray.lastIndexOf(element: ULong): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastIndexOf-XzdR7RA([SS)I
inline fun UShortArray.lastIndexOf(element: UShort): Int

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastOrNull-GBYM_sE([B)Lkotlin/UByte;
fun UByteArray.lastOrNull(): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastOrNull-JOV_ifY([BLkotlin/jvm/functions/Function1;)Lkotlin/UByte;
inline fun UByteArray.lastOrNull(predicate: (UByte) -> Boolean): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastOrNull--ajY-9A([I)Lkotlin/UInt;
fun UIntArray.lastOrNull(): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastOrNull-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Lkotlin/UInt;
inline fun UIntArray.lastOrNull(predicate: (UInt) -> Boolean): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastOrNull-QwZRm1k([J)Lkotlin/ULong;
fun ULongArray.lastOrNull(): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastOrNull-MShoTSo([JLkotlin/jvm/functions/Function1;)Lkotlin/ULong;
inline fun ULongArray.lastOrNull(predicate: (ULong) -> Boolean): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastOrNull-rL5Bavg([S)Lkotlin/UShort;
fun UShortArray.lastOrNull(): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastOrNull-xTcfx_M([SLkotlin/jvm/functions/Function1;)Lkotlin/UShort;
inline fun UShortArray.lastOrNull(predicate: (UShort) -> Boolean): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = map-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> UByteArray.map(transform: (UByte) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = map-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> UIntArray.map(transform: (UInt) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = map-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> ULongArray.map(transform: (ULong) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = map-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> UShortArray.map(transform: (UShort) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapIndexed-ELGow60([BLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> UByteArray.mapIndexed(transform: (@ParameterName(name = "index") Int, UByte) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapIndexed-WyvcNBI([ILkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> UIntArray.mapIndexed(transform: (@ParameterName(name = "index") Int, UInt) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapIndexed-s8dVfGU([JLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> ULongArray.mapIndexed(transform: (@ParameterName(name = "index") Int, ULong) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapIndexed-xzaTVY8([SLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> UShortArray.mapIndexed(transform: (@ParameterName(name = "index") Int, UShort) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapIndexedTo-eNpIKz8([BLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> UByteArray.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, UByte) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapIndexedTo--6EtJGI([ILjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> UIntArray.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, UInt) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapIndexedTo-pe2Q0Dw([JLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> ULongArray.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, ULong) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapIndexedTo-QqktQ3k([SLjava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> UShortArray.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, UShort) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapTo-wzUQCXU([BLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> UByteArray.mapTo(destination: C : MutableCollection<in R>, transform: (UByte) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapTo-wU5IKMo([ILjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> UIntArray.mapTo(destination: C : MutableCollection<in R>, transform: (UInt) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapTo-HqK1JgA([JLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> ULongArray.mapTo(destination: C : MutableCollection<in R>, transform: (ULong) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = mapTo-oEOeDjA([SLjava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> UShortArray.mapTo(destination: C : MutableCollection<in R>, transform: (UShort) -> R): C : MutableCollection<in R>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOrThrow-U([B)B
fun UByteArray.max(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOrThrow-U([I)I
fun UIntArray.max(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOrThrow-U([J)J
fun ULongArray.max(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOrThrow-U([S)S
fun UShortArray.max(): UShort

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxByOrThrow-U([BLkotlin/jvm/functions/Function1;)B
inline fun <R : Comparable<R>> UByteArray.maxBy(selector: (UByte) -> R : Comparable<R>): UByte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxByOrThrow-U([ILkotlin/jvm/functions/Function1;)I
inline fun <R : Comparable<R>> UIntArray.maxBy(selector: (UInt) -> R : Comparable<R>): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxByOrThrow-U([JLkotlin/jvm/functions/Function1;)J
inline fun <R : Comparable<R>> ULongArray.maxBy(selector: (ULong) -> R : Comparable<R>): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxByOrThrow-U([SLkotlin/jvm/functions/Function1;)S
inline fun <R : Comparable<R>> UShortArray.maxBy(selector: (UShort) -> R : Comparable<R>): UShort

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxByOrNull-JOV_ifY([BLkotlin/jvm/functions/Function1;)Lkotlin/UByte;
inline fun <R : Comparable<R>> UByteArray.maxByOrNull(selector: (UByte) -> R : Comparable<R>): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxByOrNull-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Lkotlin/UInt;
inline fun <R : Comparable<R>> UIntArray.maxByOrNull(selector: (UInt) -> R : Comparable<R>): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxByOrNull-MShoTSo([JLkotlin/jvm/functions/Function1;)Lkotlin/ULong;
inline fun <R : Comparable<R>> ULongArray.maxByOrNull(selector: (ULong) -> R : Comparable<R>): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxByOrNull-xTcfx_M([SLkotlin/jvm/functions/Function1;)Lkotlin/UShort;
inline fun <R : Comparable<R>> UShortArray.maxByOrNull(selector: (UShort) -> R : Comparable<R>): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> UByteArray.maxOf(selector: (UByte) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-JOV_ifY([BLkotlin/jvm/functions/Function1;)D
inline fun UByteArray.maxOf(selector: (UByte) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-JOV_ifY([BLkotlin/jvm/functions/Function1;)F
inline fun UByteArray.maxOf(selector: (UByte) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> UIntArray.maxOf(selector: (UInt) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-jgv0xPQ([ILkotlin/jvm/functions/Function1;)D
inline fun UIntArray.maxOf(selector: (UInt) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-jgv0xPQ([ILkotlin/jvm/functions/Function1;)F
inline fun UIntArray.maxOf(selector: (UInt) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> ULongArray.maxOf(selector: (ULong) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-MShoTSo([JLkotlin/jvm/functions/Function1;)D
inline fun ULongArray.maxOf(selector: (ULong) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-MShoTSo([JLkotlin/jvm/functions/Function1;)F
inline fun ULongArray.maxOf(selector: (ULong) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> UShortArray.maxOf(selector: (UShort) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-xTcfx_M([SLkotlin/jvm/functions/Function1;)D
inline fun UShortArray.maxOf(selector: (UShort) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-xTcfx_M([SLkotlin/jvm/functions/Function1;)F
inline fun UShortArray.maxOf(selector: (UShort) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfOrNull-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> UByteArray.maxOfOrNull(selector: (UByte) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfOrNull-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun UByteArray.maxOfOrNull(selector: (UByte) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfOrNull-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun UByteArray.maxOfOrNull(selector: (UByte) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfOrNull-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> UIntArray.maxOfOrNull(selector: (UInt) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfOrNull-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun UIntArray.maxOfOrNull(selector: (UInt) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfOrNull-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun UIntArray.maxOfOrNull(selector: (UInt) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfOrNull-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> ULongArray.maxOfOrNull(selector: (ULong) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfOrNull-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun ULongArray.maxOfOrNull(selector: (ULong) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfOrNull-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun ULongArray.maxOfOrNull(selector: (ULong) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfOrNull-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> UShortArray.maxOfOrNull(selector: (UShort) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfOrNull-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun UShortArray.maxOfOrNull(selector: (UShort) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfOrNull-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun UShortArray.maxOfOrNull(selector: (UShort) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfWith-LTi4i_s([BLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> UByteArray.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (UByte) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfWith-myNOsp4([ILjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> UIntArray.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (UInt) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfWith-5NtCtWE([JLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> ULongArray.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (ULong) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfWith-l8EHGbQ([SLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> UShortArray.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (UShort) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfWithOrNull-LTi4i_s([BLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> UByteArray.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (UByte) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfWithOrNull-myNOsp4([ILjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> UIntArray.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (UInt) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfWithOrNull-5NtCtWE([JLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> ULongArray.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (ULong) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOfWithOrNull-l8EHGbQ([SLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> UShortArray.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (UShort) -> R): R?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOrNull-GBYM_sE([B)Lkotlin/UByte;
fun UByteArray.maxOrNull(): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOrNull--ajY-9A([I)Lkotlin/UInt;
fun UIntArray.maxOrNull(): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOrNull-QwZRm1k([J)Lkotlin/ULong;
fun ULongArray.maxOrNull(): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOrNull-rL5Bavg([S)Lkotlin/UShort;
fun UShortArray.maxOrNull(): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxWithOrThrow-U([BLjava/util/Comparator;)B
fun UByteArray.maxWith(comparator: Comparator<in UByte> /* = java.util.Comparator<in UByte> */): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxWithOrThrow-U([ILjava/util/Comparator;)I
fun UIntArray.maxWith(comparator: Comparator<in UInt> /* = java.util.Comparator<in UInt> */): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxWithOrThrow-U([JLjava/util/Comparator;)J
fun ULongArray.maxWith(comparator: Comparator<in ULong> /* = java.util.Comparator<in ULong> */): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxWithOrThrow-U([SLjava/util/Comparator;)S
fun UShortArray.maxWith(comparator: Comparator<in UShort> /* = java.util.Comparator<in UShort> */): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxWithOrNull-XMRcp5o([BLjava/util/Comparator;)Lkotlin/UByte;
fun UByteArray.maxWithOrNull(comparator: Comparator<in UByte> /* = java.util.Comparator<in UByte> */): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxWithOrNull-YmdZ_VM([ILjava/util/Comparator;)Lkotlin/UInt;
fun UIntArray.maxWithOrNull(comparator: Comparator<in UInt> /* = java.util.Comparator<in UInt> */): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxWithOrNull-zrEWJaI([JLjava/util/Comparator;)Lkotlin/ULong;
fun ULongArray.maxWithOrNull(comparator: Comparator<in ULong> /* = java.util.Comparator<in ULong> */): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxWithOrNull-eOHTfZs([SLjava/util/Comparator;)Lkotlin/UShort;
fun UShortArray.maxWithOrNull(comparator: Comparator<in UShort> /* = java.util.Comparator<in UShort> */): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOrThrow-U([B)B
fun UByteArray.min(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOrThrow-U([I)I
fun UIntArray.min(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOrThrow-U([J)J
fun ULongArray.min(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOrThrow-U([S)S
fun UShortArray.min(): UShort

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minByOrThrow-U([BLkotlin/jvm/functions/Function1;)B
inline fun <R : Comparable<R>> UByteArray.minBy(selector: (UByte) -> R : Comparable<R>): UByte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minByOrThrow-U([ILkotlin/jvm/functions/Function1;)I
inline fun <R : Comparable<R>> UIntArray.minBy(selector: (UInt) -> R : Comparable<R>): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minByOrThrow-U([JLkotlin/jvm/functions/Function1;)J
inline fun <R : Comparable<R>> ULongArray.minBy(selector: (ULong) -> R : Comparable<R>): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minByOrThrow-U([SLkotlin/jvm/functions/Function1;)S
inline fun <R : Comparable<R>> UShortArray.minBy(selector: (UShort) -> R : Comparable<R>): UShort

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minByOrNull-JOV_ifY([BLkotlin/jvm/functions/Function1;)Lkotlin/UByte;
inline fun <R : Comparable<R>> UByteArray.minByOrNull(selector: (UByte) -> R : Comparable<R>): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minByOrNull-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Lkotlin/UInt;
inline fun <R : Comparable<R>> UIntArray.minByOrNull(selector: (UInt) -> R : Comparable<R>): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minByOrNull-MShoTSo([JLkotlin/jvm/functions/Function1;)Lkotlin/ULong;
inline fun <R : Comparable<R>> ULongArray.minByOrNull(selector: (ULong) -> R : Comparable<R>): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minByOrNull-xTcfx_M([SLkotlin/jvm/functions/Function1;)Lkotlin/UShort;
inline fun <R : Comparable<R>> UShortArray.minByOrNull(selector: (UShort) -> R : Comparable<R>): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> UByteArray.minOf(selector: (UByte) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-JOV_ifY([BLkotlin/jvm/functions/Function1;)D
inline fun UByteArray.minOf(selector: (UByte) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-JOV_ifY([BLkotlin/jvm/functions/Function1;)F
inline fun UByteArray.minOf(selector: (UByte) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> UIntArray.minOf(selector: (UInt) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-jgv0xPQ([ILkotlin/jvm/functions/Function1;)D
inline fun UIntArray.minOf(selector: (UInt) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-jgv0xPQ([ILkotlin/jvm/functions/Function1;)F
inline fun UIntArray.minOf(selector: (UInt) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> ULongArray.minOf(selector: (ULong) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-MShoTSo([JLkotlin/jvm/functions/Function1;)D
inline fun ULongArray.minOf(selector: (ULong) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-MShoTSo([JLkotlin/jvm/functions/Function1;)F
inline fun ULongArray.minOf(selector: (ULong) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> UShortArray.minOf(selector: (UShort) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-xTcfx_M([SLkotlin/jvm/functions/Function1;)D
inline fun UShortArray.minOf(selector: (UShort) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-xTcfx_M([SLkotlin/jvm/functions/Function1;)F
inline fun UShortArray.minOf(selector: (UShort) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfOrNull-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> UByteArray.minOfOrNull(selector: (UByte) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfOrNull-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun UByteArray.minOfOrNull(selector: (UByte) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfOrNull-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun UByteArray.minOfOrNull(selector: (UByte) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfOrNull-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> UIntArray.minOfOrNull(selector: (UInt) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfOrNull-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun UIntArray.minOfOrNull(selector: (UInt) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfOrNull-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun UIntArray.minOfOrNull(selector: (UInt) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfOrNull-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> ULongArray.minOfOrNull(selector: (ULong) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfOrNull-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun ULongArray.minOfOrNull(selector: (ULong) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfOrNull-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun ULongArray.minOfOrNull(selector: (ULong) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfOrNull-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> UShortArray.minOfOrNull(selector: (UShort) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfOrNull-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun UShortArray.minOfOrNull(selector: (UShort) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfOrNull-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun UShortArray.minOfOrNull(selector: (UShort) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfWith-LTi4i_s([BLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> UByteArray.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (UByte) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfWith-myNOsp4([ILjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> UIntArray.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (UInt) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfWith-5NtCtWE([JLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> ULongArray.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (ULong) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfWith-l8EHGbQ([SLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> UShortArray.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (UShort) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfWithOrNull-LTi4i_s([BLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> UByteArray.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (UByte) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfWithOrNull-myNOsp4([ILjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> UIntArray.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (UInt) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfWithOrNull-5NtCtWE([JLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> ULongArray.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (ULong) -> R): R?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOfWithOrNull-l8EHGbQ([SLjava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> UShortArray.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (UShort) -> R): R?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOrNull-GBYM_sE([B)Lkotlin/UByte;
fun UByteArray.minOrNull(): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOrNull--ajY-9A([I)Lkotlin/UInt;
fun UIntArray.minOrNull(): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOrNull-QwZRm1k([J)Lkotlin/ULong;
fun ULongArray.minOrNull(): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOrNull-rL5Bavg([S)Lkotlin/UShort;
fun UShortArray.minOrNull(): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minWithOrThrow-U([BLjava/util/Comparator;)B
fun UByteArray.minWith(comparator: Comparator<in UByte> /* = java.util.Comparator<in UByte> */): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minWithOrThrow-U([ILjava/util/Comparator;)I
fun UIntArray.minWith(comparator: Comparator<in UInt> /* = java.util.Comparator<in UInt> */): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minWithOrThrow-U([JLjava/util/Comparator;)J
fun ULongArray.minWith(comparator: Comparator<in ULong> /* = java.util.Comparator<in ULong> */): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minWithOrThrow-U([SLjava/util/Comparator;)S
fun UShortArray.minWith(comparator: Comparator<in UShort> /* = java.util.Comparator<in UShort> */): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minWithOrNull-XMRcp5o([BLjava/util/Comparator;)Lkotlin/UByte;
fun UByteArray.minWithOrNull(comparator: Comparator<in UByte> /* = java.util.Comparator<in UByte> */): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minWithOrNull-YmdZ_VM([ILjava/util/Comparator;)Lkotlin/UInt;
fun UIntArray.minWithOrNull(comparator: Comparator<in UInt> /* = java.util.Comparator<in UInt> */): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minWithOrNull-zrEWJaI([JLjava/util/Comparator;)Lkotlin/ULong;
fun ULongArray.minWithOrNull(comparator: Comparator<in ULong> /* = java.util.Comparator<in ULong> */): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minWithOrNull-eOHTfZs([SLjava/util/Comparator;)Lkotlin/UShort;
fun UShortArray.minWithOrNull(comparator: Comparator<in UShort> /* = java.util.Comparator<in UShort> */): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = none-GBYM_sE([B)Z
inline fun UByteArray.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = none-JOV_ifY([BLkotlin/jvm/functions/Function1;)Z
inline fun UByteArray.none(predicate: (UByte) -> Boolean): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = none--ajY-9A([I)Z
inline fun UIntArray.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = none-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Z
inline fun UIntArray.none(predicate: (UInt) -> Boolean): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = none-QwZRm1k([J)Z
inline fun ULongArray.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = none-MShoTSo([JLkotlin/jvm/functions/Function1;)Z
inline fun ULongArray.none(predicate: (ULong) -> Boolean): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = none-rL5Bavg([S)Z
inline fun UShortArray.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = none-xTcfx_M([SLkotlin/jvm/functions/Function1;)Z
inline fun UShortArray.none(predicate: (UShort) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = onEach-JOV_ifY([BLkotlin/jvm/functions/Function1;)[B
inline fun UByteArray.onEach(action: (UByte) -> Unit): UByteArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = onEach-jgv0xPQ([ILkotlin/jvm/functions/Function1;)[I
inline fun UIntArray.onEach(action: (UInt) -> Unit): UIntArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = onEach-MShoTSo([JLkotlin/jvm/functions/Function1;)[J
inline fun ULongArray.onEach(action: (ULong) -> Unit): ULongArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = onEach-xTcfx_M([SLkotlin/jvm/functions/Function1;)[S
inline fun UShortArray.onEach(action: (UShort) -> Unit): UShortArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = onEachIndexed-ELGow60([BLkotlin/jvm/functions/Function2;)[B
inline fun UByteArray.onEachIndexed(action: (@ParameterName(name = "index") Int, UByte) -> Unit): UByteArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = onEachIndexed-WyvcNBI([ILkotlin/jvm/functions/Function2;)[I
inline fun UIntArray.onEachIndexed(action: (@ParameterName(name = "index") Int, UInt) -> Unit): UIntArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = onEachIndexed-s8dVfGU([JLkotlin/jvm/functions/Function2;)[J
inline fun ULongArray.onEachIndexed(action: (@ParameterName(name = "index") Int, ULong) -> Unit): ULongArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = onEachIndexed-xzaTVY8([SLkotlin/jvm/functions/Function2;)[S
inline fun UShortArray.onEachIndexed(action: (@ParameterName(name = "index") Int, UShort) -> Unit): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = plus-gMuBH34([BB)[B
inline operator fun UByteArray.plus(element: UByte): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = plus-kdPth3s([B[B)[B
inline operator fun UByteArray.plus(elements: UByteArray): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = plus-xo_DsdI([BLjava/util/Collection;)[B
operator fun UByteArray.plus(elements: Collection<UByte>): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = plus-uWY9BYg([II)[I
inline operator fun UIntArray.plus(element: UInt): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = plus-ctEhBpI([I[I)[I
inline operator fun UIntArray.plus(elements: UIntArray): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = plus-CFIt9YE([ILjava/util/Collection;)[I
operator fun UIntArray.plus(elements: Collection<UInt>): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = plus-3uqUaXg([JJ)[J
inline operator fun ULongArray.plus(element: ULong): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = plus-us8wMrg([J[J)[J
inline operator fun ULongArray.plus(elements: ULongArray): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = plus-kzHmqpY([JLjava/util/Collection;)[J
operator fun ULongArray.plus(elements: Collection<ULong>): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = plus-XzdR7RA([SS)[S
inline operator fun UShortArray.plus(element: UShort): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = plus-mazbYpA([S[S)[S
inline operator fun UShortArray.plus(elements: UShortArray): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = plus-ojwP5H8([SLjava/util/Collection;)[S
operator fun UShortArray.plus(elements: Collection<UShort>): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = random-GBYM_sE([B)B
inline fun UByteArray.random(): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = random-oSF2wD8([BLkotlin/random/Random;)B
fun UByteArray.random(random: kotlin.random.Random): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = random--ajY-9A([I)I
inline fun UIntArray.random(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = random-2D5oskM([ILkotlin/random/Random;)I
fun UIntArray.random(random: kotlin.random.Random): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = random-QwZRm1k([J)J
inline fun ULongArray.random(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = random-JzugnMA([JLkotlin/random/Random;)J
fun ULongArray.random(random: kotlin.random.Random): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = random-rL5Bavg([S)S
inline fun UShortArray.random(): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = random-s5X_as8([SLkotlin/random/Random;)S
fun UShortArray.random(random: kotlin.random.Random): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = randomOrNull-GBYM_sE([B)Lkotlin/UByte;
inline fun UByteArray.randomOrNull(): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = randomOrNull-oSF2wD8([BLkotlin/random/Random;)Lkotlin/UByte;
fun UByteArray.randomOrNull(random: kotlin.random.Random): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = randomOrNull--ajY-9A([I)Lkotlin/UInt;
inline fun UIntArray.randomOrNull(): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = randomOrNull-2D5oskM([ILkotlin/random/Random;)Lkotlin/UInt;
fun UIntArray.randomOrNull(random: kotlin.random.Random): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = randomOrNull-QwZRm1k([J)Lkotlin/ULong;
inline fun ULongArray.randomOrNull(): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = randomOrNull-JzugnMA([JLkotlin/random/Random;)Lkotlin/ULong;
fun ULongArray.randomOrNull(random: kotlin.random.Random): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = randomOrNull-rL5Bavg([S)Lkotlin/UShort;
inline fun UShortArray.randomOrNull(): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = randomOrNull-s5X_as8([SLkotlin/random/Random;)Lkotlin/UShort;
fun UShortArray.randomOrNull(random: kotlin.random.Random): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduce-ELGow60([BLkotlin/jvm/functions/Function2;)B
inline fun UByteArray.reduce(operation: (@ParameterName(name = "acc") UByte, UByte) -> UByte): UByte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduce-WyvcNBI([ILkotlin/jvm/functions/Function2;)I
inline fun UIntArray.reduce(operation: (@ParameterName(name = "acc") UInt, UInt) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduce-s8dVfGU([JLkotlin/jvm/functions/Function2;)J
inline fun ULongArray.reduce(operation: (@ParameterName(name = "acc") ULong, ULong) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduce-xzaTVY8([SLkotlin/jvm/functions/Function2;)S
inline fun UShortArray.reduce(operation: (@ParameterName(name = "acc") UShort, UShort) -> UShort): UShort

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceIndexed-EOyYB1Y([BLkotlin/jvm/functions/Function3;)B
inline fun UByteArray.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") UByte, UByte) -> UByte): UByte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceIndexed-D40WMg8([ILkotlin/jvm/functions/Function3;)I
inline fun UIntArray.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") UInt, UInt) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceIndexed-z1zDJgo([JLkotlin/jvm/functions/Function3;)J
inline fun ULongArray.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") ULong, ULong) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceIndexed-aLgx1Fo([SLkotlin/jvm/functions/Function3;)S
inline fun UShortArray.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") UShort, UShort) -> UShort): UShort

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceIndexedOrNull-EOyYB1Y([BLkotlin/jvm/functions/Function3;)Lkotlin/UByte;
inline fun UByteArray.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") UByte, UByte) -> UByte): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceIndexedOrNull-D40WMg8([ILkotlin/jvm/functions/Function3;)Lkotlin/UInt;
inline fun UIntArray.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") UInt, UInt) -> UInt): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceIndexedOrNull-z1zDJgo([JLkotlin/jvm/functions/Function3;)Lkotlin/ULong;
inline fun ULongArray.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") ULong, ULong) -> ULong): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceIndexedOrNull-aLgx1Fo([SLkotlin/jvm/functions/Function3;)Lkotlin/UShort;
inline fun UShortArray.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") UShort, UShort) -> UShort): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceOrNull-ELGow60([BLkotlin/jvm/functions/Function2;)Lkotlin/UByte;
inline fun UByteArray.reduceOrNull(operation: (@ParameterName(name = "acc") UByte, UByte) -> UByte): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceOrNull-WyvcNBI([ILkotlin/jvm/functions/Function2;)Lkotlin/UInt;
inline fun UIntArray.reduceOrNull(operation: (@ParameterName(name = "acc") UInt, UInt) -> UInt): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceOrNull-s8dVfGU([JLkotlin/jvm/functions/Function2;)Lkotlin/ULong;
inline fun ULongArray.reduceOrNull(operation: (@ParameterName(name = "acc") ULong, ULong) -> ULong): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceOrNull-xzaTVY8([SLkotlin/jvm/functions/Function2;)Lkotlin/UShort;
inline fun UShortArray.reduceOrNull(operation: (@ParameterName(name = "acc") UShort, UShort) -> UShort): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRight-ELGow60([BLkotlin/jvm/functions/Function2;)B
inline fun UByteArray.reduceRight(operation: (UByte, @ParameterName(name = "acc") UByte) -> UByte): UByte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRight-WyvcNBI([ILkotlin/jvm/functions/Function2;)I
inline fun UIntArray.reduceRight(operation: (UInt, @ParameterName(name = "acc") UInt) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRight-s8dVfGU([JLkotlin/jvm/functions/Function2;)J
inline fun ULongArray.reduceRight(operation: (ULong, @ParameterName(name = "acc") ULong) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRight-xzaTVY8([SLkotlin/jvm/functions/Function2;)S
inline fun UShortArray.reduceRight(operation: (UShort, @ParameterName(name = "acc") UShort) -> UShort): UShort

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRightIndexed-EOyYB1Y([BLkotlin/jvm/functions/Function3;)B
inline fun UByteArray.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, UByte, @ParameterName(name = "acc") UByte) -> UByte): UByte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRightIndexed-D40WMg8([ILkotlin/jvm/functions/Function3;)I
inline fun UIntArray.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, UInt, @ParameterName(name = "acc") UInt) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRightIndexed-z1zDJgo([JLkotlin/jvm/functions/Function3;)J
inline fun ULongArray.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, ULong, @ParameterName(name = "acc") ULong) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRightIndexed-aLgx1Fo([SLkotlin/jvm/functions/Function3;)S
inline fun UShortArray.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, UShort, @ParameterName(name = "acc") UShort) -> UShort): UShort

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull-EOyYB1Y([BLkotlin/jvm/functions/Function3;)Lkotlin/UByte;
inline fun UByteArray.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, UByte, @ParameterName(name = "acc") UByte) -> UByte): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull-D40WMg8([ILkotlin/jvm/functions/Function3;)Lkotlin/UInt;
inline fun UIntArray.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, UInt, @ParameterName(name = "acc") UInt) -> UInt): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull-z1zDJgo([JLkotlin/jvm/functions/Function3;)Lkotlin/ULong;
inline fun ULongArray.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, ULong, @ParameterName(name = "acc") ULong) -> ULong): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull-aLgx1Fo([SLkotlin/jvm/functions/Function3;)Lkotlin/UShort;
inline fun UShortArray.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, UShort, @ParameterName(name = "acc") UShort) -> UShort): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRightOrNull-ELGow60([BLkotlin/jvm/functions/Function2;)Lkotlin/UByte;
inline fun UByteArray.reduceRightOrNull(operation: (UByte, @ParameterName(name = "acc") UByte) -> UByte): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRightOrNull-WyvcNBI([ILkotlin/jvm/functions/Function2;)Lkotlin/UInt;
inline fun UIntArray.reduceRightOrNull(operation: (UInt, @ParameterName(name = "acc") UInt) -> UInt): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRightOrNull-s8dVfGU([JLkotlin/jvm/functions/Function2;)Lkotlin/ULong;
inline fun ULongArray.reduceRightOrNull(operation: (ULong, @ParameterName(name = "acc") ULong) -> ULong): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reduceRightOrNull-xzaTVY8([SLkotlin/jvm/functions/Function2;)Lkotlin/UShort;
inline fun UShortArray.reduceRightOrNull(operation: (UShort, @ParameterName(name = "acc") UShort) -> UShort): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reverse-GBYM_sE([B)V
inline fun UByteArray.reverse()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reverse-4UcCI2c([BII)V
inline fun UByteArray.reverse(fromIndex: Int, toIndex: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reverse--ajY-9A([I)V
inline fun UIntArray.reverse()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reverse-oBK06Vg([III)V
inline fun UIntArray.reverse(fromIndex: Int, toIndex: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reverse-QwZRm1k([J)V
inline fun ULongArray.reverse()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reverse--nroSd4([JII)V
inline fun ULongArray.reverse(fromIndex: Int, toIndex: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reverse-rL5Bavg([S)V
inline fun UShortArray.reverse()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reverse-Aa5vz7o([SII)V
inline fun UShortArray.reverse(fromIndex: Int, toIndex: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reversed-GBYM_sE([B)Ljava/util/List;
fun UByteArray.reversed(): List<UByte>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reversed--ajY-9A([I)Ljava/util/List;
fun UIntArray.reversed(): List<UInt>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reversed-QwZRm1k([J)Ljava/util/List;
fun ULongArray.reversed(): List<ULong>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reversed-rL5Bavg([S)Ljava/util/List;
fun UShortArray.reversed(): List<UShort>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reversedArray-GBYM_sE([B)[B
inline fun UByteArray.reversedArray(): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reversedArray--ajY-9A([I)[I
inline fun UIntArray.reversedArray(): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reversedArray-QwZRm1k([J)[J
inline fun ULongArray.reversedArray(): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = reversedArray-rL5Bavg([S)[S
inline fun UShortArray.reversedArray(): UShortArray

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningFold-yXmHNn8([BLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> UByteArray.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, UByte) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningFold-zi1B2BA([ILjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> UIntArray.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, UInt) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningFold-A8wKCXQ([JLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> ULongArray.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, ULong) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningFold-zww5nb8([SLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> UShortArray.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, UShort) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningFoldIndexed-3iWJZGE([BLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> UByteArray.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, UByte) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningFoldIndexed-yVwIW0Q([ILjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> UIntArray.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, UInt) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningFoldIndexed-mwnnOCs([JLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> ULongArray.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, ULong) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningFoldIndexed-bzxtMww([SLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> UShortArray.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, UShort) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningReduce-ELGow60([BLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun UByteArray.runningReduce(operation: (@ParameterName(name = "acc") UByte, UByte) -> UByte): List<UByte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningReduce-WyvcNBI([ILkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun UIntArray.runningReduce(operation: (@ParameterName(name = "acc") UInt, UInt) -> UInt): List<UInt>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningReduce-s8dVfGU([JLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun ULongArray.runningReduce(operation: (@ParameterName(name = "acc") ULong, ULong) -> ULong): List<ULong>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningReduce-xzaTVY8([SLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun UShortArray.runningReduce(operation: (@ParameterName(name = "acc") UShort, UShort) -> UShort): List<UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningReduceIndexed-EOyYB1Y([BLkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun UByteArray.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") UByte, UByte) -> UByte): List<UByte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningReduceIndexed-D40WMg8([ILkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun UIntArray.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") UInt, UInt) -> UInt): List<UInt>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningReduceIndexed-z1zDJgo([JLkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun ULongArray.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") ULong, ULong) -> ULong): List<ULong>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = runningReduceIndexed-aLgx1Fo([SLkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun UShortArray.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") UShort, UShort) -> UShort): List<UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = scan-yXmHNn8([BLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> UByteArray.scan(initial: R, operation: (@ParameterName(name = "acc") R, UByte) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = scan-zi1B2BA([ILjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> UIntArray.scan(initial: R, operation: (@ParameterName(name = "acc") R, UInt) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = scan-A8wKCXQ([JLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> ULongArray.scan(initial: R, operation: (@ParameterName(name = "acc") R, ULong) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = scan-zww5nb8([SLjava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> UShortArray.scan(initial: R, operation: (@ParameterName(name = "acc") R, UShort) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = scanIndexed-3iWJZGE([BLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> UByteArray.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, UByte) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = scanIndexed-yVwIW0Q([ILjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> UIntArray.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, UInt) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = scanIndexed-mwnnOCs([JLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> ULongArray.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, ULong) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = scanIndexed-bzxtMww([SLjava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> UShortArray.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, UShort) -> R): List<R>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = shuffle-GBYM_sE([B)V
fun UByteArray.shuffle()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = shuffle-oSF2wD8([BLkotlin/random/Random;)V
fun UByteArray.shuffle(random: kotlin.random.Random)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = shuffle--ajY-9A([I)V
fun UIntArray.shuffle()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = shuffle-2D5oskM([ILkotlin/random/Random;)V
fun UIntArray.shuffle(random: kotlin.random.Random)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = shuffle-QwZRm1k([J)V
fun ULongArray.shuffle()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = shuffle-JzugnMA([JLkotlin/random/Random;)V
fun ULongArray.shuffle(random: kotlin.random.Random)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = shuffle-rL5Bavg([S)V
fun UShortArray.shuffle()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = shuffle-s5X_as8([SLkotlin/random/Random;)V
fun UShortArray.shuffle(random: kotlin.random.Random)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = single-GBYM_sE([B)B
inline fun UByteArray.single(): UByte

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = single-JOV_ifY([BLkotlin/jvm/functions/Function1;)B
inline fun UByteArray.single(predicate: (UByte) -> Boolean): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = single--ajY-9A([I)I
inline fun UIntArray.single(): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = single-jgv0xPQ([ILkotlin/jvm/functions/Function1;)I
inline fun UIntArray.single(predicate: (UInt) -> Boolean): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = single-QwZRm1k([J)J
inline fun ULongArray.single(): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = single-MShoTSo([JLkotlin/jvm/functions/Function1;)J
inline fun ULongArray.single(predicate: (ULong) -> Boolean): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = single-rL5Bavg([S)S
inline fun UShortArray.single(): UShort

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = single-xTcfx_M([SLkotlin/jvm/functions/Function1;)S
inline fun UShortArray.single(predicate: (UShort) -> Boolean): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = singleOrNull-GBYM_sE([B)Lkotlin/UByte;
fun UByteArray.singleOrNull(): UByte?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = singleOrNull-JOV_ifY([BLkotlin/jvm/functions/Function1;)Lkotlin/UByte;
inline fun UByteArray.singleOrNull(predicate: (UByte) -> Boolean): UByte?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = singleOrNull--ajY-9A([I)Lkotlin/UInt;
fun UIntArray.singleOrNull(): UInt?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = singleOrNull-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Lkotlin/UInt;
inline fun UIntArray.singleOrNull(predicate: (UInt) -> Boolean): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = singleOrNull-QwZRm1k([J)Lkotlin/ULong;
fun ULongArray.singleOrNull(): ULong?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = singleOrNull-MShoTSo([JLkotlin/jvm/functions/Function1;)Lkotlin/ULong;
inline fun ULongArray.singleOrNull(predicate: (ULong) -> Boolean): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = singleOrNull-rL5Bavg([S)Lkotlin/UShort;
fun UShortArray.singleOrNull(): UShort?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = singleOrNull-xTcfx_M([SLkotlin/jvm/functions/Function1;)Lkotlin/UShort;
inline fun UShortArray.singleOrNull(predicate: (UShort) -> Boolean): UShort?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = slice-JQknh5Q([BLjava/lang/Iterable;)Ljava/util/List;
fun UByteArray.slice(indices: Iterable<Int>): List<UByte>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = slice-c0bezYM([BLkotlin/ranges/IntRange;)Ljava/util/List;
fun UByteArray.slice(indices: IntRange): List<UByte>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = slice-HwE9HBo([ILjava/lang/Iterable;)Ljava/util/List;
fun UIntArray.slice(indices: Iterable<Int>): List<UInt>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = slice-tAntMlw([ILkotlin/ranges/IntRange;)Ljava/util/List;
fun UIntArray.slice(indices: IntRange): List<UInt>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = slice-F7u83W8([JLjava/lang/Iterable;)Ljava/util/List;
fun ULongArray.slice(indices: Iterable<Int>): List<ULong>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = slice-ZRhS8yI([JLkotlin/ranges/IntRange;)Ljava/util/List;
fun ULongArray.slice(indices: IntRange): List<ULong>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = slice-JGPC0-M([SLjava/lang/Iterable;)Ljava/util/List;
fun UShortArray.slice(indices: Iterable<Int>): List<UShort>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = slice-Q6IL4kU([SLkotlin/ranges/IntRange;)Ljava/util/List;
fun UShortArray.slice(indices: IntRange): List<UShort>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sliceArray-xo_DsdI([BLjava/util/Collection;)[B
fun UByteArray.sliceArray(indices: Collection<Int>): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sliceArray-c0bezYM([BLkotlin/ranges/IntRange;)[B
fun UByteArray.sliceArray(indices: IntRange): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sliceArray-CFIt9YE([ILjava/util/Collection;)[I
fun UIntArray.sliceArray(indices: Collection<Int>): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sliceArray-tAntMlw([ILkotlin/ranges/IntRange;)[I
fun UIntArray.sliceArray(indices: IntRange): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sliceArray-kzHmqpY([JLjava/util/Collection;)[J
fun ULongArray.sliceArray(indices: Collection<Int>): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sliceArray-ZRhS8yI([JLkotlin/ranges/IntRange;)[J
fun ULongArray.sliceArray(indices: IntRange): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sliceArray-ojwP5H8([SLjava/util/Collection;)[S
fun UShortArray.sliceArray(indices: Collection<Int>): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sliceArray-Q6IL4kU([SLkotlin/ranges/IntRange;)[S
fun UShortArray.sliceArray(indices: IntRange): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sort-GBYM_sE([B)V
fun UByteArray.sort()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sort-4UcCI2c([BII)V
fun UByteArray.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sort--ajY-9A([I)V
fun UIntArray.sort()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sort-oBK06Vg([III)V
fun UIntArray.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sort-QwZRm1k([J)V
fun ULongArray.sort()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sort--nroSd4([JII)V
fun ULongArray.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sort-rL5Bavg([S)V
fun UShortArray.sort()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sort-Aa5vz7o([SII)V
fun UShortArray.sort(fromIndex: Int /* = default */, toIndex: Int /* = default */)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortDescending-GBYM_sE([B)V
fun UByteArray.sortDescending()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortDescending-4UcCI2c([BII)V
fun UByteArray.sortDescending(fromIndex: Int, toIndex: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortDescending--ajY-9A([I)V
fun UIntArray.sortDescending()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortDescending-oBK06Vg([III)V
fun UIntArray.sortDescending(fromIndex: Int, toIndex: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortDescending-QwZRm1k([J)V
fun ULongArray.sortDescending()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortDescending--nroSd4([JII)V
fun ULongArray.sortDescending(fromIndex: Int, toIndex: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortDescending-rL5Bavg([S)V
fun UShortArray.sortDescending()

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortDescending-Aa5vz7o([SII)V
fun UShortArray.sortDescending(fromIndex: Int, toIndex: Int)

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sorted-GBYM_sE([B)Ljava/util/List;
fun UByteArray.sorted(): List<UByte>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sorted--ajY-9A([I)Ljava/util/List;
fun UIntArray.sorted(): List<UInt>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sorted-QwZRm1k([J)Ljava/util/List;
fun ULongArray.sorted(): List<ULong>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sorted-rL5Bavg([S)Ljava/util/List;
fun UShortArray.sorted(): List<UShort>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortedArray-GBYM_sE([B)[B
fun UByteArray.sortedArray(): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortedArray--ajY-9A([I)[I
fun UIntArray.sortedArray(): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortedArray-QwZRm1k([J)[J
fun ULongArray.sortedArray(): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortedArray-rL5Bavg([S)[S
fun UShortArray.sortedArray(): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortedArrayDescending-GBYM_sE([B)[B
fun UByteArray.sortedArrayDescending(): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortedArrayDescending--ajY-9A([I)[I
fun UIntArray.sortedArrayDescending(): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortedArrayDescending-QwZRm1k([J)[J
fun ULongArray.sortedArrayDescending(): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortedArrayDescending-rL5Bavg([S)[S
fun UShortArray.sortedArrayDescending(): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortedDescending-GBYM_sE([B)Ljava/util/List;
fun UByteArray.sortedDescending(): List<UByte>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortedDescending--ajY-9A([I)Ljava/util/List;
fun UIntArray.sortedDescending(): List<UInt>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortedDescending-QwZRm1k([J)Ljava/util/List;
fun ULongArray.sortedDescending(): List<ULong>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sortedDescending-rL5Bavg([S)Ljava/util/List;
fun UShortArray.sortedDescending(): List<UShort>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUByte([Lkotlin/UByte;)I
fun Array<out UByte>.sum(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([Lkotlin/UInt;)I
fun Array<out UInt>.sum(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([Lkotlin/ULong;)J
fun Array<out ULong>.sum(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUShort([Lkotlin/UShort;)I
fun Array<out UShort>.sum(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sum-GBYM_sE([B)I
inline fun UByteArray.sum(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sum--ajY-9A([I)I
inline fun UIntArray.sum(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sum-QwZRm1k([J)J
inline fun ULongArray.sum(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sum-rL5Bavg([S)I
inline fun UShortArray.sum(): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumBy-JOV_ifY([BLkotlin/jvm/functions/Function1;)I
inline fun UByteArray.sumBy(selector: (UByte) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumBy-jgv0xPQ([ILkotlin/jvm/functions/Function1;)I
inline fun UIntArray.sumBy(selector: (UInt) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumBy-MShoTSo([JLkotlin/jvm/functions/Function1;)I
inline fun ULongArray.sumBy(selector: (ULong) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumBy-xTcfx_M([SLkotlin/jvm/functions/Function1;)I
inline fun UShortArray.sumBy(selector: (UShort) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumByDouble-JOV_ifY([BLkotlin/jvm/functions/Function1;)D
inline fun UByteArray.sumByDouble(selector: (UByte) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumByDouble-jgv0xPQ([ILkotlin/jvm/functions/Function1;)D
inline fun UIntArray.sumByDouble(selector: (UInt) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumByDouble-MShoTSo([JLkotlin/jvm/functions/Function1;)D
inline fun ULongArray.sumByDouble(selector: (ULong) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumByDouble-xTcfx_M([SLkotlin/jvm/functions/Function1;)D
inline fun UShortArray.sumByDouble(selector: (UShort) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfDouble([BLkotlin/jvm/functions/Function1;)D
inline fun UByteArray.sumOf(selector: (UByte) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfInt([BLkotlin/jvm/functions/Function1;)I
inline fun UByteArray.sumOf(selector: (UByte) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfLong([BLkotlin/jvm/functions/Function1;)J
inline fun UByteArray.sumOf(selector: (UByte) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([BLkotlin/jvm/functions/Function1;)I
inline fun UByteArray.sumOf(selector: (UByte) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([BLkotlin/jvm/functions/Function1;)J
inline fun UByteArray.sumOf(selector: (UByte) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfDouble([ILkotlin/jvm/functions/Function1;)D
inline fun UIntArray.sumOf(selector: (UInt) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfInt([ILkotlin/jvm/functions/Function1;)I
inline fun UIntArray.sumOf(selector: (UInt) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfLong([ILkotlin/jvm/functions/Function1;)J
inline fun UIntArray.sumOf(selector: (UInt) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([ILkotlin/jvm/functions/Function1;)I
inline fun UIntArray.sumOf(selector: (UInt) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([ILkotlin/jvm/functions/Function1;)J
inline fun UIntArray.sumOf(selector: (UInt) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfDouble([JLkotlin/jvm/functions/Function1;)D
inline fun ULongArray.sumOf(selector: (ULong) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfInt([JLkotlin/jvm/functions/Function1;)I
inline fun ULongArray.sumOf(selector: (ULong) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfLong([JLkotlin/jvm/functions/Function1;)J
inline fun ULongArray.sumOf(selector: (ULong) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([JLkotlin/jvm/functions/Function1;)I
inline fun ULongArray.sumOf(selector: (ULong) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([JLkotlin/jvm/functions/Function1;)J
inline fun ULongArray.sumOf(selector: (ULong) -> ULong): ULong

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfDouble([SLkotlin/jvm/functions/Function1;)D
inline fun UShortArray.sumOf(selector: (UShort) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfInt([SLkotlin/jvm/functions/Function1;)I
inline fun UShortArray.sumOf(selector: (UShort) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfLong([SLkotlin/jvm/functions/Function1;)J
inline fun UShortArray.sumOf(selector: (UShort) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt([SLkotlin/jvm/functions/Function1;)I
inline fun UShortArray.sumOf(selector: (UShort) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong([SLkotlin/jvm/functions/Function1;)J
inline fun UShortArray.sumOf(selector: (UShort) -> ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = take-PpDY95g([BI)Ljava/util/List;
fun UByteArray.take(n: Int): List<UByte>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = take-qFRl0hI([II)Ljava/util/List;
fun UIntArray.take(n: Int): List<UInt>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = take-r7IrZao([JI)Ljava/util/List;
fun ULongArray.take(n: Int): List<ULong>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = take-nggk6HY([SI)Ljava/util/List;
fun UShortArray.take(n: Int): List<UShort>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeLast-PpDY95g([BI)Ljava/util/List;
fun UByteArray.takeLast(n: Int): List<UByte>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeLast-qFRl0hI([II)Ljava/util/List;
fun UIntArray.takeLast(n: Int): List<UInt>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeLast-r7IrZao([JI)Ljava/util/List;
fun ULongArray.takeLast(n: Int): List<ULong>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeLast-nggk6HY([SI)Ljava/util/List;
fun UShortArray.takeLast(n: Int): List<UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeLastWhile-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UByteArray.takeLastWhile(predicate: (UByte) -> Boolean): List<UByte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeLastWhile-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UIntArray.takeLastWhile(predicate: (UInt) -> Boolean): List<UInt>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeLastWhile-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ULongArray.takeLastWhile(predicate: (ULong) -> Boolean): List<ULong>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeLastWhile-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UShortArray.takeLastWhile(predicate: (UShort) -> Boolean): List<UShort>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeWhile-JOV_ifY([BLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UByteArray.takeWhile(predicate: (UByte) -> Boolean): List<UByte>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeWhile-jgv0xPQ([ILkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UIntArray.takeWhile(predicate: (UInt) -> Boolean): List<UInt>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeWhile-MShoTSo([JLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun ULongArray.takeWhile(predicate: (ULong) -> Boolean): List<ULong>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = takeWhile-xTcfx_M([SLkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun UShortArray.takeWhile(predicate: (UShort) -> Boolean): List<UShort>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toByteArray-GBYM_sE([B)[B
inline fun UByteArray.toByteArray(): ByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toIntArray--ajY-9A([I)[I
inline fun UIntArray.toIntArray(): IntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toLongArray-QwZRm1k([J)[J
inline fun ULongArray.toLongArray(): LongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toShortArray-rL5Bavg([S)[S
inline fun UShortArray.toShortArray(): ShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toTypedArray-GBYM_sE([B)[Lkotlin/UByte;
fun UByteArray.toTypedArray(): Array<UByte>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toTypedArray--ajY-9A([I)[Lkotlin/UInt;
fun UIntArray.toTypedArray(): Array<UInt>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toTypedArray-QwZRm1k([J)[Lkotlin/ULong;
fun ULongArray.toTypedArray(): Array<ULong>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toTypedArray-rL5Bavg([S)[Lkotlin/UShort;
fun UShortArray.toTypedArray(): Array<UShort>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUByteArray([Lkotlin/UByte;)[B
fun Array<out UByte>.toUByteArray(): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUByteArray([B)[B
inline fun ByteArray.toUByteArray(): UByteArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUIntArray([Lkotlin/UInt;)[I
fun Array<out UInt>.toUIntArray(): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUIntArray([I)[I
inline fun IntArray.toUIntArray(): UIntArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULongArray([Lkotlin/ULong;)[J
fun Array<out ULong>.toULongArray(): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toULongArray([J)[J
inline fun LongArray.toULongArray(): ULongArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUShortArray([Lkotlin/UShort;)[S
fun Array<out UShort>.toUShortArray(): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = toUShortArray([S)[S
inline fun ShortArray.toUShortArray(): UShortArray

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = withIndex-GBYM_sE([B)Ljava/lang/Iterable;
fun UByteArray.withIndex(): Iterable<IndexedValue<UByte>>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = withIndex--ajY-9A([I)Ljava/lang/Iterable;
fun UIntArray.withIndex(): Iterable<IndexedValue<UInt>>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = withIndex-QwZRm1k([J)Ljava/lang/Iterable;
fun ULongArray.withIndex(): Iterable<IndexedValue<ULong>>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = withIndex-rL5Bavg([S)Ljava/lang/Iterable;
fun UShortArray.withIndex(): Iterable<IndexedValue<UShort>>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-nl983wc([B[Ljava/lang/Object;)Ljava/util/List;
infix fun <R> UByteArray.zip(other: Array<out R>): List<Pair<UByte, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-LuipOMY([B[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> UByteArray.zip(other: Array<out R>, transform: (@ParameterName(name = "a") UByte, @ParameterName(name = "b") R) -> V): List<V>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-kdPth3s([B[B)Ljava/util/List;
infix fun UByteArray.zip(other: UByteArray): List<Pair<UByte, UByte>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-JAKpvQM([B[BLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> UByteArray.zip(other: UByteArray, transform: (@ParameterName(name = "a") UByte, @ParameterName(name = "b") UByte) -> V): List<V>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-JQknh5Q([BLjava/lang/Iterable;)Ljava/util/List;
infix fun <R> UByteArray.zip(other: Iterable<R>): List<Pair<UByte, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-UCnP4_w([BLjava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> UByteArray.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") UByte, @ParameterName(name = "b") R) -> V): List<V>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-C-E_24M([I[Ljava/lang/Object;)Ljava/util/List;
infix fun <R> UIntArray.zip(other: Array<out R>): List<Pair<UInt, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-ZjwqOic([I[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> UIntArray.zip(other: Array<out R>, transform: (@ParameterName(name = "a") UInt, @ParameterName(name = "b") R) -> V): List<V>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-ctEhBpI([I[I)Ljava/util/List;
infix fun UIntArray.zip(other: UIntArray): List<Pair<UInt, UInt>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-L83TJbI([I[ILkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> UIntArray.zip(other: UIntArray, transform: (@ParameterName(name = "a") UInt, @ParameterName(name = "b") UInt) -> V): List<V>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-HwE9HBo([ILjava/lang/Iterable;)Ljava/util/List;
infix fun <R> UIntArray.zip(other: Iterable<R>): List<Pair<UInt, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-7znnbtw([ILjava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> UIntArray.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") UInt, @ParameterName(name = "b") R) -> V): List<V>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-f7H3mmw([J[Ljava/lang/Object;)Ljava/util/List;
infix fun <R> ULongArray.zip(other: Array<out R>): List<Pair<ULong, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-8LME4QE([J[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> ULongArray.zip(other: Array<out R>, transform: (@ParameterName(name = "a") ULong, @ParameterName(name = "b") R) -> V): List<V>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-us8wMrg([J[J)Ljava/util/List;
infix fun ULongArray.zip(other: ULongArray): List<Pair<ULong, ULong>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-PabeH-Q([J[JLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> ULongArray.zip(other: ULongArray, transform: (@ParameterName(name = "a") ULong, @ParameterName(name = "b") ULong) -> V): List<V>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-F7u83W8([JLjava/lang/Iterable;)Ljava/util/List;
infix fun <R> ULongArray.zip(other: Iterable<R>): List<Pair<ULong, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-TUPTUsU([JLjava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> ULongArray.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") ULong, @ParameterName(name = "b") R) -> V): List<V>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-uaTIQ5s([S[Ljava/lang/Object;)Ljava/util/List;
infix fun <R> UShortArray.zip(other: Array<out R>): List<Pair<UShort, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-ePBmRWY([S[Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> UShortArray.zip(other: Array<out R>, transform: (@ParameterName(name = "a") UShort, @ParameterName(name = "b") R) -> V): List<V>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-mazbYpA([S[S)Ljava/util/List;
infix fun UShortArray.zip(other: UShortArray): List<Pair<UShort, UShort>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-gVVukQo([S[SLkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> UShortArray.zip(other: UShortArray, transform: (@ParameterName(name = "a") UShort, @ParameterName(name = "b") UShort) -> V): List<V>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-JGPC0-M([SLjava/lang/Iterable;)Ljava/util/List;
infix fun <R> UShortArray.zip(other: Iterable<R>): List<Pair<UShort, R>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = zip-kBb4a-s([SLjava/lang/Iterable;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R, V> UShortArray.zip(other: Iterable<R>, transform: (@ParameterName(name = "a") UShort, @ParameterName(name = "b") R) -> V): List<V>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.comparisons.ComparisonsKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = compareBy(Lkotlin/jvm/functions/Function1;)Ljava/util/Comparator;
inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> /* = java.util.Comparator<T> */

// JVM method = compareBy([Lkotlin/jvm/functions/Function1;)Ljava/util/Comparator;
fun <T> compareBy(vararg selectors: (T) -> Comparable<*>? /* Array<out (T) -> Comparable<*>?> */): Comparator<T> /* = java.util.Comparator<T> */

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = compareBy(Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/util/Comparator;
inline fun <T, K> compareBy(comparator: Comparator<in K> /* = java.util.Comparator<in K> */, crossinline selector: (T) -> K): Comparator<T> /* = java.util.Comparator<T> */

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = compareByDescending(Lkotlin/jvm/functions/Function1;)Ljava/util/Comparator;
inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> /* = java.util.Comparator<T> */

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = compareByDescending(Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/util/Comparator;
inline fun <T, K> compareByDescending(comparator: Comparator<in K> /* = java.util.Comparator<in K> */, crossinline selector: (T) -> K): Comparator<T> /* = java.util.Comparator<T> */

// JVM method = compareValues(Ljava/lang/Comparable;Ljava/lang/Comparable;)I
fun <T : Comparable<*>> compareValues(a: T : Comparable<*>?, b: T : Comparable<*>?): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = compareValuesBy(Ljava/lang/Object;Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)I
inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int

// JVM method = compareValuesBy(Ljava/lang/Object;Ljava/lang/Object;[Lkotlin/jvm/functions/Function1;)I
fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>? /* Array<out (T) -> Comparable<*>?> */): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = compareValuesBy(Ljava/lang/Object;Ljava/lang/Object;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)I
inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K> /* = java.util.Comparator<in K> */, selector: (T) -> K): Int

// JVM method = compareValuesByImpl$ComparisonsKt__ComparisonsKt(Ljava/lang/Object;Ljava/lang/Object;[Lkotlin/jvm/functions/Function1;)I
private fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int

// JVM method = naturalOrder()Ljava/util/Comparator;
fun <T : Comparable<T>> naturalOrder(): Comparator<T : Comparable<T>> /* = java.util.Comparator<T : Comparable<T>> */

// JVM method = nullsFirst()Ljava/util/Comparator;
inline fun <T : Comparable<T>> nullsFirst(): Comparator<T : Comparable<T>?> /* = java.util.Comparator<T : Comparable<T>?> */

// JVM method = nullsFirst(Ljava/util/Comparator;)Ljava/util/Comparator;
fun <T : Any> nullsFirst(comparator: Comparator<in T : Any> /* = java.util.Comparator<in T : Any> */): Comparator<T : Any?> /* = java.util.Comparator<T : Any?> */

// JVM method = nullsLast()Ljava/util/Comparator;
inline fun <T : Comparable<T>> nullsLast(): Comparator<T : Comparable<T>?> /* = java.util.Comparator<T : Comparable<T>?> */

// JVM method = nullsLast(Ljava/util/Comparator;)Ljava/util/Comparator;
fun <T : Any> nullsLast(comparator: Comparator<in T : Any> /* = java.util.Comparator<in T : Any> */): Comparator<T : Any?> /* = java.util.Comparator<T : Any?> */

// JVM method = reverseOrder()Ljava/util/Comparator;
fun <T : Comparable<T>> reverseOrder(): Comparator<T : Comparable<T>> /* = java.util.Comparator<T : Comparable<T>> */

// JVM method = reversed(Ljava/util/Comparator;)Ljava/util/Comparator;
fun <T> Comparator<T> /* = java.util.Comparator<T> */.reversed(): Comparator<T> /* = java.util.Comparator<T> */

// JVM method = then(Ljava/util/Comparator;Ljava/util/Comparator;)Ljava/util/Comparator;
infix fun <T> Comparator<T> /* = java.util.Comparator<T> */.then(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): Comparator<T> /* = java.util.Comparator<T> */

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = thenBy(Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/util/Comparator;
inline fun <T> Comparator<T> /* = java.util.Comparator<T> */.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> /* = java.util.Comparator<T> */

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = thenBy(Ljava/util/Comparator;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/util/Comparator;
inline fun <T, K> Comparator<T> /* = java.util.Comparator<T> */.thenBy(comparator: Comparator<in K> /* = java.util.Comparator<in K> */, crossinline selector: (T) -> K): Comparator<T> /* = java.util.Comparator<T> */

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = thenByDescending(Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/util/Comparator;
inline fun <T> Comparator<T> /* = java.util.Comparator<T> */.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> /* = java.util.Comparator<T> */

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = thenByDescending(Ljava/util/Comparator;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/util/Comparator;
inline fun <T, K> Comparator<T> /* = java.util.Comparator<T> */.thenByDescending(comparator: Comparator<in K> /* = java.util.Comparator<in K> */, crossinline selector: (T) -> K): Comparator<T> /* = java.util.Comparator<T> */

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = thenComparator(Ljava/util/Comparator;Lkotlin/jvm/functions/Function2;)Ljava/util/Comparator;
inline fun <T> Comparator<T> /* = java.util.Comparator<T> */.thenComparator(crossinline comparison: (@ParameterName(name = "a") T, @ParameterName(name = "b") T) -> Int): Comparator<T> /* = java.util.Comparator<T> */

// JVM method = thenDescending(Ljava/util/Comparator;Ljava/util/Comparator;)Ljava/util/Comparator;
infix fun <T> Comparator<T> /* = java.util.Comparator<T> */.thenDescending(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): Comparator<T> /* = java.util.Comparator<T> */

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.comparisons.ComparisonsKt


// *** FUNCTIONS ***

// JVM method = maxOf(Ljava/lang/Comparable;Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> maxOf(a: T : Comparable<T>, b: T : Comparable<T>): T : Comparable<T>

// JVM method = maxOf(Ljava/lang/Comparable;Ljava/lang/Comparable;Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> maxOf(a: T : Comparable<T>, b: T : Comparable<T>, c: T : Comparable<T>): T : Comparable<T>

// JVM method = maxOf(Ljava/lang/Comparable;[Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> maxOf(a: T : Comparable<T>, vararg other: T : Comparable<T> /* Array<out T : Comparable<T>> */): T : Comparable<T>

// JVM method = maxOf(BB)B
inline fun maxOf(a: Byte, b: Byte): Byte

// JVM method = maxOf(BBB)B
inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte

// JVM method = maxOf(B[B)B
fun maxOf(a: Byte, vararg other: Byte /* ByteArray */): Byte

// JVM method = maxOf(DD)D
inline fun maxOf(a: Double, b: Double): Double

// JVM method = maxOf(DDD)D
inline fun maxOf(a: Double, b: Double, c: Double): Double

// JVM method = maxOf(D[D)D
fun maxOf(a: Double, vararg other: Double /* DoubleArray */): Double

// JVM method = maxOf(FF)F
inline fun maxOf(a: Float, b: Float): Float

// JVM method = maxOf(FFF)F
inline fun maxOf(a: Float, b: Float, c: Float): Float

// JVM method = maxOf(F[F)F
fun maxOf(a: Float, vararg other: Float /* FloatArray */): Float

// JVM method = maxOf(II)I
inline fun maxOf(a: Int, b: Int): Int

// JVM method = maxOf(III)I
inline fun maxOf(a: Int, b: Int, c: Int): Int

// JVM method = maxOf(I[I)I
fun maxOf(a: Int, vararg other: Int /* IntArray */): Int

// JVM method = maxOf(JJ)J
inline fun maxOf(a: Long, b: Long): Long

// JVM method = maxOf(JJJ)J
inline fun maxOf(a: Long, b: Long, c: Long): Long

// JVM method = maxOf(J[J)J
fun maxOf(a: Long, vararg other: Long /* LongArray */): Long

// JVM method = maxOf(SS)S
inline fun maxOf(a: Short, b: Short): Short

// JVM method = maxOf(SSS)S
inline fun maxOf(a: Short, b: Short, c: Short): Short

// JVM method = maxOf(S[S)S
fun maxOf(a: Short, vararg other: Short /* ShortArray */): Short

// JVM method = minOf(Ljava/lang/Comparable;Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> minOf(a: T : Comparable<T>, b: T : Comparable<T>): T : Comparable<T>

// JVM method = minOf(Ljava/lang/Comparable;Ljava/lang/Comparable;Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> minOf(a: T : Comparable<T>, b: T : Comparable<T>, c: T : Comparable<T>): T : Comparable<T>

// JVM method = minOf(Ljava/lang/Comparable;[Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> minOf(a: T : Comparable<T>, vararg other: T : Comparable<T> /* Array<out T : Comparable<T>> */): T : Comparable<T>

// JVM method = minOf(BB)B
inline fun minOf(a: Byte, b: Byte): Byte

// JVM method = minOf(BBB)B
inline fun minOf(a: Byte, b: Byte, c: Byte): Byte

// JVM method = minOf(B[B)B
fun minOf(a: Byte, vararg other: Byte /* ByteArray */): Byte

// JVM method = minOf(DD)D
inline fun minOf(a: Double, b: Double): Double

// JVM method = minOf(DDD)D
inline fun minOf(a: Double, b: Double, c: Double): Double

// JVM method = minOf(D[D)D
fun minOf(a: Double, vararg other: Double /* DoubleArray */): Double

// JVM method = minOf(FF)F
inline fun minOf(a: Float, b: Float): Float

// JVM method = minOf(FFF)F
inline fun minOf(a: Float, b: Float, c: Float): Float

// JVM method = minOf(F[F)F
fun minOf(a: Float, vararg other: Float /* FloatArray */): Float

// JVM method = minOf(II)I
inline fun minOf(a: Int, b: Int): Int

// JVM method = minOf(III)I
inline fun minOf(a: Int, b: Int, c: Int): Int

// JVM method = minOf(I[I)I
fun minOf(a: Int, vararg other: Int /* IntArray */): Int

// JVM method = minOf(JJ)J
inline fun minOf(a: Long, b: Long): Long

// JVM method = minOf(JJJ)J
inline fun minOf(a: Long, b: Long, c: Long): Long

// JVM method = minOf(J[J)J
fun minOf(a: Long, vararg other: Long /* LongArray */): Long

// JVM method = minOf(SS)S
inline fun minOf(a: Short, b: Short): Short

// JVM method = minOf(SSS)S
inline fun minOf(a: Short, b: Short, c: Short): Short

// JVM method = minOf(S[S)S
fun minOf(a: Short, vararg other: Short /* ShortArray */): Short

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.comparisons.ComparisonsKt


// *** FUNCTIONS ***

// JVM method = maxOf(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> maxOf(a: T, b: T, c: T, comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T

// JVM method = maxOf(Ljava/lang/Object;Ljava/lang/Object;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> maxOf(a: T, b: T, comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T

// JVM method = maxOf(Ljava/lang/Object;[Ljava/lang/Object;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> maxOf(a: T, vararg other: T /* Array<out T> */, comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T

// JVM method = minOf(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> minOf(a: T, b: T, c: T, comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T

// JVM method = minOf(Ljava/lang/Object;Ljava/lang/Object;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> minOf(a: T, b: T, comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T

// JVM method = minOf(Ljava/lang/Object;[Ljava/lang/Object;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> minOf(a: T, vararg other: T /* Array<out T> */, comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.comparisons.UComparisonsKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-Kr8caGY(BB)B
fun maxOf(a: UByte, b: UByte): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-b33U2AM(BBB)B
inline fun maxOf(a: UByte, b: UByte, c: UByte): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-Wr6uiD8(B[B)B
fun maxOf(a: UByte, vararg other: UByte /* UByteArray */): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-J1ME1BU(II)I
fun maxOf(a: UInt, b: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-WZ9TVnA(III)I
inline fun maxOf(a: UInt, b: UInt, c: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-Md2H83M(I[I)I
fun maxOf(a: UInt, vararg other: UInt /* UIntArray */): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-eb3DHEI(JJ)J
fun maxOf(a: ULong, b: ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-sambcqE(JJJ)J
inline fun maxOf(a: ULong, b: ULong, c: ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-R03FKyM(J[J)J
fun maxOf(a: ULong, vararg other: ULong /* ULongArray */): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-5PvTz6A(SS)S
fun maxOf(a: UShort, b: UShort): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-VKSA0NQ(SSS)S
inline fun maxOf(a: UShort, b: UShort, c: UShort): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = maxOf-t1qELG4(S[S)S
fun maxOf(a: UShort, vararg other: UShort /* UShortArray */): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-Kr8caGY(BB)B
fun minOf(a: UByte, b: UByte): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-b33U2AM(BBB)B
inline fun minOf(a: UByte, b: UByte, c: UByte): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-Wr6uiD8(B[B)B
fun minOf(a: UByte, vararg other: UByte /* UByteArray */): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-J1ME1BU(II)I
fun minOf(a: UInt, b: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-WZ9TVnA(III)I
inline fun minOf(a: UInt, b: UInt, c: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-Md2H83M(I[I)I
fun minOf(a: UInt, vararg other: UInt /* UIntArray */): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-eb3DHEI(JJ)J
fun minOf(a: ULong, b: ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-sambcqE(JJJ)J
inline fun minOf(a: ULong, b: ULong, c: ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-R03FKyM(J[J)J
fun minOf(a: ULong, vararg other: ULong /* ULongArray */): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-5PvTz6A(SS)S
fun minOf(a: UShort, b: UShort): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-VKSA0NQ(SSS)S
inline fun minOf(a: UShort, b: UShort, c: UShort): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = minOf-t1qELG4(S[S)S
fun minOf(a: UShort, vararg other: UShort /* UShortArray */): UShort

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.coroutines.intrinsics.IntrinsicsKt


// *** FUNCTIONS ***

// JVM method = createCoroutineFromSuspendFunction$IntrinsicsKt__IntrinsicsJvmKt(Lkotlin/coroutines/Continuation;Lkotlin/jvm/functions/Function1;)Lkotlin/coroutines/Continuation;
private inline fun <T> createCoroutineFromSuspendFunction(completion: kotlin.coroutines.Continuation<T>, crossinline block: (kotlin.coroutines.Continuation<T>) -> Any?): kotlin.coroutines.Continuation<Unit>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = createCoroutineUnintercepted(Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation;
fun <T> suspend () -> T.createCoroutineUnintercepted(completion: kotlin.coroutines.Continuation<T>): kotlin.coroutines.Continuation<Unit>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = createCoroutineUnintercepted(Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation;
fun <R, T> suspend R.() -> T.createCoroutineUnintercepted(receiver: R, completion: kotlin.coroutines.Continuation<T>): kotlin.coroutines.Continuation<Unit>

// JVM method = intercepted(Lkotlin/coroutines/Continuation;)Lkotlin/coroutines/Continuation;
fun <T> kotlin.coroutines.Continuation<T>.intercepted(): kotlin.coroutines.Continuation<T>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = startCoroutineUninterceptedOrReturn(Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
inline fun <T> suspend () -> T.startCoroutineUninterceptedOrReturn(completion: kotlin.coroutines.Continuation<T>): Any?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = startCoroutineUninterceptedOrReturn(Lkotlin/jvm/functions/Function2;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
inline fun <R, T> suspend R.() -> T.startCoroutineUninterceptedOrReturn(receiver: R, completion: kotlin.coroutines.Continuation<T>): Any?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = startCoroutineUninterceptedOrReturn(Lkotlin/jvm/functions/Function3;Ljava/lang/Object;Ljava/lang/Object;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
internal inline fun <R, P, T> suspend R.(P) -> T.startCoroutineUninterceptedOrReturn(receiver: R, param: P, completion: kotlin.coroutines.Continuation<T>): Any?

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.coroutines.intrinsics.IntrinsicsKt


// *** PROPERTIES ***

// JVM annotation-holding method = getCOROUTINE_SUSPENDED$annotations()V
val COROUTINE_SUSPENDED: Any
	// JVM method = getCOROUTINE_SUSPENDED()Ljava/lang/Object;
	get() = /* non-default */


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = suspendCoroutineUninterceptedOrReturn(Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (kotlin.coroutines.Continuation<T>) -> Any?): T {
	contract {
		callsInPlace(block, InvocationKind.EXACTLY_ONCE)
	}
}

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.io.FilesKt


// *** PROPERTIES ***

val java.io.File.isRooted: Boolean
	// JVM method = isRooted(Ljava/io/File;)Z
	get() = /* non-default */

internal val java.io.File.root: java.io.File
	// JVM method = getRoot(Ljava/io/File;)Ljava/io/File;
	get() = /* non-default */

internal val java.io.File.rootName: String
	// JVM method = getRootName(Ljava/io/File;)Ljava/lang/String;
	get() = /* non-default */


// *** FUNCTIONS ***

// JVM method = getRootLength$FilesKt__FilePathComponentsKt(Ljava/lang/String;)I
private fun String.getRootLength(): Int

// JVM method = subPath(Ljava/io/File;II)Ljava/io/File;
internal fun java.io.File.subPath(beginIndex: Int, endIndex: Int): java.io.File

// JVM method = toComponents(Ljava/io/File;)Lkotlin/io/FilePathComponents;
internal fun java.io.File.toComponents(): FilePathComponents

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.io.FilesKt


// *** FUNCTIONS ***

// JVM method = appendBytes(Ljava/io/File;[B)V
fun java.io.File.appendBytes(array: ByteArray)

// JVM method = appendText(Ljava/io/File;Ljava/lang/String;Ljava/nio/charset/Charset;)V
fun java.io.File.appendText(text: String, charset: java.nio.charset.Charset /* = default */)

// JVM method = bufferedReader(Ljava/io/File;Ljava/nio/charset/Charset;I)Ljava/io/BufferedReader;
inline fun java.io.File.bufferedReader(charset: java.nio.charset.Charset /* = default */, bufferSize: Int /* = default */): java.io.BufferedReader

// JVM method = bufferedWriter(Ljava/io/File;Ljava/nio/charset/Charset;I)Ljava/io/BufferedWriter;
inline fun java.io.File.bufferedWriter(charset: java.nio.charset.Charset /* = default */, bufferSize: Int /* = default */): java.io.BufferedWriter

// JVM method = forEachBlock(Ljava/io/File;Lkotlin/jvm/functions/Function2;)V
fun java.io.File.forEachBlock(action: (@ParameterName(name = "buffer") ByteArray, @ParameterName(name = "bytesRead") Int) -> Unit)

// JVM method = forEachBlock(Ljava/io/File;ILkotlin/jvm/functions/Function2;)V
fun java.io.File.forEachBlock(blockSize: Int, action: (@ParameterName(name = "buffer") ByteArray, @ParameterName(name = "bytesRead") Int) -> Unit)

// JVM method = forEachLine(Ljava/io/File;Ljava/nio/charset/Charset;Lkotlin/jvm/functions/Function1;)V
fun java.io.File.forEachLine(charset: java.nio.charset.Charset /* = default */, action: (@ParameterName(name = "line") String) -> Unit)

// JVM method = inputStream(Ljava/io/File;)Ljava/io/FileInputStream;
inline fun java.io.File.inputStream(): java.io.FileInputStream

// JVM method = outputStream(Ljava/io/File;)Ljava/io/FileOutputStream;
inline fun java.io.File.outputStream(): java.io.FileOutputStream

// JVM method = printWriter(Ljava/io/File;Ljava/nio/charset/Charset;)Ljava/io/PrintWriter;
inline fun java.io.File.printWriter(charset: java.nio.charset.Charset /* = default */): java.io.PrintWriter

// JVM method = readBytes(Ljava/io/File;)[B
fun java.io.File.readBytes(): ByteArray

// JVM method = readLines(Ljava/io/File;Ljava/nio/charset/Charset;)Ljava/util/List;
fun java.io.File.readLines(charset: java.nio.charset.Charset /* = default */): List<String>

// JVM method = readText(Ljava/io/File;Ljava/nio/charset/Charset;)Ljava/lang/String;
fun java.io.File.readText(charset: java.nio.charset.Charset /* = default */): String

// JVM method = reader(Ljava/io/File;Ljava/nio/charset/Charset;)Ljava/io/InputStreamReader;
inline fun java.io.File.reader(charset: java.nio.charset.Charset /* = default */): java.io.InputStreamReader

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = useLines(Ljava/io/File;Ljava/nio/charset/Charset;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> java.io.File.useLines(charset: java.nio.charset.Charset /* = default */, block: (Sequence<String>) -> T): T

// JVM method = writeBytes(Ljava/io/File;[B)V
fun java.io.File.writeBytes(array: ByteArray)

// JVM method = writeText(Ljava/io/File;Ljava/lang/String;Ljava/nio/charset/Charset;)V
fun java.io.File.writeText(text: String, charset: java.nio.charset.Charset /* = default */)

// JVM method = writer(Ljava/io/File;Ljava/nio/charset/Charset;)Ljava/io/OutputStreamWriter;
inline fun java.io.File.writer(charset: java.nio.charset.Charset /* = default */): java.io.OutputStreamWriter

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.io.FilesKt


// *** FUNCTIONS ***

// JVM method = walk(Ljava/io/File;Lkotlin/io/FileWalkDirection;)Lkotlin/io/FileTreeWalk;
fun java.io.File.walk(direction: FileWalkDirection /* = default */): FileTreeWalk

// JVM method = walkBottomUp(Ljava/io/File;)Lkotlin/io/FileTreeWalk;
fun java.io.File.walkBottomUp(): FileTreeWalk

// JVM method = walkTopDown(Ljava/io/File;)Lkotlin/io/FileTreeWalk;
fun java.io.File.walkTopDown(): FileTreeWalk

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.io.FilesKt


// *** PROPERTIES ***

val java.io.File.extension: String
	// JVM method = getExtension(Ljava/io/File;)Ljava/lang/String;
	get() = /* non-default */

val java.io.File.invariantSeparatorsPath: String
	// JVM method = getInvariantSeparatorsPath(Ljava/io/File;)Ljava/lang/String;
	get() = /* non-default */

val java.io.File.nameWithoutExtension: String
	// JVM method = getNameWithoutExtension(Ljava/io/File;)Ljava/lang/String;
	get() = /* non-default */


// *** FUNCTIONS ***

// JVM method = createTempDir(Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;
fun createTempDir(prefix: String /* = default */, suffix: String? /* = default */, directory: java.io.File? /* = default */): java.io.File

// JVM method = createTempFile(Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;
fun createTempFile(prefix: String /* = default */, suffix: String? /* = default */, directory: java.io.File? /* = default */): java.io.File

// JVM method = copyRecursively(Ljava/io/File;Ljava/io/File;ZLkotlin/jvm/functions/Function2;)Z
fun java.io.File.copyRecursively(target: java.io.File, overwrite: Boolean /* = default */, onError: (java.io.File, java.io.IOException) -> OnErrorAction /* = default */): Boolean

// JVM method = copyTo(Ljava/io/File;Ljava/io/File;ZI)Ljava/io/File;
fun java.io.File.copyTo(target: java.io.File, overwrite: Boolean /* = default */, bufferSize: Int /* = default */): java.io.File

// JVM method = deleteRecursively(Ljava/io/File;)Z
fun java.io.File.deleteRecursively(): Boolean

// JVM method = endsWith(Ljava/io/File;Ljava/io/File;)Z
fun java.io.File.endsWith(other: java.io.File): Boolean

// JVM method = endsWith(Ljava/io/File;Ljava/lang/String;)Z
fun java.io.File.endsWith(other: String): Boolean

// JVM method = normalize(Ljava/io/File;)Ljava/io/File;
fun java.io.File.normalize(): java.io.File

// JVM method = normalize$FilesKt__UtilsKt(Ljava/util/List;)Ljava/util/List;
private fun List<java.io.File>.normalize(): List<java.io.File>

// JVM method = normalize$FilesKt__UtilsKt(Lkotlin/io/FilePathComponents;)Lkotlin/io/FilePathComponents;
private fun FilePathComponents.normalize(): FilePathComponents

// JVM method = relativeTo(Ljava/io/File;Ljava/io/File;)Ljava/io/File;
fun java.io.File.relativeTo(base: java.io.File): java.io.File

// JVM method = relativeToOrNull(Ljava/io/File;Ljava/io/File;)Ljava/io/File;
fun java.io.File.relativeToOrNull(base: java.io.File): java.io.File?

// JVM method = relativeToOrSelf(Ljava/io/File;Ljava/io/File;)Ljava/io/File;
fun java.io.File.relativeToOrSelf(base: java.io.File): java.io.File

// JVM method = resolve(Ljava/io/File;Ljava/io/File;)Ljava/io/File;
fun java.io.File.resolve(relative: java.io.File): java.io.File

// JVM method = resolve(Ljava/io/File;Ljava/lang/String;)Ljava/io/File;
fun java.io.File.resolve(relative: String): java.io.File

// JVM method = resolveSibling(Ljava/io/File;Ljava/io/File;)Ljava/io/File;
fun java.io.File.resolveSibling(relative: java.io.File): java.io.File

// JVM method = resolveSibling(Ljava/io/File;Ljava/lang/String;)Ljava/io/File;
fun java.io.File.resolveSibling(relative: String): java.io.File

// JVM method = startsWith(Ljava/io/File;Ljava/io/File;)Z
fun java.io.File.startsWith(other: java.io.File): Boolean

// JVM method = startsWith(Ljava/io/File;Ljava/lang/String;)Z
fun java.io.File.startsWith(other: String): Boolean

// JVM method = toRelativeString(Ljava/io/File;Ljava/io/File;)Ljava/lang/String;
fun java.io.File.toRelativeString(base: java.io.File): String

// JVM method = toRelativeStringOrNull$FilesKt__UtilsKt(Ljava/io/File;Ljava/io/File;)Ljava/lang/String;
private fun java.io.File.toRelativeStringOrNull(base: java.io.File): String?

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.io.encoding.StreamEncodingKt


// *** FUNCTIONS ***

// JVM method = decodingWith(Ljava/io/InputStream;Lkotlin/io/encoding/Base64;)Ljava/io/InputStream;
fun java.io.InputStream.decodingWith(base64: kotlin.io.encoding.Base64): java.io.InputStream

// JVM method = encodingWith(Ljava/io/OutputStream;Lkotlin/io/encoding/Base64;)Ljava/io/OutputStream;
fun java.io.OutputStream.encodingWith(base64: kotlin.io.encoding.Base64): java.io.OutputStream

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.math.MathKt


// *** PROPERTIES ***

// JVM field = E:D
// JVM annotation-holding method = getE$annotations()V
const val E: Double

// JVM field = PI:D
// JVM annotation-holding method = getPI$annotations()V
const val PI: Double

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.math.MathKt


// *** PROPERTIES ***

// JVM annotation-holding method = getAbsoluteValue$annotations(D)V
inline val Double.absoluteValue: Double
	// JVM method = getAbsoluteValue(D)D
	get() = /* non-default */

// JVM annotation-holding method = getAbsoluteValue$annotations(F)V
inline val Float.absoluteValue: Float
	// JVM method = getAbsoluteValue(F)F
	get() = /* non-default */

// JVM annotation-holding method = getAbsoluteValue$annotations(I)V
inline val Int.absoluteValue: Int
	// JVM method = getAbsoluteValue(I)I
	get() = /* non-default */

// JVM annotation-holding method = getAbsoluteValue$annotations(J)V
inline val Long.absoluteValue: Long
	// JVM method = getAbsoluteValue(J)J
	get() = /* non-default */

// JVM annotation-holding method = getSign$annotations(D)V
inline val Double.sign: Double
	// JVM method = getSign(D)D
	get() = /* non-default */

// JVM annotation-holding method = getSign$annotations(F)V
inline val Float.sign: Float
	// JVM method = getSign(F)F
	get() = /* non-default */

// JVM annotation-holding method = getSign$annotations(I)V
val Int.sign: Int
	// JVM method = getSign(I)I
	get() = /* non-default */

// JVM annotation-holding method = getSign$annotations(J)V
val Long.sign: Int
	// JVM method = getSign(J)I
	get() = /* non-default */

// JVM annotation-holding method = getUlp$annotations(D)V
inline val Double.ulp: Double
	// JVM method = getUlp(D)D
	get() = /* non-default */

// JVM annotation-holding method = getUlp$annotations(F)V
inline val Float.ulp: Float
	// JVM method = getUlp(F)F
	get() = /* non-default */


// *** FUNCTIONS ***

// JVM method = abs(D)D
inline fun abs(x: Double): Double

// JVM method = abs(F)F
inline fun abs(x: Float): Float

// JVM method = abs(I)I
inline fun abs(n: Int): Int

// JVM method = abs(J)J
inline fun abs(n: Long): Long

// JVM method = acos(D)D
inline fun acos(x: Double): Double

// JVM method = acos(F)F
inline fun acos(x: Float): Float

// JVM method = acosh(D)D
fun acosh(x: Double): Double

// JVM method = acosh(F)F
inline fun acosh(x: Float): Float

// JVM method = asin(D)D
inline fun asin(x: Double): Double

// JVM method = asin(F)F
inline fun asin(x: Float): Float

// JVM method = asinh(D)D
fun asinh(x: Double): Double

// JVM method = asinh(F)F
inline fun asinh(x: Float): Float

// JVM method = atan(D)D
inline fun atan(x: Double): Double

// JVM method = atan(F)F
inline fun atan(x: Float): Float

// JVM method = atan2(DD)D
inline fun atan2(y: Double, x: Double): Double

// JVM method = atan2(FF)F
inline fun atan2(y: Float, x: Float): Float

// JVM method = atanh(D)D
fun atanh(x: Double): Double

// JVM method = atanh(F)F
inline fun atanh(x: Float): Float

// JVM method = cbrt(D)D
inline fun cbrt(x: Double): Double

// JVM method = cbrt(F)F
inline fun cbrt(x: Float): Float

// JVM method = ceil(D)D
inline fun ceil(x: Double): Double

// JVM method = ceil(F)F
inline fun ceil(x: Float): Float

// JVM method = cos(D)D
inline fun cos(x: Double): Double

// JVM method = cos(F)F
inline fun cos(x: Float): Float

// JVM method = cosh(D)D
inline fun cosh(x: Double): Double

// JVM method = cosh(F)F
inline fun cosh(x: Float): Float

// JVM method = exp(D)D
inline fun exp(x: Double): Double

// JVM method = exp(F)F
inline fun exp(x: Float): Float

// JVM method = expm1(D)D
inline fun expm1(x: Double): Double

// JVM method = expm1(F)F
inline fun expm1(x: Float): Float

// JVM method = floor(D)D
inline fun floor(x: Double): Double

// JVM method = floor(F)F
inline fun floor(x: Float): Float

// JVM method = hypot(DD)D
inline fun hypot(x: Double, y: Double): Double

// JVM method = hypot(FF)F
inline fun hypot(x: Float, y: Float): Float

// JVM method = ln(D)D
inline fun ln(x: Double): Double

// JVM method = ln(F)F
inline fun ln(x: Float): Float

// JVM method = ln1p(D)D
inline fun ln1p(x: Double): Double

// JVM method = ln1p(F)F
inline fun ln1p(x: Float): Float

// JVM method = log(DD)D
fun log(x: Double, base: Double): Double

// JVM method = log(FF)F
fun log(x: Float, base: Float): Float

// JVM method = log10(D)D
inline fun log10(x: Double): Double

// JVM method = log10(F)F
inline fun log10(x: Float): Float

// JVM method = log2(D)D
fun log2(x: Double): Double

// JVM method = log2(F)F
fun log2(x: Float): Float

// JVM method = max(DD)D
inline fun max(a: Double, b: Double): Double

// JVM method = max(FF)F
inline fun max(a: Float, b: Float): Float

// JVM method = max(II)I
inline fun max(a: Int, b: Int): Int

// JVM method = max(JJ)J
inline fun max(a: Long, b: Long): Long

// JVM method = min(DD)D
inline fun min(a: Double, b: Double): Double

// JVM method = min(FF)F
inline fun min(a: Float, b: Float): Float

// JVM method = min(II)I
inline fun min(a: Int, b: Int): Int

// JVM method = min(JJ)J
inline fun min(a: Long, b: Long): Long

// JVM method = round(D)D
inline fun round(x: Double): Double

// JVM method = round(F)F
inline fun round(x: Float): Float

// JVM method = sign(D)D
inline fun sign(x: Double): Double

// JVM method = sign(F)F
inline fun sign(x: Float): Float

// JVM method = sin(D)D
inline fun sin(x: Double): Double

// JVM method = sin(F)F
inline fun sin(x: Float): Float

// JVM method = sinh(D)D
inline fun sinh(x: Double): Double

// JVM method = sinh(F)F
inline fun sinh(x: Float): Float

// JVM method = sqrt(D)D
inline fun sqrt(x: Double): Double

// JVM method = sqrt(F)F
inline fun sqrt(x: Float): Float

// JVM method = tan(D)D
inline fun tan(x: Double): Double

// JVM method = tan(F)F
inline fun tan(x: Float): Float

// JVM method = tanh(D)D
inline fun tanh(x: Double): Double

// JVM method = tanh(F)F
inline fun tanh(x: Float): Float

// JVM method = truncate(D)D
fun truncate(x: Double): Double

// JVM method = truncate(F)F
fun truncate(x: Float): Float

// JVM method = IEEErem(DD)D
inline fun Double.IEEErem(divisor: Double): Double

// JVM method = IEEErem(FF)F
inline fun Float.IEEErem(divisor: Float): Float

// JVM method = nextDown(D)D
inline fun Double.nextDown(): Double

// JVM method = nextDown(F)F
inline fun Float.nextDown(): Float

// JVM method = nextTowards(DD)D
inline fun Double.nextTowards(to: Double): Double

// JVM method = nextTowards(FF)F
inline fun Float.nextTowards(to: Float): Float

// JVM method = nextUp(D)D
inline fun Double.nextUp(): Double

// JVM method = nextUp(F)F
inline fun Float.nextUp(): Float

// JVM method = pow(DD)D
inline fun Double.pow(x: Double): Double

// JVM method = pow(DI)D
inline fun Double.pow(n: Int): Double

// JVM method = pow(FF)F
inline fun Float.pow(x: Float): Float

// JVM method = pow(FI)F
inline fun Float.pow(n: Int): Float

// JVM method = roundToInt(D)I
fun Double.roundToInt(): Int

// JVM method = roundToInt(F)I
fun Float.roundToInt(): Int

// JVM method = roundToLong(D)J
fun Double.roundToLong(): Long

// JVM method = roundToLong(F)J
fun Float.roundToLong(): Long

// JVM method = withSign(DD)D
inline fun Double.withSign(sign: Double): Double

// JVM method = withSign(DI)D
inline fun Double.withSign(sign: Int): Double

// JVM method = withSign(FF)F
inline fun Float.withSign(sign: Float): Float

// JVM method = withSign(FI)F
inline fun Float.withSign(sign: Int): Float

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.ranges.RangesKt


// *** FUNCTIONS ***

// JVM method = checkStepIsPositive(ZLjava/lang/Number;)V
internal fun checkStepIsPositive(isPositive: Boolean, step: Number)

// JVM method = contains(Lkotlin/ranges/ClosedRange;Ljava/lang/Object;)Z
inline operator fun <T : Any, R> R.contains(element: T : Any?): Boolean where
	R : ClosedRange<T : Any>,
	R : Iterable<T : Any>

// JVM method = contains(Lkotlin/ranges/OpenEndRange;Ljava/lang/Object;)Z
inline operator fun <T : Any, R> R.contains(element: T : Any?): Boolean where
	R : OpenEndRange<T : Any>,
	R : Iterable<T : Any>

// JVM method = rangeTo(Ljava/lang/Comparable;Ljava/lang/Comparable;)Lkotlin/ranges/ClosedRange;
operator fun <T : Comparable<T>> T : Comparable<T>.rangeTo(that: T : Comparable<T>): ClosedRange<T : Comparable<T>>

// JVM method = rangeTo(DD)Lkotlin/ranges/ClosedFloatingPointRange;
operator fun Double.rangeTo(that: Double): ClosedFloatingPointRange<Double>

// JVM method = rangeTo(FF)Lkotlin/ranges/ClosedFloatingPointRange;
operator fun Float.rangeTo(that: Float): ClosedFloatingPointRange<Float>

// JVM method = rangeUntil(Ljava/lang/Comparable;Ljava/lang/Comparable;)Lkotlin/ranges/OpenEndRange;
operator fun <T : Comparable<T>> T : Comparable<T>.rangeUntil(that: T : Comparable<T>): OpenEndRange<T : Comparable<T>>

// JVM method = rangeUntil(DD)Lkotlin/ranges/OpenEndRange;
operator fun Double.rangeUntil(that: Double): OpenEndRange<Double>

// JVM method = rangeUntil(FF)Lkotlin/ranges/OpenEndRange;
operator fun Float.rangeUntil(that: Float): OpenEndRange<Float>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.ranges.RangesKt


// *** FUNCTIONS ***

// JVM method = coerceAtLeast(Ljava/lang/Comparable;Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> T : Comparable<T>.coerceAtLeast(minimumValue: T : Comparable<T>): T : Comparable<T>

// JVM method = coerceAtLeast(BB)B
fun Byte.coerceAtLeast(minimumValue: Byte): Byte

// JVM method = coerceAtLeast(DD)D
fun Double.coerceAtLeast(minimumValue: Double): Double

// JVM method = coerceAtLeast(FF)F
fun Float.coerceAtLeast(minimumValue: Float): Float

// JVM method = coerceAtLeast(II)I
fun Int.coerceAtLeast(minimumValue: Int): Int

// JVM method = coerceAtLeast(JJ)J
fun Long.coerceAtLeast(minimumValue: Long): Long

// JVM method = coerceAtLeast(SS)S
fun Short.coerceAtLeast(minimumValue: Short): Short

// JVM method = coerceAtMost(Ljava/lang/Comparable;Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> T : Comparable<T>.coerceAtMost(maximumValue: T : Comparable<T>): T : Comparable<T>

// JVM method = coerceAtMost(BB)B
fun Byte.coerceAtMost(maximumValue: Byte): Byte

// JVM method = coerceAtMost(DD)D
fun Double.coerceAtMost(maximumValue: Double): Double

// JVM method = coerceAtMost(FF)F
fun Float.coerceAtMost(maximumValue: Float): Float

// JVM method = coerceAtMost(II)I
fun Int.coerceAtMost(maximumValue: Int): Int

// JVM method = coerceAtMost(JJ)J
fun Long.coerceAtMost(maximumValue: Long): Long

// JVM method = coerceAtMost(SS)S
fun Short.coerceAtMost(maximumValue: Short): Short

// JVM method = coerceIn(Ljava/lang/Comparable;Ljava/lang/Comparable;Ljava/lang/Comparable;)Ljava/lang/Comparable;
fun <T : Comparable<T>> T : Comparable<T>.coerceIn(minimumValue: T : Comparable<T>?, maximumValue: T : Comparable<T>?): T : Comparable<T>

// JVM method = coerceIn(Ljava/lang/Comparable;Lkotlin/ranges/ClosedFloatingPointRange;)Ljava/lang/Comparable;
fun <T : Comparable<T>> T : Comparable<T>.coerceIn(range: ClosedFloatingPointRange<T : Comparable<T>>): T : Comparable<T>

// JVM method = coerceIn(Ljava/lang/Comparable;Lkotlin/ranges/ClosedRange;)Ljava/lang/Comparable;
fun <T : Comparable<T>> T : Comparable<T>.coerceIn(range: ClosedRange<T : Comparable<T>>): T : Comparable<T>

// JVM method = coerceIn(BBB)B
fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte

// JVM method = coerceIn(DDD)D
fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double

// JVM method = coerceIn(FFF)F
fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float

// JVM method = coerceIn(III)I
fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int

// JVM method = coerceIn(ILkotlin/ranges/ClosedRange;)I
fun Int.coerceIn(range: ClosedRange<Int>): Int

// JVM method = coerceIn(JJJ)J
fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long

// JVM method = coerceIn(JLkotlin/ranges/ClosedRange;)J
fun Long.coerceIn(range: ClosedRange<Long>): Long

// JVM method = coerceIn(SSS)S
fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short

// JVM method = contains(Lkotlin/ranges/CharRange;Ljava/lang/Character;)Z
inline operator fun CharRange.contains(element: Char?): Boolean

// JVM method = byteRangeContains(Lkotlin/ranges/ClosedRange;D)Z
operator fun ClosedRange<Byte>.contains(value: Double): Boolean

// JVM method = byteRangeContains(Lkotlin/ranges/ClosedRange;F)Z
operator fun ClosedRange<Byte>.contains(value: Float): Boolean

// JVM method = byteRangeContains(Lkotlin/ranges/ClosedRange;I)Z
operator fun ClosedRange<Byte>.contains(value: Int): Boolean

// JVM method = byteRangeContains(Lkotlin/ranges/ClosedRange;J)Z
operator fun ClosedRange<Byte>.contains(value: Long): Boolean

// JVM method = byteRangeContains(Lkotlin/ranges/ClosedRange;S)Z
operator fun ClosedRange<Byte>.contains(value: Short): Boolean

// JVM method = doubleRangeContains(Lkotlin/ranges/ClosedRange;B)Z
operator fun ClosedRange<Double>.contains(value: Byte): Boolean

// JVM method = doubleRangeContains(Lkotlin/ranges/ClosedRange;F)Z
operator fun ClosedRange<Double>.contains(value: Float): Boolean

// JVM method = doubleRangeContains(Lkotlin/ranges/ClosedRange;I)Z
operator fun ClosedRange<Double>.contains(value: Int): Boolean

// JVM method = doubleRangeContains(Lkotlin/ranges/ClosedRange;J)Z
operator fun ClosedRange<Double>.contains(value: Long): Boolean

// JVM method = doubleRangeContains(Lkotlin/ranges/ClosedRange;S)Z
operator fun ClosedRange<Double>.contains(value: Short): Boolean

// JVM method = floatRangeContains(Lkotlin/ranges/ClosedRange;B)Z
operator fun ClosedRange<Float>.contains(value: Byte): Boolean

// JVM method = floatRangeContains(Lkotlin/ranges/ClosedRange;D)Z
operator fun ClosedRange<Float>.contains(value: Double): Boolean

// JVM method = floatRangeContains(Lkotlin/ranges/ClosedRange;I)Z
operator fun ClosedRange<Float>.contains(value: Int): Boolean

// JVM method = floatRangeContains(Lkotlin/ranges/ClosedRange;J)Z
operator fun ClosedRange<Float>.contains(value: Long): Boolean

// JVM method = floatRangeContains(Lkotlin/ranges/ClosedRange;S)Z
operator fun ClosedRange<Float>.contains(value: Short): Boolean

// JVM method = intRangeContains(Lkotlin/ranges/ClosedRange;B)Z
operator fun ClosedRange<Int>.contains(value: Byte): Boolean

// JVM method = intRangeContains(Lkotlin/ranges/ClosedRange;D)Z
operator fun ClosedRange<Int>.contains(value: Double): Boolean

// JVM method = intRangeContains(Lkotlin/ranges/ClosedRange;F)Z
operator fun ClosedRange<Int>.contains(value: Float): Boolean

// JVM method = intRangeContains(Lkotlin/ranges/ClosedRange;J)Z
operator fun ClosedRange<Int>.contains(value: Long): Boolean

// JVM method = intRangeContains(Lkotlin/ranges/ClosedRange;S)Z
operator fun ClosedRange<Int>.contains(value: Short): Boolean

// JVM method = longRangeContains(Lkotlin/ranges/ClosedRange;B)Z
operator fun ClosedRange<Long>.contains(value: Byte): Boolean

// JVM method = longRangeContains(Lkotlin/ranges/ClosedRange;D)Z
operator fun ClosedRange<Long>.contains(value: Double): Boolean

// JVM method = longRangeContains(Lkotlin/ranges/ClosedRange;F)Z
operator fun ClosedRange<Long>.contains(value: Float): Boolean

// JVM method = longRangeContains(Lkotlin/ranges/ClosedRange;I)Z
operator fun ClosedRange<Long>.contains(value: Int): Boolean

// JVM method = longRangeContains(Lkotlin/ranges/ClosedRange;S)Z
operator fun ClosedRange<Long>.contains(value: Short): Boolean

// JVM method = shortRangeContains(Lkotlin/ranges/ClosedRange;B)Z
operator fun ClosedRange<Short>.contains(value: Byte): Boolean

// JVM method = shortRangeContains(Lkotlin/ranges/ClosedRange;D)Z
operator fun ClosedRange<Short>.contains(value: Double): Boolean

// JVM method = shortRangeContains(Lkotlin/ranges/ClosedRange;F)Z
operator fun ClosedRange<Short>.contains(value: Float): Boolean

// JVM method = shortRangeContains(Lkotlin/ranges/ClosedRange;I)Z
operator fun ClosedRange<Short>.contains(value: Int): Boolean

// JVM method = shortRangeContains(Lkotlin/ranges/ClosedRange;J)Z
operator fun ClosedRange<Short>.contains(value: Long): Boolean

// JVM method = contains(Lkotlin/ranges/IntRange;B)Z
inline operator fun IntRange.contains(value: Byte): Boolean

// JVM method = contains(Lkotlin/ranges/IntRange;Ljava/lang/Integer;)Z
inline operator fun IntRange.contains(element: Int?): Boolean

// JVM method = contains(Lkotlin/ranges/IntRange;J)Z
inline operator fun IntRange.contains(value: Long): Boolean

// JVM method = contains(Lkotlin/ranges/IntRange;S)Z
inline operator fun IntRange.contains(value: Short): Boolean

// JVM method = contains(Lkotlin/ranges/LongRange;B)Z
inline operator fun LongRange.contains(value: Byte): Boolean

// JVM method = contains(Lkotlin/ranges/LongRange;I)Z
inline operator fun LongRange.contains(value: Int): Boolean

// JVM method = contains(Lkotlin/ranges/LongRange;Ljava/lang/Long;)Z
inline operator fun LongRange.contains(element: Long?): Boolean

// JVM method = contains(Lkotlin/ranges/LongRange;S)Z
inline operator fun LongRange.contains(value: Short): Boolean

// JVM method = byteRangeContains(Lkotlin/ranges/OpenEndRange;I)Z
operator fun OpenEndRange<Byte>.contains(value: Int): Boolean

// JVM method = byteRangeContains(Lkotlin/ranges/OpenEndRange;J)Z
operator fun OpenEndRange<Byte>.contains(value: Long): Boolean

// JVM method = byteRangeContains(Lkotlin/ranges/OpenEndRange;S)Z
operator fun OpenEndRange<Byte>.contains(value: Short): Boolean

// JVM method = doubleRangeContains(Lkotlin/ranges/OpenEndRange;F)Z
operator fun OpenEndRange<Double>.contains(value: Float): Boolean

// JVM method = intRangeContains(Lkotlin/ranges/OpenEndRange;B)Z
operator fun OpenEndRange<Int>.contains(value: Byte): Boolean

// JVM method = intRangeContains(Lkotlin/ranges/OpenEndRange;J)Z
operator fun OpenEndRange<Int>.contains(value: Long): Boolean

// JVM method = intRangeContains(Lkotlin/ranges/OpenEndRange;S)Z
operator fun OpenEndRange<Int>.contains(value: Short): Boolean

// JVM method = longRangeContains(Lkotlin/ranges/OpenEndRange;B)Z
operator fun OpenEndRange<Long>.contains(value: Byte): Boolean

// JVM method = longRangeContains(Lkotlin/ranges/OpenEndRange;I)Z
operator fun OpenEndRange<Long>.contains(value: Int): Boolean

// JVM method = longRangeContains(Lkotlin/ranges/OpenEndRange;S)Z
operator fun OpenEndRange<Long>.contains(value: Short): Boolean

// JVM method = shortRangeContains(Lkotlin/ranges/OpenEndRange;B)Z
operator fun OpenEndRange<Short>.contains(value: Byte): Boolean

// JVM method = shortRangeContains(Lkotlin/ranges/OpenEndRange;I)Z
operator fun OpenEndRange<Short>.contains(value: Int): Boolean

// JVM method = shortRangeContains(Lkotlin/ranges/OpenEndRange;J)Z
operator fun OpenEndRange<Short>.contains(value: Long): Boolean

// JVM method = downTo(BB)Lkotlin/ranges/IntProgression;
infix fun Byte.downTo(to: Byte): IntProgression

// JVM method = downTo(BI)Lkotlin/ranges/IntProgression;
infix fun Byte.downTo(to: Int): IntProgression

// JVM method = downTo(BJ)Lkotlin/ranges/LongProgression;
infix fun Byte.downTo(to: Long): LongProgression

// JVM method = downTo(BS)Lkotlin/ranges/IntProgression;
infix fun Byte.downTo(to: Short): IntProgression

// JVM method = downTo(CC)Lkotlin/ranges/CharProgression;
infix fun Char.downTo(to: Char): CharProgression

// JVM method = downTo(IB)Lkotlin/ranges/IntProgression;
infix fun Int.downTo(to: Byte): IntProgression

// JVM method = downTo(II)Lkotlin/ranges/IntProgression;
infix fun Int.downTo(to: Int): IntProgression

// JVM method = downTo(IJ)Lkotlin/ranges/LongProgression;
infix fun Int.downTo(to: Long): LongProgression

// JVM method = downTo(IS)Lkotlin/ranges/IntProgression;
infix fun Int.downTo(to: Short): IntProgression

// JVM method = downTo(JB)Lkotlin/ranges/LongProgression;
infix fun Long.downTo(to: Byte): LongProgression

// JVM method = downTo(JI)Lkotlin/ranges/LongProgression;
infix fun Long.downTo(to: Int): LongProgression

// JVM method = downTo(JJ)Lkotlin/ranges/LongProgression;
infix fun Long.downTo(to: Long): LongProgression

// JVM method = downTo(JS)Lkotlin/ranges/LongProgression;
infix fun Long.downTo(to: Short): LongProgression

// JVM method = downTo(SB)Lkotlin/ranges/IntProgression;
infix fun Short.downTo(to: Byte): IntProgression

// JVM method = downTo(SI)Lkotlin/ranges/IntProgression;
infix fun Short.downTo(to: Int): IntProgression

// JVM method = downTo(SJ)Lkotlin/ranges/LongProgression;
infix fun Short.downTo(to: Long): LongProgression

// JVM method = downTo(SS)Lkotlin/ranges/IntProgression;
infix fun Short.downTo(to: Short): IntProgression

// JVM method = first(Lkotlin/ranges/CharProgression;)C
fun CharProgression.first(): Char

// JVM method = first(Lkotlin/ranges/IntProgression;)I
fun IntProgression.first(): Int

// JVM method = first(Lkotlin/ranges/LongProgression;)J
fun LongProgression.first(): Long

// JVM method = firstOrNull(Lkotlin/ranges/CharProgression;)Ljava/lang/Character;
fun CharProgression.firstOrNull(): Char?

// JVM method = firstOrNull(Lkotlin/ranges/IntProgression;)Ljava/lang/Integer;
fun IntProgression.firstOrNull(): Int?

// JVM method = firstOrNull(Lkotlin/ranges/LongProgression;)Ljava/lang/Long;
fun LongProgression.firstOrNull(): Long?

// JVM method = last(Lkotlin/ranges/CharProgression;)C
fun CharProgression.last(): Char

// JVM method = last(Lkotlin/ranges/IntProgression;)I
fun IntProgression.last(): Int

// JVM method = last(Lkotlin/ranges/LongProgression;)J
fun LongProgression.last(): Long

// JVM method = lastOrNull(Lkotlin/ranges/CharProgression;)Ljava/lang/Character;
fun CharProgression.lastOrNull(): Char?

// JVM method = lastOrNull(Lkotlin/ranges/IntProgression;)Ljava/lang/Integer;
fun IntProgression.lastOrNull(): Int?

// JVM method = lastOrNull(Lkotlin/ranges/LongProgression;)Ljava/lang/Long;
fun LongProgression.lastOrNull(): Long?

// JVM method = random(Lkotlin/ranges/CharRange;)C
inline fun CharRange.random(): Char

// JVM method = random(Lkotlin/ranges/CharRange;Lkotlin/random/Random;)C
fun CharRange.random(random: kotlin.random.Random): Char

// JVM method = random(Lkotlin/ranges/IntRange;)I
inline fun IntRange.random(): Int

// JVM method = random(Lkotlin/ranges/IntRange;Lkotlin/random/Random;)I
fun IntRange.random(random: kotlin.random.Random): Int

// JVM method = random(Lkotlin/ranges/LongRange;)J
inline fun LongRange.random(): Long

// JVM method = random(Lkotlin/ranges/LongRange;Lkotlin/random/Random;)J
fun LongRange.random(random: kotlin.random.Random): Long

// JVM method = randomOrNull(Lkotlin/ranges/CharRange;)Ljava/lang/Character;
inline fun CharRange.randomOrNull(): Char?

// JVM method = randomOrNull(Lkotlin/ranges/CharRange;Lkotlin/random/Random;)Ljava/lang/Character;
fun CharRange.randomOrNull(random: kotlin.random.Random): Char?

// JVM method = randomOrNull(Lkotlin/ranges/IntRange;)Ljava/lang/Integer;
inline fun IntRange.randomOrNull(): Int?

// JVM method = randomOrNull(Lkotlin/ranges/IntRange;Lkotlin/random/Random;)Ljava/lang/Integer;
fun IntRange.randomOrNull(random: kotlin.random.Random): Int?

// JVM method = randomOrNull(Lkotlin/ranges/LongRange;)Ljava/lang/Long;
inline fun LongRange.randomOrNull(): Long?

// JVM method = randomOrNull(Lkotlin/ranges/LongRange;Lkotlin/random/Random;)Ljava/lang/Long;
fun LongRange.randomOrNull(random: kotlin.random.Random): Long?

// JVM method = reversed(Lkotlin/ranges/CharProgression;)Lkotlin/ranges/CharProgression;
fun CharProgression.reversed(): CharProgression

// JVM method = reversed(Lkotlin/ranges/IntProgression;)Lkotlin/ranges/IntProgression;
fun IntProgression.reversed(): IntProgression

// JVM method = reversed(Lkotlin/ranges/LongProgression;)Lkotlin/ranges/LongProgression;
fun LongProgression.reversed(): LongProgression

// JVM method = step(Lkotlin/ranges/CharProgression;I)Lkotlin/ranges/CharProgression;
infix fun CharProgression.step(step: Int): CharProgression

// JVM method = step(Lkotlin/ranges/IntProgression;I)Lkotlin/ranges/IntProgression;
infix fun IntProgression.step(step: Int): IntProgression

// JVM method = step(Lkotlin/ranges/LongProgression;J)Lkotlin/ranges/LongProgression;
infix fun LongProgression.step(step: Long): LongProgression

// JVM method = toByteExactOrNull(D)Ljava/lang/Byte;
internal fun Double.toByteExactOrNull(): Byte?

// JVM method = toByteExactOrNull(F)Ljava/lang/Byte;
internal fun Float.toByteExactOrNull(): Byte?

// JVM method = toByteExactOrNull(I)Ljava/lang/Byte;
internal fun Int.toByteExactOrNull(): Byte?

// JVM method = toByteExactOrNull(J)Ljava/lang/Byte;
internal fun Long.toByteExactOrNull(): Byte?

// JVM method = toByteExactOrNull(S)Ljava/lang/Byte;
internal fun Short.toByteExactOrNull(): Byte?

// JVM method = toIntExactOrNull(D)Ljava/lang/Integer;
internal fun Double.toIntExactOrNull(): Int?

// JVM method = toIntExactOrNull(F)Ljava/lang/Integer;
internal fun Float.toIntExactOrNull(): Int?

// JVM method = toIntExactOrNull(J)Ljava/lang/Integer;
internal fun Long.toIntExactOrNull(): Int?

// JVM method = toLongExactOrNull(D)Ljava/lang/Long;
internal fun Double.toLongExactOrNull(): Long?

// JVM method = toLongExactOrNull(F)Ljava/lang/Long;
internal fun Float.toLongExactOrNull(): Long?

// JVM method = toShortExactOrNull(D)Ljava/lang/Short;
internal fun Double.toShortExactOrNull(): Short?

// JVM method = toShortExactOrNull(F)Ljava/lang/Short;
internal fun Float.toShortExactOrNull(): Short?

// JVM method = toShortExactOrNull(I)Ljava/lang/Short;
internal fun Int.toShortExactOrNull(): Short?

// JVM method = toShortExactOrNull(J)Ljava/lang/Short;
internal fun Long.toShortExactOrNull(): Short?

// JVM method = until(BB)Lkotlin/ranges/IntRange;
infix fun Byte.until(to: Byte): IntRange

// JVM method = until(BI)Lkotlin/ranges/IntRange;
infix fun Byte.until(to: Int): IntRange

// JVM method = until(BJ)Lkotlin/ranges/LongRange;
infix fun Byte.until(to: Long): LongRange

// JVM method = until(BS)Lkotlin/ranges/IntRange;
infix fun Byte.until(to: Short): IntRange

// JVM method = until(CC)Lkotlin/ranges/CharRange;
infix fun Char.until(to: Char): CharRange

// JVM method = until(IB)Lkotlin/ranges/IntRange;
infix fun Int.until(to: Byte): IntRange

// JVM method = until(II)Lkotlin/ranges/IntRange;
infix fun Int.until(to: Int): IntRange

// JVM method = until(IJ)Lkotlin/ranges/LongRange;
infix fun Int.until(to: Long): LongRange

// JVM method = until(IS)Lkotlin/ranges/IntRange;
infix fun Int.until(to: Short): IntRange

// JVM method = until(JB)Lkotlin/ranges/LongRange;
infix fun Long.until(to: Byte): LongRange

// JVM method = until(JI)Lkotlin/ranges/LongRange;
infix fun Long.until(to: Int): LongRange

// JVM method = until(JJ)Lkotlin/ranges/LongRange;
infix fun Long.until(to: Long): LongRange

// JVM method = until(JS)Lkotlin/ranges/LongRange;
infix fun Long.until(to: Short): LongRange

// JVM method = until(SB)Lkotlin/ranges/IntRange;
infix fun Short.until(to: Byte): IntRange

// JVM method = until(SI)Lkotlin/ranges/IntRange;
infix fun Short.until(to: Int): IntRange

// JVM method = until(SJ)Lkotlin/ranges/LongRange;
infix fun Short.until(to: Long): LongRange

// JVM method = until(SS)Lkotlin/ranges/IntRange;
infix fun Short.until(to: Short): IntRange

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.ranges.URangesKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceAtLeast-Kr8caGY(BB)B
fun UByte.coerceAtLeast(minimumValue: UByte): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceAtLeast-J1ME1BU(II)I
fun UInt.coerceAtLeast(minimumValue: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceAtLeast-eb3DHEI(JJ)J
fun ULong.coerceAtLeast(minimumValue: ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceAtLeast-5PvTz6A(SS)S
fun UShort.coerceAtLeast(minimumValue: UShort): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceAtMost-Kr8caGY(BB)B
fun UByte.coerceAtMost(maximumValue: UByte): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceAtMost-J1ME1BU(II)I
fun UInt.coerceAtMost(maximumValue: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceAtMost-eb3DHEI(JJ)J
fun ULong.coerceAtMost(maximumValue: ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceAtMost-5PvTz6A(SS)S
fun UShort.coerceAtMost(maximumValue: UShort): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceIn-b33U2AM(BBB)B
fun UByte.coerceIn(minimumValue: UByte, maximumValue: UByte): UByte

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceIn-WZ9TVnA(III)I
fun UInt.coerceIn(minimumValue: UInt, maximumValue: UInt): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceIn-wuiCnnA(ILkotlin/ranges/ClosedRange;)I
fun UInt.coerceIn(range: ClosedRange<UInt>): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceIn-sambcqE(JJJ)J
fun ULong.coerceIn(minimumValue: ULong, maximumValue: ULong): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceIn-JPwROB0(JLkotlin/ranges/ClosedRange;)J
fun ULong.coerceIn(range: ClosedRange<ULong>): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = coerceIn-VKSA0NQ(SSS)S
fun UShort.coerceIn(minimumValue: UShort, maximumValue: UShort): UShort

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contains-68kG9v0(Lkotlin/ranges/UIntRange;B)Z
operator fun UIntRange.contains(value: UByte): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contains-biwQdVI(Lkotlin/ranges/UIntRange;Lkotlin/UInt;)Z
inline operator fun UIntRange.contains(element: UInt?): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contains-fz5IDCE(Lkotlin/ranges/UIntRange;J)Z
operator fun UIntRange.contains(value: ULong): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contains-ZsK3CEQ(Lkotlin/ranges/UIntRange;S)Z
operator fun UIntRange.contains(value: UShort): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contains-ULb-yJY(Lkotlin/ranges/ULongRange;B)Z
operator fun ULongRange.contains(value: UByte): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contains-Gab390E(Lkotlin/ranges/ULongRange;I)Z
operator fun ULongRange.contains(value: UInt): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contains-GYNo2lE(Lkotlin/ranges/ULongRange;Lkotlin/ULong;)Z
inline operator fun ULongRange.contains(element: ULong?): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = contains-uhHAxoY(Lkotlin/ranges/ULongRange;S)Z
operator fun ULongRange.contains(value: UShort): Boolean

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = downTo-Kr8caGY(BB)Lkotlin/ranges/UIntProgression;
infix fun UByte.downTo(to: UByte): UIntProgression

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = downTo-J1ME1BU(II)Lkotlin/ranges/UIntProgression;
infix fun UInt.downTo(to: UInt): UIntProgression

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = downTo-eb3DHEI(JJ)Lkotlin/ranges/ULongProgression;
infix fun ULong.downTo(to: ULong): ULongProgression

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = downTo-5PvTz6A(SS)Lkotlin/ranges/UIntProgression;
infix fun UShort.downTo(to: UShort): UIntProgression

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = first(Lkotlin/ranges/UIntProgression;)I
fun UIntProgression.first(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = first(Lkotlin/ranges/ULongProgression;)J
fun ULongProgression.first(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = firstOrNull(Lkotlin/ranges/UIntProgression;)Lkotlin/UInt;
fun UIntProgression.firstOrNull(): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = firstOrNull(Lkotlin/ranges/ULongProgression;)Lkotlin/ULong;
fun ULongProgression.firstOrNull(): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = last(Lkotlin/ranges/UIntProgression;)I
fun UIntProgression.last(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = last(Lkotlin/ranges/ULongProgression;)J
fun ULongProgression.last(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastOrNull(Lkotlin/ranges/UIntProgression;)Lkotlin/UInt;
fun UIntProgression.lastOrNull(): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = lastOrNull(Lkotlin/ranges/ULongProgression;)Lkotlin/ULong;
fun ULongProgression.lastOrNull(): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = random(Lkotlin/ranges/UIntRange;)I
inline fun UIntRange.random(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = random(Lkotlin/ranges/UIntRange;Lkotlin/random/Random;)I
fun UIntRange.random(random: kotlin.random.Random): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = random(Lkotlin/ranges/ULongRange;)J
inline fun ULongRange.random(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = random(Lkotlin/ranges/ULongRange;Lkotlin/random/Random;)J
fun ULongRange.random(random: kotlin.random.Random): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = randomOrNull(Lkotlin/ranges/UIntRange;)Lkotlin/UInt;
inline fun UIntRange.randomOrNull(): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = randomOrNull(Lkotlin/ranges/UIntRange;Lkotlin/random/Random;)Lkotlin/UInt;
fun UIntRange.randomOrNull(random: kotlin.random.Random): UInt?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = randomOrNull(Lkotlin/ranges/ULongRange;)Lkotlin/ULong;
inline fun ULongRange.randomOrNull(): ULong?

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = randomOrNull(Lkotlin/ranges/ULongRange;Lkotlin/random/Random;)Lkotlin/ULong;
fun ULongRange.randomOrNull(random: kotlin.random.Random): ULong?

// JVM method = reversed(Lkotlin/ranges/UIntProgression;)Lkotlin/ranges/UIntProgression;
fun UIntProgression.reversed(): UIntProgression

// JVM method = reversed(Lkotlin/ranges/ULongProgression;)Lkotlin/ranges/ULongProgression;
fun ULongProgression.reversed(): ULongProgression

// JVM method = step(Lkotlin/ranges/UIntProgression;I)Lkotlin/ranges/UIntProgression;
infix fun UIntProgression.step(step: Int): UIntProgression

// JVM method = step(Lkotlin/ranges/ULongProgression;J)Lkotlin/ranges/ULongProgression;
infix fun ULongProgression.step(step: Long): ULongProgression

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = until-Kr8caGY(BB)Lkotlin/ranges/UIntRange;
infix fun UByte.until(to: UByte): UIntRange

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = until-J1ME1BU(II)Lkotlin/ranges/UIntRange;
infix fun UInt.until(to: UInt): UIntRange

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = until-eb3DHEI(JJ)Lkotlin/ranges/ULongRange;
infix fun ULong.until(to: ULong): ULongRange

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = until-5PvTz6A(SS)Lkotlin/ranges/UIntRange;
infix fun UShort.until(to: UShort): UIntRange

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.sequences.SequencesKt


// *** TYPE ALIASES ***

private typealias State = Int


// *** PROPERTIES ***

// JVM field = State_Done:I
private const val State_Done: State /* = Int */

// JVM field = State_Failed:I
private const val State_Failed: State /* = Int */

// JVM field = State_ManyNotReady:I
private const val State_ManyNotReady: State /* = Int */

// JVM field = State_ManyReady:I
private const val State_ManyReady: State /* = Int */

// JVM field = State_NotReady:I
private const val State_NotReady: State /* = Int */

// JVM field = State_Ready:I
private const val State_Ready: State /* = Int */


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = iterator(Lkotlin/jvm/functions/Function2;)Ljava/util/Iterator;
fun <T> iterator(block: suspend SequenceScope<T>.() -> Unit): Iterator<T>

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sequence(Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;
fun <T> sequence(block: suspend SequenceScope<T>.() -> Unit): Sequence<T>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.sequences.SequencesKt


// *** FUNCTIONS ***

// JVM method = asSequence(Ljava/util/Enumeration;)Lkotlin/sequences/Sequence;
inline fun <T> java.util.Enumeration<T>.asSequence(): Sequence<T>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.sequences.SequencesKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = Sequence(Lkotlin/jvm/functions/Function0;)Lkotlin/sequences/Sequence;
inline fun <T> Sequence(crossinline iterator: () -> Iterator<T>): Sequence<T>

// JVM method = emptySequence()Lkotlin/sequences/Sequence;
fun <T> emptySequence(): Sequence<T>

// JVM method = flatMapIndexed(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
internal fun <T, C, R> flatMapIndexed(source: Sequence<T>, transform: (Int, T) -> C, iterator: (C) -> Iterator<R>): Sequence<R>

// JVM method = generateSequence(Lkotlin/jvm/functions/Function0;)Lkotlin/sequences/Sequence;
fun <T : Any> generateSequence(nextFunction: () -> T : Any?): Sequence<T : Any>

// JVM method = generateSequence(Lkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T : Any> generateSequence(seedFunction: () -> T : Any?, nextFunction: (T : Any) -> T : Any?): Sequence<T : Any>

// JVM method = generateSequence(Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T : Any> generateSequence(seed: T : Any?, nextFunction: (T : Any) -> T : Any?): Sequence<T : Any>

// JVM method = sequenceOf([Ljava/lang/Object;)Lkotlin/sequences/Sequence;
fun <T> sequenceOf(vararg elements: T /* Array<out T> */): Sequence<T>

// JVM method = asSequence(Ljava/util/Iterator;)Lkotlin/sequences/Sequence;
fun <T> Iterator<T>.asSequence(): Sequence<T>

// JVM method = constrainOnce(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.constrainOnce(): Sequence<T>

// JVM method = flatten$SequencesKt__SequencesKt(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
private fun <T, R> Sequence<T>.flatten(iterator: (T) -> Iterator<R>): Sequence<R>

// JVM method = flattenSequenceOfIterable(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
fun <T> Sequence<Iterable<T>>.flatten(): Sequence<T>

// JVM method = flatten(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
fun <T> Sequence<Sequence<T>>.flatten(): Sequence<T>

// JVM method = ifEmpty(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function0;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.ifEmpty(defaultValue: () -> Sequence<T>): Sequence<T>

// JVM method = orEmpty(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
inline fun <T> Sequence<T>?.orEmpty(): Sequence<T>

// JVM method = shuffled(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.shuffled(): Sequence<T>

// JVM method = shuffled(Lkotlin/sequences/Sequence;Lkotlin/random/Random;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.shuffled(random: kotlin.random.Random): Sequence<T>

// JVM method = unzip(Lkotlin/sequences/Sequence;)Lkotlin/Pair;
fun <T, R> Sequence<Pair<T, R>>.unzip(): Pair<List<T>, List<R>>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.sequences.SequencesKt


// *** FUNCTIONS ***

// JVM method = filterIsInstance(Lkotlin/sequences/Sequence;Ljava/lang/Class;)Lkotlin/sequences/Sequence;
fun <R> Sequence<*>.filterIsInstance(klass: java.lang.Class<R>): Sequence<R>

// JVM method = filterIsInstanceTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;Ljava/lang/Class;)Ljava/util/Collection;
fun <C : MutableCollection<in R>, R> Sequence<*>.filterIsInstanceTo(destination: C : MutableCollection<in R>, klass: java.lang.Class<R>): C : MutableCollection<in R>

// JVM method = max(Lkotlin/sequences/Sequence;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Sequence<T : Comparable<T>>.max(): T : Comparable<T>?

// JVM method = max(Lkotlin/sequences/Sequence;)Ljava/lang/Double;
fun Sequence<Double>.max(): Double?

// JVM method = max(Lkotlin/sequences/Sequence;)Ljava/lang/Float;
fun Sequence<Float>.max(): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R : Comparable<R>): T?

// JVM method = maxWith(Lkotlin/sequences/Sequence;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Sequence<T>.maxWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T?

// JVM method = min(Lkotlin/sequences/Sequence;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Sequence<T : Comparable<T>>.min(): T : Comparable<T>?

// JVM method = min(Lkotlin/sequences/Sequence;)Ljava/lang/Double;
fun Sequence<Double>.min(): Double?

// JVM method = min(Lkotlin/sequences/Sequence;)Ljava/lang/Float;
fun Sequence<Float>.min(): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R : Comparable<R>): T?

// JVM method = minWith(Lkotlin/sequences/Sequence;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Sequence<T>.minWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigDecimal(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun <T> Sequence<T>.sumOf(selector: (T) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigInteger(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun <T> Sequence<T>.sumOf(selector: (T) -> java.math.BigInteger): java.math.BigInteger

// JVM method = toSortedSet(Lkotlin/sequences/Sequence;)Ljava/util/SortedSet;
fun <T : Comparable<T>> Sequence<T : Comparable<T>>.toSortedSet(): java.util.SortedSet<T : Comparable<T>>

// JVM method = toSortedSet(Lkotlin/sequences/Sequence;Ljava/util/Comparator;)Ljava/util/SortedSet;
fun <T> Sequence<T>.toSortedSet(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): java.util.SortedSet<T>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.sequences.SequencesKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Z
inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean

// JVM method = any(Lkotlin/sequences/Sequence;)Z
fun <T> Sequence<T>.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Z
inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean

// JVM method = asIterable(Lkotlin/sequences/Sequence;)Ljava/lang/Iterable;
fun <T> Sequence<T>.asIterable(): Iterable<T>

// JVM method = asSequence(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
inline fun <T> Sequence<T>.asSequence(): Sequence<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associate(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo(Lkotlin/sequences/Sequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M : MutableMap<in K, in T>, keySelector: (T) -> K): M : MutableMap<in K, in T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo(Lkotlin/sequences/Sequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M : MutableMap<in K, in V>, keySelector: (T) -> K, valueTransform: (T) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateTo(Lkotlin/sequences/Sequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M : MutableMap<in K, in V>, transform: (T) -> Pair<K, V>): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWith(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWithTo(Lkotlin/sequences/Sequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M : MutableMap<in K, in V>, valueSelector: (K) -> V): M : MutableMap<in K, in V>

// JVM method = averageOfByte(Lkotlin/sequences/Sequence;)D
fun Sequence<Byte>.average(): Double

// JVM method = averageOfDouble(Lkotlin/sequences/Sequence;)D
fun Sequence<Double>.average(): Double

// JVM method = averageOfFloat(Lkotlin/sequences/Sequence;)D
fun Sequence<Float>.average(): Double

// JVM method = averageOfInt(Lkotlin/sequences/Sequence;)D
fun Sequence<Int>.average(): Double

// JVM method = averageOfLong(Lkotlin/sequences/Sequence;)D
fun Sequence<Long>.average(): Double

// JVM method = averageOfShort(Lkotlin/sequences/Sequence;)D
fun Sequence<Short>.average(): Double

// JVM method = chunked(Lkotlin/sequences/Sequence;I)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>>

// JVM method = chunked(Lkotlin/sequences/Sequence;ILkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R>

// JVM method = contains(Lkotlin/sequences/Sequence;Ljava/lang/Object;)Z
operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<@kotlin.internal.OnlyInputTypes T>.contains(element: @kotlin.internal.OnlyInputTypes T): Boolean

// JVM method = count(Lkotlin/sequences/Sequence;)I
fun <T> Sequence<T>.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int

// JVM method = distinct(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.distinct(): Sequence<T>

// JVM method = distinctBy(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T>

// JVM method = drop(Lkotlin/sequences/Sequence;I)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.drop(n: Int): Sequence<T>

// JVM method = dropWhile(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T>

// JVM method = elementAt(Lkotlin/sequences/Sequence;I)Ljava/lang/Object;
fun <T> Sequence<T>.elementAt(index: Int): T

// JVM method = elementAtOrElse(Lkotlin/sequences/Sequence;ILkotlin/jvm/functions/Function1;)Ljava/lang/Object;
fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T

// JVM method = elementAtOrNull(Lkotlin/sequences/Sequence;I)Ljava/lang/Object;
fun <T> Sequence<T>.elementAtOrNull(index: Int): T?

// JVM method = filter(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T>

// JVM method = filterIndexed(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.filterIndexed(predicate: (@ParameterName(name = "index") Int, T) -> Boolean): Sequence<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexedTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C : MutableCollection<in T>, predicate: (@ParameterName(name = "index") Int, T) -> Boolean): C : MutableCollection<in T>

// JVM method = filterIsInstance(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer reified R>

// JVM method = filterIsInstanceTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;)Ljava/util/Collection;
inline fun <reified R, C : MutableCollection<in reified R>> Sequence<*>.filterIsInstanceTo(destination: C : MutableCollection<in reified R>): C : MutableCollection<in reified R>

// JVM method = filterNot(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T>

// JVM method = filterNotNull(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
fun <T : Any> Sequence<T : Any?>.filterNotNull(): Sequence<T : Any>

// JVM method = filterNotNullTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;)Ljava/util/Collection;
fun <C : MutableCollection<in T : Any>, T : Any> Sequence<T : Any?>.filterNotNullTo(destination: C : MutableCollection<in T : Any>): C : MutableCollection<in T : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C : MutableCollection<in T>, predicate: (T) -> Boolean): C : MutableCollection<in T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C : MutableCollection<in T>, predicate: (T) -> Boolean): C : MutableCollection<in T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = find(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T?

// JVM method = first(Lkotlin/sequences/Sequence;)Ljava/lang/Object;
fun <T> Sequence<T>.first(): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = first(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstNotNullOf(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Any> Sequence<T>.firstNotNullOf(transform: (T) -> R : Any?): R : Any

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstNotNullOfOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Any> Sequence<T>.firstNotNullOfOrNull(transform: (T) -> R : Any?): R : Any?

// JVM method = firstOrNull(Lkotlin/sequences/Sequence;)Ljava/lang/Object;
fun <T> Sequence<T>.firstOrNull(): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T?

// JVM method = flatMapIterable(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R>

// JVM method = flatMap(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R>

// JVM method = flatMapIndexedIterable(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.flatMapIndexed(transform: (@ParameterName(name = "index") Int, T) -> Iterable<R>): Sequence<R>

// JVM method = flatMapIndexedSequence(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.flatMapIndexed(transform: (@ParameterName(name = "index") Int, T) -> Sequence<R>): Sequence<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterableTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, T) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedSequenceTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, T) -> Sequence<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIterableTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C : MutableCollection<in R>, transform: (T) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C : MutableCollection<in R>, transform: (T) -> Sequence<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold(Lkotlin/sequences/Sequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <T, R> Sequence<T>.fold(initial: R, operation: (@ParameterName(name = "acc") R, T) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldIndexed(Lkotlin/sequences/Sequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, T) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)V
inline fun <T> Sequence<T>.forEach(action: (T) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachIndexed(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)V
inline fun <T> Sequence<T>.forEachIndexed(action: (@ParameterName(name = "index") Int, T) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo(Lkotlin/sequences/Sequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M : MutableMap<in K, MutableList<T>>, keySelector: (T) -> K): M : MutableMap<in K, MutableList<T>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo(Lkotlin/sequences/Sequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (T) -> K, valueTransform: (T) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupingBy(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/collections/Grouping;
inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K>

// JVM method = indexOf(Lkotlin/sequences/Sequence;Ljava/lang/Object;)I
fun <@kotlin.internal.OnlyInputTypes T> Sequence<@kotlin.internal.OnlyInputTypes T>.indexOf(element: @kotlin.internal.OnlyInputTypes T): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int

// JVM method = joinTo(Lkotlin/sequences/Sequence;Ljava/lang/Appendable;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
fun <T, A : Appendable /* = java.lang.Appendable */> Sequence<T>.joinTo(buffer: A : Appendable /* = java.lang.Appendable */, separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((T) -> CharSequence)? /* = default */): A : Appendable /* = java.lang.Appendable */

// JVM method = joinToString(Lkotlin/sequences/Sequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;ILjava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
fun <T> Sequence<T>.joinToString(separator: CharSequence /* = default */, prefix: CharSequence /* = default */, postfix: CharSequence /* = default */, limit: Int /* = default */, truncated: CharSequence /* = default */, transform: ((T) -> CharSequence)? /* = default */): String

// JVM method = last(Lkotlin/sequences/Sequence;)Ljava/lang/Object;
fun <T> Sequence<T>.last(): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T

// JVM method = lastIndexOf(Lkotlin/sequences/Sequence;Ljava/lang/Object;)I
fun <@kotlin.internal.OnlyInputTypes T> Sequence<@kotlin.internal.OnlyInputTypes T>.lastIndexOf(element: @kotlin.internal.OnlyInputTypes T): Int

// JVM method = lastOrNull(Lkotlin/sequences/Sequence;)Ljava/lang/Object;
fun <T> Sequence<T>.lastOrNull(): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T?

// JVM method = map(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R>

// JVM method = mapIndexed(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.mapIndexed(transform: (@ParameterName(name = "index") Int, T) -> R): Sequence<R>

// JVM method = mapIndexedNotNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;
fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (@ParameterName(name = "index") Int, T) -> R : Any?): Sequence<R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedNotNullTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, R : Any, C : MutableCollection<in R : Any>> Sequence<T>.mapIndexedNotNullTo(destination: C : MutableCollection<in R : Any>, transform: (@ParameterName(name = "index") Int, T) -> R : Any?): C : MutableCollection<in R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, T) -> R): C : MutableCollection<in R>

// JVM method = mapNotNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R : Any?): Sequence<R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapNotNullTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, R : Any, C : MutableCollection<in R : Any>> Sequence<T>.mapNotNullTo(destination: C : MutableCollection<in R : Any>, transform: (T) -> R : Any?): C : MutableCollection<in R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo(Lkotlin/sequences/Sequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C : MutableCollection<in R>, transform: (T) -> R): C : MutableCollection<in R>

// JVM method = maxOrThrow(Lkotlin/sequences/Sequence;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Sequence<T : Comparable<T>>.max(): T : Comparable<T>

// JVM method = maxOrThrow(Lkotlin/sequences/Sequence;)D
fun Sequence<Double>.max(): Double

// JVM method = maxOrThrow(Lkotlin/sequences/Sequence;)F
fun Sequence<Float>.max(): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R : Comparable<R>): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R : Comparable<R>): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)D
inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)F
inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith(Lkotlin/sequences/Sequence;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (T) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull(Lkotlin/sequences/Sequence;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (T) -> R): R?

// JVM method = maxOrNull(Lkotlin/sequences/Sequence;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Sequence<T : Comparable<T>>.maxOrNull(): T : Comparable<T>?

// JVM method = maxOrNull(Lkotlin/sequences/Sequence;)Ljava/lang/Double;
fun Sequence<Double>.maxOrNull(): Double?

// JVM method = maxOrNull(Lkotlin/sequences/Sequence;)Ljava/lang/Float;
fun Sequence<Float>.maxOrNull(): Float?

// JVM method = maxWithOrThrow(Lkotlin/sequences/Sequence;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Sequence<T>.maxWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T

// JVM method = maxWithOrNull(Lkotlin/sequences/Sequence;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T?

// JVM method = minOrThrow(Lkotlin/sequences/Sequence;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Sequence<T : Comparable<T>>.min(): T : Comparable<T>

// JVM method = minOrThrow(Lkotlin/sequences/Sequence;)D
fun Sequence<Double>.min(): Double

// JVM method = minOrThrow(Lkotlin/sequences/Sequence;)F
fun Sequence<Float>.min(): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R : Comparable<R>): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R : Comparable<R>): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)D
inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)F
inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith(Lkotlin/sequences/Sequence;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (T) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull(Lkotlin/sequences/Sequence;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (T) -> R): R?

// JVM method = minOrNull(Lkotlin/sequences/Sequence;)Ljava/lang/Comparable;
fun <T : Comparable<T>> Sequence<T : Comparable<T>>.minOrNull(): T : Comparable<T>?

// JVM method = minOrNull(Lkotlin/sequences/Sequence;)Ljava/lang/Double;
fun Sequence<Double>.minOrNull(): Double?

// JVM method = minOrNull(Lkotlin/sequences/Sequence;)Ljava/lang/Float;
fun Sequence<Float>.minOrNull(): Float?

// JVM method = minWithOrThrow(Lkotlin/sequences/Sequence;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Sequence<T>.minWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T

// JVM method = minWithOrNull(Lkotlin/sequences/Sequence;Ljava/util/Comparator;)Ljava/lang/Object;
fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): T?

// JVM method = minus(Lkotlin/sequences/Sequence;Ljava/lang/Object;)Lkotlin/sequences/Sequence;
operator fun <T> Sequence<T>.minus(element: T): Sequence<T>

// JVM method = minus(Lkotlin/sequences/Sequence;[Ljava/lang/Object;)Lkotlin/sequences/Sequence;
operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T>

// JVM method = minus(Lkotlin/sequences/Sequence;Ljava/lang/Iterable;)Lkotlin/sequences/Sequence;
operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T>

// JVM method = minus(Lkotlin/sequences/Sequence;Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T>

// JVM method = minusElement(Lkotlin/sequences/Sequence;Ljava/lang/Object;)Lkotlin/sequences/Sequence;
inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T>

// JVM method = none(Lkotlin/sequences/Sequence;)Z
fun <T> Sequence<T>.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Z
inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean

// JVM method = onEach(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T>

// JVM method = onEachIndexed(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.onEachIndexed(action: (@ParameterName(name = "index") Int, T) -> Unit): Sequence<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>>

// JVM method = plus(Lkotlin/sequences/Sequence;Ljava/lang/Object;)Lkotlin/sequences/Sequence;
operator fun <T> Sequence<T>.plus(element: T): Sequence<T>

// JVM method = plus(Lkotlin/sequences/Sequence;[Ljava/lang/Object;)Lkotlin/sequences/Sequence;
operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T>

// JVM method = plus(Lkotlin/sequences/Sequence;Ljava/lang/Iterable;)Lkotlin/sequences/Sequence;
operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T>

// JVM method = plus(Lkotlin/sequences/Sequence;Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T>

// JVM method = plusElement(Lkotlin/sequences/Sequence;Ljava/lang/Object;)Lkotlin/sequences/Sequence;
inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <S, T : S> Sequence<T : S>.reduce(operation: (@ParameterName(name = "acc") S, T : S) -> S): S

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexed(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <S, T : S> Sequence<T : S>.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") S, T : S) -> S): S

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexedOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <S, T : S> Sequence<T : S>.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") S, T : S) -> S): S?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <S, T : S> Sequence<T : S>.reduceOrNull(operation: (@ParameterName(name = "acc") S, T : S) -> S): S?

// JVM method = requireNoNulls(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
fun <T : Any> Sequence<T : Any?>.requireNoNulls(): Sequence<T : Any>

// JVM method = runningFold(Lkotlin/sequences/Sequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, T) -> R): Sequence<R>

// JVM method = runningFoldIndexed(Lkotlin/sequences/Sequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, T) -> R): Sequence<R>

// JVM method = runningReduce(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;
fun <S, T : S> Sequence<T : S>.runningReduce(operation: (@ParameterName(name = "acc") S, T : S) -> S): Sequence<S>

// JVM method = runningReduceIndexed(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function3;)Lkotlin/sequences/Sequence;
fun <S, T : S> Sequence<T : S>.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") S, T : S) -> S): Sequence<S>

// JVM method = scan(Lkotlin/sequences/Sequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.scan(initial: R, operation: (@ParameterName(name = "acc") R, T) -> R): Sequence<R>

// JVM method = scanIndexed(Lkotlin/sequences/Sequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, T) -> R): Sequence<R>

// JVM method = single(Lkotlin/sequences/Sequence;)Ljava/lang/Object;
fun <T> Sequence<T>.single(): T

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = single(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T

// JVM method = singleOrNull(Lkotlin/sequences/Sequence;)Ljava/lang/Object;
fun <T> Sequence<T>.singleOrNull(): T?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = singleOrNull(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T?

// JVM method = sorted(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
fun <T : Comparable<T>> Sequence<T : Comparable<T>>.sorted(): Sequence<T : Comparable<T>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedBy(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R : Comparable<R>?): Sequence<T>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sortedByDescending(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R : Comparable<R>?): Sequence<T>

// JVM method = sortedDescending(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
fun <T : Comparable<T>> Sequence<T : Comparable<T>>.sortedDescending(): Sequence<T : Comparable<T>>

// JVM method = sortedWith(Lkotlin/sequences/Sequence;Ljava/util/Comparator;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T> /* = java.util.Comparator<in T> */): Sequence<T>

// JVM method = sumOfByte(Lkotlin/sequences/Sequence;)I
fun Sequence<Byte>.sum(): Int

// JVM method = sumOfDouble(Lkotlin/sequences/Sequence;)D
fun Sequence<Double>.sum(): Double

// JVM method = sumOfFloat(Lkotlin/sequences/Sequence;)F
fun Sequence<Float>.sum(): Float

// JVM method = sumOfInt(Lkotlin/sequences/Sequence;)I
fun Sequence<Int>.sum(): Int

// JVM method = sumOfLong(Lkotlin/sequences/Sequence;)J
fun Sequence<Long>.sum(): Long

// JVM method = sumOfShort(Lkotlin/sequences/Sequence;)I
fun Sequence<Short>.sum(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumBy(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumByDouble(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)D
inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfDouble(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)D
inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfInt(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfLong(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)J
inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)I
inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)J
inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong

// JVM method = take(Lkotlin/sequences/Sequence;I)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.take(n: Int): Sequence<T>

// JVM method = takeWhile(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T>

// JVM method = toCollection(Lkotlin/sequences/Sequence;Ljava/util/Collection;)Ljava/util/Collection;
fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C : MutableCollection<in T>): C : MutableCollection<in T>

// JVM method = toHashSet(Lkotlin/sequences/Sequence;)Ljava/util/HashSet;
fun <T> Sequence<T>.toHashSet(): HashSet<T> /* = java.util.HashSet<T> */

// JVM method = toList(Lkotlin/sequences/Sequence;)Ljava/util/List;
fun <T> Sequence<T>.toList(): List<T>

// JVM method = toMutableList(Lkotlin/sequences/Sequence;)Ljava/util/List;
fun <T> Sequence<T>.toMutableList(): MutableList<T>

// JVM method = toMutableSet(Lkotlin/sequences/Sequence;)Ljava/util/Set;
fun <T> Sequence<T>.toMutableSet(): MutableSet<T>

// JVM method = toSet(Lkotlin/sequences/Sequence;)Ljava/util/Set;
fun <T> Sequence<T>.toSet(): Set<T>

// JVM method = windowed(Lkotlin/sequences/Sequence;IIZ)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.windowed(size: Int, step: Int /* = default */, partialWindows: Boolean /* = default */): Sequence<List<T>>

// JVM method = windowed(Lkotlin/sequences/Sequence;IIZLkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.windowed(size: Int, step: Int /* = default */, partialWindows: Boolean /* = default */, transform: (List<T>) -> R): Sequence<R>

// JVM method = withIndex(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>>

// JVM method = zip(Lkotlin/sequences/Sequence;Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>>

// JVM method = zip(Lkotlin/sequences/Sequence;Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;
fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (@ParameterName(name = "a") T, @ParameterName(name = "b") R) -> V): Sequence<V>

// JVM method = zipWithNext(Lkotlin/sequences/Sequence;)Lkotlin/sequences/Sequence;
fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>>

// JVM method = zipWithNext(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function2;)Lkotlin/sequences/Sequence;
fun <T, R> Sequence<T>.zipWithNext(transform: (@ParameterName(name = "a") T, @ParameterName(name = "b") T) -> R): Sequence<R>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.sequences.USequencesKt


// *** FUNCTIONS ***

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUByte(Lkotlin/sequences/Sequence;)I
fun Sequence<UByte>.sum(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt(Lkotlin/sequences/Sequence;)I
fun Sequence<UInt>.sum(): UInt

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong(Lkotlin/sequences/Sequence;)J
fun Sequence<ULong>.sum(): ULong

// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUShort(Lkotlin/sequences/Sequence;)I
fun Sequence<UShort>.sum(): UInt

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.CharsKt


// *** PROPERTIES ***

val Char.category: CharCategory
	// JVM method = getCategory(C)Lkotlin/text/CharCategory;
	get() = /* non-default */

val Char.directionality: CharDirectionality
	// JVM method = getDirectionality(C)Lkotlin/text/CharDirectionality;
	get() = /* non-default */


// *** FUNCTIONS ***

// JVM method = checkRadix(I)I
internal fun checkRadix(radix: Int): Int

// JVM method = digitOf(CI)I
internal fun digitOf(char: Char, radix: Int): Int

// JVM method = isDefined(C)Z
inline fun Char.isDefined(): Boolean

// JVM method = isDigit(C)Z
inline fun Char.isDigit(): Boolean

// JVM method = isHighSurrogate(C)Z
inline fun Char.isHighSurrogate(): Boolean

// JVM method = isISOControl(C)Z
inline fun Char.isISOControl(): Boolean

// JVM method = isIdentifierIgnorable(C)Z
inline fun Char.isIdentifierIgnorable(): Boolean

// JVM method = isJavaIdentifierPart(C)Z
inline fun Char.isJavaIdentifierPart(): Boolean

// JVM method = isJavaIdentifierStart(C)Z
inline fun Char.isJavaIdentifierStart(): Boolean

// JVM method = isLetter(C)Z
inline fun Char.isLetter(): Boolean

// JVM method = isLetterOrDigit(C)Z
inline fun Char.isLetterOrDigit(): Boolean

// JVM method = isLowSurrogate(C)Z
inline fun Char.isLowSurrogate(): Boolean

// JVM method = isLowerCase(C)Z
inline fun Char.isLowerCase(): Boolean

// JVM method = isTitleCase(C)Z
inline fun Char.isTitleCase(): Boolean

// JVM method = isUpperCase(C)Z
inline fun Char.isUpperCase(): Boolean

// JVM method = isWhitespace(C)Z
fun Char.isWhitespace(): Boolean

// JVM method = lowercase(C)Ljava/lang/String;
inline fun Char.lowercase(): String

// JVM method = lowercase(CLjava/util/Locale;)Ljava/lang/String;
fun Char.lowercase(locale: java.util.Locale): String

// JVM method = lowercaseChar(C)C
inline fun Char.lowercaseChar(): Char

// JVM method = titlecase(CLjava/util/Locale;)Ljava/lang/String;
fun Char.titlecase(locale: java.util.Locale): String

// JVM method = titlecaseChar(C)C
inline fun Char.titlecaseChar(): Char

// JVM method = toLowerCase(C)C
inline fun Char.toLowerCase(): Char

// JVM method = toTitleCase(C)C
inline fun Char.toTitleCase(): Char

// JVM method = toUpperCase(C)C
inline fun Char.toUpperCase(): Char

// JVM method = uppercase(C)Ljava/lang/String;
inline fun Char.uppercase(): String

// JVM method = uppercase(CLjava/util/Locale;)Ljava/lang/String;
fun Char.uppercase(locale: java.util.Locale): String

// JVM method = uppercaseChar(C)C
inline fun Char.uppercaseChar(): Char

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.CharsKt


// *** FUNCTIONS ***

// JVM method = digitToChar(I)C
fun Int.digitToChar(): Char

// JVM method = digitToChar(II)C
fun Int.digitToChar(radix: Int): Char

// JVM method = digitToInt(C)I
fun Char.digitToInt(): Int

// JVM method = digitToInt(CI)I
fun Char.digitToInt(radix: Int): Int

// JVM method = digitToIntOrNull(C)Ljava/lang/Integer;
fun Char.digitToIntOrNull(): Int?

// JVM method = digitToIntOrNull(CI)Ljava/lang/Integer;
fun Char.digitToIntOrNull(radix: Int): Int?

// JVM method = equals(CCZ)Z
fun Char.equals(other: Char, ignoreCase: Boolean /* = default */): Boolean

// JVM method = isSurrogate(C)Z
fun Char.isSurrogate(): Boolean

// JVM method = plus(CLjava/lang/String;)Ljava/lang/String;
inline operator fun Char.plus(other: String): String

// JVM method = titlecase(C)Ljava/lang/String;
fun Char.titlecase(): String

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.StringsKt


// *** FUNCTIONS ***

// JVM method = append(Ljava/lang/Appendable;[Ljava/lang/CharSequence;)Ljava/lang/Appendable;
fun <T : Appendable /* = java.lang.Appendable */> T : Appendable /* = java.lang.Appendable */.append(vararg value: CharSequence? /* Array<out CharSequence?> */): T : Appendable /* = java.lang.Appendable */

// JVM method = appendElement(Ljava/lang/Appendable;Ljava/lang/Object;Lkotlin/jvm/functions/Function1;)V
internal fun <T> Appendable /* = java.lang.Appendable */.appendElement(element: T, transform: ((T) -> CharSequence)?)

// JVM method = appendLine(Ljava/lang/Appendable;)Ljava/lang/Appendable;
inline fun Appendable /* = java.lang.Appendable */.appendLine(): Appendable /* = java.lang.Appendable */

// JVM method = appendLine(Ljava/lang/Appendable;C)Ljava/lang/Appendable;
inline fun Appendable /* = java.lang.Appendable */.appendLine(value: Char): Appendable /* = java.lang.Appendable */

// JVM method = appendLine(Ljava/lang/Appendable;Ljava/lang/CharSequence;)Ljava/lang/Appendable;
inline fun Appendable /* = java.lang.Appendable */.appendLine(value: CharSequence?): Appendable /* = java.lang.Appendable */

// JVM method = appendRange(Ljava/lang/Appendable;Ljava/lang/CharSequence;II)Ljava/lang/Appendable;
fun <T : Appendable /* = java.lang.Appendable */> T : Appendable /* = java.lang.Appendable */.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): T : Appendable /* = java.lang.Appendable */

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.StringsKt


// *** FUNCTIONS ***

// JVM method = getIndentFunction$StringsKt__IndentKt(Ljava/lang/String;)Lkotlin/jvm/functions/Function1;
private fun getIndentFunction(indent: String): (String) -> String

// JVM method = indentWidth$StringsKt__IndentKt(Ljava/lang/String;)I
private fun String.indentWidth(): Int

// JVM method = prependIndent(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.prependIndent(indent: String /* = default */): String

// JVM method = reindent$StringsKt__IndentKt(Ljava/util/List;ILkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
private inline fun List<String>.reindent(resultSizeEstimate: Int, indentAddFunction: (String) -> String, indentCutFunction: (String) -> String?): String

// JVM method = replaceIndent(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.replaceIndent(newIndent: String /* = default */): String

// JVM method = replaceIndentByMargin(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.replaceIndentByMargin(newIndent: String /* = default */, marginPrefix: String /* = default */): String

// JVM method = trimIndent(Ljava/lang/String;)Ljava/lang/String;
fun String.trimIndent(): String

// JVM method = trimMargin(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.trimMargin(marginPrefix: String /* = default */): String

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.StringsKt


// *** FUNCTIONS ***

// JVM method = toRegex(Ljava/util/regex/Pattern;)Lkotlin/text/Regex;
inline fun java.util.regex.Pattern.toRegex(): Regex

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.StringsKt


// *** FUNCTIONS ***

// JVM method = toRegex(Ljava/lang/String;)Lkotlin/text/Regex;
inline fun String.toRegex(): Regex

// JVM method = toRegex(Ljava/lang/String;Ljava/util/Set;)Lkotlin/text/Regex;
inline fun String.toRegex(options: Set<RegexOption>): Regex

// JVM method = toRegex(Ljava/lang/String;Lkotlin/text/RegexOption;)Lkotlin/text/Regex;
inline fun String.toRegex(option: RegexOption): Regex

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.StringsKt


// *** FUNCTIONS ***

// JVM method = appendLine(Ljava/lang/StringBuilder;Ljava/lang/StringBuffer;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: java.lang.StringBuffer?): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;B)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: Byte): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;D)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: Double): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;F)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: Float): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;I)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: Int): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;J)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: Long): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;S)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: Short): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;Ljava/lang/StringBuilder;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: StringBuilder? /* = java.lang.StringBuilder? */): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendRange(Ljava/lang/StringBuilder;[CII)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendRange(Ljava/lang/StringBuilder;Ljava/lang/CharSequence;II)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/Appendable;)Ljava/lang/Appendable;
fun Appendable /* = java.lang.Appendable */.appendln(): Appendable /* = java.lang.Appendable */

// JVM method = appendln(Ljava/lang/Appendable;C)Ljava/lang/Appendable;
inline fun Appendable /* = java.lang.Appendable */.appendln(value: Char): Appendable /* = java.lang.Appendable */

// JVM method = appendln(Ljava/lang/Appendable;Ljava/lang/CharSequence;)Ljava/lang/Appendable;
inline fun Appendable /* = java.lang.Appendable */.appendln(value: CharSequence?): Appendable /* = java.lang.Appendable */

// JVM method = appendln(Ljava/lang/StringBuilder;)Ljava/lang/StringBuilder;
fun StringBuilder /* = java.lang.StringBuilder */.appendln(): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;Ljava/lang/StringBuffer;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: java.lang.StringBuffer?): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;Ljava/lang/Object;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: Any?): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;Z)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: Boolean): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;B)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: Byte): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;C)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: Char): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;[C)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: CharArray): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;Ljava/lang/CharSequence;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: CharSequence?): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;D)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: Double): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;F)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: Float): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;I)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: Int): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;J)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: Long): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;S)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: Short): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;Ljava/lang/String;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: String?): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendln(Ljava/lang/StringBuilder;Ljava/lang/StringBuilder;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendln(value: StringBuilder? /* = java.lang.StringBuilder? */): StringBuilder /* = java.lang.StringBuilder */

// JVM method = clear(Ljava/lang/StringBuilder;)Ljava/lang/StringBuilder;
fun StringBuilder /* = java.lang.StringBuilder */.clear(): StringBuilder /* = java.lang.StringBuilder */

// JVM method = deleteAt(Ljava/lang/StringBuilder;I)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.deleteAt(index: Int): StringBuilder /* = java.lang.StringBuilder */

// JVM method = deleteRange(Ljava/lang/StringBuilder;II)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.deleteRange(startIndex: Int, endIndex: Int): StringBuilder /* = java.lang.StringBuilder */

// JVM method = insertRange(Ljava/lang/StringBuilder;I[CII)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder /* = java.lang.StringBuilder */

// JVM method = insertRange(Ljava/lang/StringBuilder;ILjava/lang/CharSequence;II)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder /* = java.lang.StringBuilder */

// JVM method = set(Ljava/lang/StringBuilder;IC)V
inline operator fun StringBuilder /* = java.lang.StringBuilder */.set(index: Int, value: Char)

// JVM method = setRange(Ljava/lang/StringBuilder;IILjava/lang/String;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder /* = java.lang.StringBuilder */

// JVM method = toCharArray(Ljava/lang/StringBuilder;[CIII)V
inline fun StringBuilder /* = java.lang.StringBuilder */.toCharArray(destination: CharArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */)

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.StringsKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildString(ILkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun buildString(capacity: Int, builderAction: StringBuilder /* = java.lang.StringBuilder */.() -> Unit): String {
	contract {
		callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE)
	}
}

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = buildString(Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun buildString(builderAction: StringBuilder /* = java.lang.StringBuilder */.() -> Unit): String {
	contract {
		callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE)
	}
}

// JVM method = append(Ljava/lang/StringBuilder;Ljava/lang/Object;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.append(obj: Any?): StringBuilder /* = java.lang.StringBuilder */

// JVM method = append(Ljava/lang/StringBuilder;[Ljava/lang/Object;)Ljava/lang/StringBuilder;
fun StringBuilder /* = java.lang.StringBuilder */.append(vararg value: Any? /* Array<out Any?> */): StringBuilder /* = java.lang.StringBuilder */

// JVM method = append(Ljava/lang/StringBuilder;[Ljava/lang/String;)Ljava/lang/StringBuilder;
fun StringBuilder /* = java.lang.StringBuilder */.append(vararg value: String? /* Array<out String?> */): StringBuilder /* = java.lang.StringBuilder */

// JVM method = append(Ljava/lang/StringBuilder;[CII)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.append(str: CharArray, offset: Int, len: Int): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;Ljava/lang/Object;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: Any?): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;Z)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: Boolean): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;C)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: Char): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;[C)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: CharArray): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;Ljava/lang/CharSequence;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: CharSequence?): StringBuilder /* = java.lang.StringBuilder */

// JVM method = appendLine(Ljava/lang/StringBuilder;Ljava/lang/String;)Ljava/lang/StringBuilder;
inline fun StringBuilder /* = java.lang.StringBuilder */.appendLine(value: String?): StringBuilder /* = java.lang.StringBuilder */

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.StringsKt


// *** FUNCTIONS ***

// JVM method = screenFloatValue$StringsKt__StringNumberConversionsJVMKt(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
private inline fun <T> screenFloatValue(str: String, parse: (String) -> T): T?

// JVM method = toBigDecimal(Ljava/lang/String;)Ljava/math/BigDecimal;
inline fun String.toBigDecimal(): java.math.BigDecimal

// JVM method = toBigDecimal(Ljava/lang/String;Ljava/math/MathContext;)Ljava/math/BigDecimal;
inline fun String.toBigDecimal(mathContext: java.math.MathContext): java.math.BigDecimal

// JVM method = toBigDecimalOrNull(Ljava/lang/String;)Ljava/math/BigDecimal;
fun String.toBigDecimalOrNull(): java.math.BigDecimal?

// JVM method = toBigDecimalOrNull(Ljava/lang/String;Ljava/math/MathContext;)Ljava/math/BigDecimal;
fun String.toBigDecimalOrNull(mathContext: java.math.MathContext): java.math.BigDecimal?

// JVM method = toBigInteger(Ljava/lang/String;)Ljava/math/BigInteger;
inline fun String.toBigInteger(): java.math.BigInteger

// JVM method = toBigInteger(Ljava/lang/String;I)Ljava/math/BigInteger;
inline fun String.toBigInteger(radix: Int): java.math.BigInteger

// JVM method = toBigIntegerOrNull(Ljava/lang/String;)Ljava/math/BigInteger;
fun String.toBigIntegerOrNull(): java.math.BigInteger?

// JVM method = toBigIntegerOrNull(Ljava/lang/String;I)Ljava/math/BigInteger;
fun String.toBigIntegerOrNull(radix: Int): java.math.BigInteger?

// JVM method = toBoolean(Ljava/lang/String;)Z
inline fun String.toBoolean(): Boolean

// JVM method = toBooleanNullable(Ljava/lang/String;)Z
inline fun String?.toBoolean(): Boolean

// JVM method = toByte(Ljava/lang/String;)B
inline fun String.toByte(): Byte

// JVM method = toByte(Ljava/lang/String;I)B
inline fun String.toByte(radix: Int): Byte

// JVM method = toDouble(Ljava/lang/String;)D
inline fun String.toDouble(): Double

// JVM method = toDoubleOrNull(Ljava/lang/String;)Ljava/lang/Double;
fun String.toDoubleOrNull(): Double?

// JVM method = toFloat(Ljava/lang/String;)F
inline fun String.toFloat(): Float

// JVM method = toFloatOrNull(Ljava/lang/String;)Ljava/lang/Float;
fun String.toFloatOrNull(): Float?

// JVM method = toInt(Ljava/lang/String;)I
inline fun String.toInt(): Int

// JVM method = toInt(Ljava/lang/String;I)I
inline fun String.toInt(radix: Int): Int

// JVM method = toLong(Ljava/lang/String;)J
inline fun String.toLong(): Long

// JVM method = toLong(Ljava/lang/String;I)J
inline fun String.toLong(radix: Int): Long

// JVM method = toShort(Ljava/lang/String;)S
inline fun String.toShort(): Short

// JVM method = toShort(Ljava/lang/String;I)S
inline fun String.toShort(radix: Int): Short

// JVM method = toString(BI)Ljava/lang/String;
inline fun Byte.toString(radix: Int): String

// JVM method = toString(II)Ljava/lang/String;
inline fun Int.toString(radix: Int): String

// JVM method = toString(JI)Ljava/lang/String;
inline fun Long.toString(radix: Int): String

// JVM method = toString(SI)Ljava/lang/String;
inline fun Short.toString(radix: Int): String

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.StringsKt


// *** FUNCTIONS ***

// JVM method = numberFormatError(Ljava/lang/String;)Ljava/lang/Void;
internal fun numberFormatError(input: String): Nothing

// JVM method = toByteOrNull(Ljava/lang/String;)Ljava/lang/Byte;
fun String.toByteOrNull(): Byte?

// JVM method = toByteOrNull(Ljava/lang/String;I)Ljava/lang/Byte;
fun String.toByteOrNull(radix: Int): Byte?

// JVM method = toIntOrNull(Ljava/lang/String;)Ljava/lang/Integer;
fun String.toIntOrNull(): Int?

// JVM method = toIntOrNull(Ljava/lang/String;I)Ljava/lang/Integer;
fun String.toIntOrNull(radix: Int): Int?

// JVM method = toLongOrNull(Ljava/lang/String;)Ljava/lang/Long;
fun String.toLongOrNull(): Long?

// JVM method = toLongOrNull(Ljava/lang/String;I)Ljava/lang/Long;
fun String.toLongOrNull(radix: Int): Long?

// JVM method = toShortOrNull(Ljava/lang/String;)Ljava/lang/Short;
fun String.toShortOrNull(): Short?

// JVM method = toShortOrNull(Ljava/lang/String;I)Ljava/lang/Short;
fun String.toShortOrNull(radix: Int): Short?

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.StringsKt


// *** PROPERTIES ***

val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String> /* = java.util.Comparator<String> */
	// JVM method = getCASE_INSENSITIVE_ORDER(Lkotlin/jvm/internal/StringCompanionObject;)Ljava/util/Comparator;
	get() = /* non-default */


// *** FUNCTIONS ***

// JVM method = String(Ljava/lang/StringBuffer;)Ljava/lang/String;
inline fun String(stringBuffer: java.lang.StringBuffer): String

// JVM method = String(Ljava/lang/StringBuilder;)Ljava/lang/String;
inline fun String(stringBuilder: java.lang.StringBuilder): String

// JVM method = String([B)Ljava/lang/String;
inline fun String(bytes: ByteArray): String

// JVM method = String([BLjava/nio/charset/Charset;)Ljava/lang/String;
inline fun String(bytes: ByteArray, charset: java.nio.charset.Charset): String

// JVM method = String([BII)Ljava/lang/String;
inline fun String(bytes: ByteArray, offset: Int, length: Int): String

// JVM method = String([BIILjava/nio/charset/Charset;)Ljava/lang/String;
inline fun String(bytes: ByteArray, offset: Int, length: Int, charset: java.nio.charset.Charset): String

// JVM method = String([C)Ljava/lang/String;
inline fun String(chars: CharArray): String

// JVM method = String([CII)Ljava/lang/String;
inline fun String(chars: CharArray, offset: Int, length: Int): String

// JVM method = String([III)Ljava/lang/String;
inline fun String(codePoints: IntArray, offset: Int, length: Int): String

// JVM method = capitalize(Ljava/lang/String;)Ljava/lang/String;
fun String.capitalize(): String

// JVM method = capitalize(Ljava/lang/String;Ljava/util/Locale;)Ljava/lang/String;
fun String.capitalize(locale: java.util.Locale): String

// JVM method = codePointAt(Ljava/lang/String;I)I
inline fun String.codePointAt(index: Int): Int

// JVM method = codePointBefore(Ljava/lang/String;I)I
inline fun String.codePointBefore(index: Int): Int

// JVM method = codePointCount(Ljava/lang/String;II)I
inline fun String.codePointCount(beginIndex: Int, endIndex: Int): Int

// JVM method = compareTo(Ljava/lang/String;Ljava/lang/String;Z)I
fun String.compareTo(other: String, ignoreCase: Boolean /* = default */): Int

// JVM method = concatToString([C)Ljava/lang/String;
fun CharArray.concatToString(): String

// JVM method = concatToString([CII)Ljava/lang/String;
fun CharArray.concatToString(startIndex: Int /* = default */, endIndex: Int /* = default */): String

// JVM method = contentEquals(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Z
infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean

// JVM method = contentEquals(Ljava/lang/CharSequence;Ljava/lang/CharSequence;Z)Z
fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean

// JVM method = contentEquals(Ljava/lang/String;Ljava/lang/StringBuffer;)Z
inline fun String.contentEquals(stringBuilder: java.lang.StringBuffer): Boolean

// JVM method = contentEquals(Ljava/lang/String;Ljava/lang/CharSequence;)Z
inline fun String.contentEquals(charSequence: CharSequence): Boolean

// JVM method = decapitalize(Ljava/lang/String;)Ljava/lang/String;
fun String.decapitalize(): String

// JVM method = decapitalize(Ljava/lang/String;Ljava/util/Locale;)Ljava/lang/String;
fun String.decapitalize(locale: java.util.Locale): String

// JVM method = decodeToString([B)Ljava/lang/String;
fun ByteArray.decodeToString(): String

// JVM method = decodeToString([BIIZ)Ljava/lang/String;
fun ByteArray.decodeToString(startIndex: Int /* = default */, endIndex: Int /* = default */, throwOnInvalidSequence: Boolean /* = default */): String

// JVM method = encodeToByteArray(Ljava/lang/String;)[B
fun String.encodeToByteArray(): ByteArray

// JVM method = encodeToByteArray(Ljava/lang/String;IIZ)[B
fun String.encodeToByteArray(startIndex: Int /* = default */, endIndex: Int /* = default */, throwOnInvalidSequence: Boolean /* = default */): ByteArray

// JVM method = endsWith(Ljava/lang/String;Ljava/lang/String;Z)Z
fun String.endsWith(suffix: String, ignoreCase: Boolean /* = default */): Boolean

// JVM method = equals(Ljava/lang/String;Ljava/lang/String;Z)Z
fun String?.equals(other: String?, ignoreCase: Boolean /* = default */): Boolean

// JVM method = format(Ljava/lang/String;Ljava/util/Locale;[Ljava/lang/Object;)Ljava/lang/String;
inline fun String.format(locale: java.util.Locale, vararg args: Any? /* Array<out Any?> */): String

// JVM method = formatNullable(Ljava/lang/String;Ljava/util/Locale;[Ljava/lang/Object;)Ljava/lang/String;
inline fun String.format(locale: java.util.Locale?, vararg args: Any? /* Array<out Any?> */): String

// JVM method = format(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
inline fun String.format(vararg args: Any? /* Array<out Any?> */): String

// JVM method = format(Lkotlin/jvm/internal/StringCompanionObject;Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
inline fun String.Companion.format(locale: java.util.Locale, format: String, vararg args: Any? /* Array<out Any?> */): String

// JVM method = formatNullable(Lkotlin/jvm/internal/StringCompanionObject;Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
inline fun String.Companion.format(locale: java.util.Locale?, format: String, vararg args: Any? /* Array<out Any?> */): String

// JVM method = format(Lkotlin/jvm/internal/StringCompanionObject;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
inline fun String.Companion.format(format: String, vararg args: Any? /* Array<out Any?> */): String

// JVM method = intern(Ljava/lang/String;)Ljava/lang/String;
inline fun String.intern(): String

// JVM method = isBlank(Ljava/lang/CharSequence;)Z
fun CharSequence.isBlank(): Boolean

// JVM method = lowercase(Ljava/lang/String;)Ljava/lang/String;
inline fun String.lowercase(): String

// JVM method = lowercase(Ljava/lang/String;Ljava/util/Locale;)Ljava/lang/String;
inline fun String.lowercase(locale: java.util.Locale): String

// JVM method = nativeIndexOf(Ljava/lang/String;CI)I
internal inline fun String.nativeIndexOf(ch: Char, fromIndex: Int): Int

// JVM method = nativeIndexOf(Ljava/lang/String;Ljava/lang/String;I)I
internal inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int

// JVM method = nativeLastIndexOf(Ljava/lang/String;CI)I
internal inline fun String.nativeLastIndexOf(ch: Char, fromIndex: Int): Int

// JVM method = nativeLastIndexOf(Ljava/lang/String;Ljava/lang/String;I)I
internal inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int

// JVM method = offsetByCodePoints(Ljava/lang/String;II)I
inline fun String.offsetByCodePoints(index: Int, codePointOffset: Int): Int

// JVM method = regionMatches(Ljava/lang/CharSequence;ILjava/lang/CharSequence;IIZ)Z
fun CharSequence.regionMatches(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean /* = default */): Boolean

// JVM method = regionMatches(Ljava/lang/String;ILjava/lang/String;IIZ)Z
fun String.regionMatches(thisOffset: Int, other: String, otherOffset: Int, length: Int, ignoreCase: Boolean /* = default */): Boolean

// JVM method = repeat(Ljava/lang/CharSequence;I)Ljava/lang/String;
fun CharSequence.repeat(n: Int): String

// JVM method = replace(Ljava/lang/String;CCZ)Ljava/lang/String;
fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean /* = default */): String

// JVM method = replace(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Z)Ljava/lang/String;
fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean /* = default */): String

// JVM method = replaceFirst(Ljava/lang/String;CCZ)Ljava/lang/String;
fun String.replaceFirst(oldChar: Char, newChar: Char, ignoreCase: Boolean /* = default */): String

// JVM method = replaceFirst(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Z)Ljava/lang/String;
fun String.replaceFirst(oldValue: String, newValue: String, ignoreCase: Boolean /* = default */): String

// JVM method = split(Ljava/lang/CharSequence;Ljava/util/regex/Pattern;I)Ljava/util/List;
fun CharSequence.split(regex: java.util.regex.Pattern, limit: Int /* = default */): List<String>

// JVM method = startsWith(Ljava/lang/String;Ljava/lang/String;Z)Z
fun String.startsWith(prefix: String, ignoreCase: Boolean /* = default */): Boolean

// JVM method = startsWith(Ljava/lang/String;Ljava/lang/String;IZ)Z
fun String.startsWith(prefix: String, startIndex: Int, ignoreCase: Boolean /* = default */): Boolean

// JVM method = substring(Ljava/lang/String;I)Ljava/lang/String;
inline fun String.substring(startIndex: Int): String

// JVM method = substring(Ljava/lang/String;II)Ljava/lang/String;
inline fun String.substring(startIndex: Int, endIndex: Int): String

// JVM method = toByteArray(Ljava/lang/String;Ljava/nio/charset/Charset;)[B
inline fun String.toByteArray(charset: java.nio.charset.Charset /* = default */): ByteArray

// JVM method = toCharArray(Ljava/lang/String;)[C
inline fun String.toCharArray(): CharArray

// JVM method = toCharArray(Ljava/lang/String;[CIII)[C
inline fun String.toCharArray(destination: CharArray, destinationOffset: Int /* = default */, startIndex: Int /* = default */, endIndex: Int /* = default */): CharArray

// JVM method = toCharArray(Ljava/lang/String;II)[C
fun String.toCharArray(startIndex: Int /* = default */, endIndex: Int /* = default */): CharArray

// JVM method = toLowerCase(Ljava/lang/String;)Ljava/lang/String;
inline fun String.toLowerCase(): String

// JVM method = toLowerCase(Ljava/lang/String;Ljava/util/Locale;)Ljava/lang/String;
inline fun String.toLowerCase(locale: java.util.Locale): String

// JVM method = toPattern(Ljava/lang/String;I)Ljava/util/regex/Pattern;
inline fun String.toPattern(flags: Int /* = default */): java.util.regex.Pattern

// JVM method = toUpperCase(Ljava/lang/String;)Ljava/lang/String;
inline fun String.toUpperCase(): String

// JVM method = toUpperCase(Ljava/lang/String;Ljava/util/Locale;)Ljava/lang/String;
inline fun String.toUpperCase(locale: java.util.Locale): String

// JVM method = uppercase(Ljava/lang/String;)Ljava/lang/String;
inline fun String.uppercase(): String

// JVM method = uppercase(Ljava/lang/String;Ljava/util/Locale;)Ljava/lang/String;
inline fun String.uppercase(locale: java.util.Locale): String

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.StringsKt


// *** PROPERTIES ***

val CharSequence.indices: IntRange
	// JVM method = getIndices(Ljava/lang/CharSequence;)Lkotlin/ranges/IntRange;
	get() = /* non-default */

val CharSequence.lastIndex: Int
	// JVM method = getLastIndex(Ljava/lang/CharSequence;)I
	get() = /* non-default */


// *** FUNCTIONS ***

// JVM method = requireNonNegativeLimit(I)V
internal fun requireNonNegativeLimit(limit: Int)

// JVM method = commonPrefixWith(Ljava/lang/CharSequence;Ljava/lang/CharSequence;Z)Ljava/lang/String;
fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean /* = default */): String

// JVM method = commonSuffixWith(Ljava/lang/CharSequence;Ljava/lang/CharSequence;Z)Ljava/lang/String;
fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean /* = default */): String

// JVM method = contains(Ljava/lang/CharSequence;CZ)Z
operator fun CharSequence.contains(char: Char, ignoreCase: Boolean /* = default */): Boolean

// JVM method = contains(Ljava/lang/CharSequence;Ljava/lang/CharSequence;Z)Z
operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean /* = default */): Boolean

// JVM method = contains(Ljava/lang/CharSequence;Lkotlin/text/Regex;)Z
inline operator fun CharSequence.contains(regex: Regex): Boolean

// JVM method = contentEqualsIgnoreCaseImpl(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Z
internal fun CharSequence?.contentEqualsIgnoreCaseImpl(other: CharSequence?): Boolean

// JVM method = contentEqualsImpl(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Z
internal fun CharSequence?.contentEqualsImpl(other: CharSequence?): Boolean

// JVM method = endsWith(Ljava/lang/CharSequence;CZ)Z
fun CharSequence.endsWith(char: Char, ignoreCase: Boolean /* = default */): Boolean

// JVM method = endsWith(Ljava/lang/CharSequence;Ljava/lang/CharSequence;Z)Z
fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean /* = default */): Boolean

// JVM method = findAnyOf(Ljava/lang/CharSequence;Ljava/util/Collection;IZ)Lkotlin/Pair;
fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int /* = default */, ignoreCase: Boolean /* = default */): Pair<Int, String>?

// JVM method = findAnyOf$StringsKt__StringsKt(Ljava/lang/CharSequence;Ljava/util/Collection;IZZ)Lkotlin/Pair;
private fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>?

// JVM method = findLastAnyOf(Ljava/lang/CharSequence;Ljava/util/Collection;IZ)Lkotlin/Pair;
fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int /* = default */, ignoreCase: Boolean /* = default */): Pair<Int, String>?

// JVM method = hasSurrogatePairAt(Ljava/lang/CharSequence;I)Z
fun CharSequence.hasSurrogatePairAt(index: Int): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = ifBlank(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where
	C : CharSequence,
	C : R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = ifEmpty(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where
	C : CharSequence,
	C : R

// JVM method = indexOf(Ljava/lang/CharSequence;CIZ)I
fun CharSequence.indexOf(char: Char, startIndex: Int /* = default */, ignoreCase: Boolean /* = default */): Int

// JVM method = indexOf$StringsKt__StringsKt(Ljava/lang/CharSequence;Ljava/lang/CharSequence;IIZZ)I
private fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean /* = default */): Int

// JVM method = indexOf(Ljava/lang/CharSequence;Ljava/lang/String;IZ)I
fun CharSequence.indexOf(string: String, startIndex: Int /* = default */, ignoreCase: Boolean /* = default */): Int

// JVM method = indexOfAny(Ljava/lang/CharSequence;[CIZ)I
fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int /* = default */, ignoreCase: Boolean /* = default */): Int

// JVM method = indexOfAny(Ljava/lang/CharSequence;Ljava/util/Collection;IZ)I
fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int /* = default */, ignoreCase: Boolean /* = default */): Int

// JVM method = isEmpty(Ljava/lang/CharSequence;)Z
inline fun CharSequence.isEmpty(): Boolean

// JVM method = isNotBlank(Ljava/lang/CharSequence;)Z
inline fun CharSequence.isNotBlank(): Boolean

// JVM method = isNotEmpty(Ljava/lang/CharSequence;)Z
inline fun CharSequence.isNotEmpty(): Boolean

// JVM method = isNullOrBlank(Ljava/lang/CharSequence;)Z
inline fun CharSequence?.isNullOrBlank(): Boolean {
	contract {
		returns(false) implies (this@isNullOrBlank != null)
	}
}

// JVM method = isNullOrEmpty(Ljava/lang/CharSequence;)Z
inline fun CharSequence?.isNullOrEmpty(): Boolean {
	contract {
		returns(false) implies (this@isNullOrEmpty != null)
	}
}

// JVM method = iterator(Ljava/lang/CharSequence;)Lkotlin/collections/CharIterator;
operator fun CharSequence.iterator(): CharIterator

// JVM method = lastIndexOf(Ljava/lang/CharSequence;CIZ)I
fun CharSequence.lastIndexOf(char: Char, startIndex: Int /* = default */, ignoreCase: Boolean /* = default */): Int

// JVM method = lastIndexOf(Ljava/lang/CharSequence;Ljava/lang/String;IZ)I
fun CharSequence.lastIndexOf(string: String, startIndex: Int /* = default */, ignoreCase: Boolean /* = default */): Int

// JVM method = lastIndexOfAny(Ljava/lang/CharSequence;[CIZ)I
fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int /* = default */, ignoreCase: Boolean /* = default */): Int

// JVM method = lastIndexOfAny(Ljava/lang/CharSequence;Ljava/util/Collection;IZ)I
fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int /* = default */, ignoreCase: Boolean /* = default */): Int

// JVM method = lineSequence(Ljava/lang/CharSequence;)Lkotlin/sequences/Sequence;
fun CharSequence.lineSequence(): Sequence<String>

// JVM method = lines(Ljava/lang/CharSequence;)Ljava/util/List;
fun CharSequence.lines(): List<String>

// JVM method = matches(Ljava/lang/CharSequence;Lkotlin/text/Regex;)Z
inline infix fun CharSequence.matches(regex: Regex): Boolean

// JVM method = orEmpty(Ljava/lang/String;)Ljava/lang/String;
inline fun String?.orEmpty(): String

// JVM method = padEnd(Ljava/lang/CharSequence;IC)Ljava/lang/CharSequence;
fun CharSequence.padEnd(length: Int, padChar: Char /* = default */): CharSequence

// JVM method = padEnd(Ljava/lang/String;IC)Ljava/lang/String;
fun String.padEnd(length: Int, padChar: Char /* = default */): String

// JVM method = padStart(Ljava/lang/CharSequence;IC)Ljava/lang/CharSequence;
fun CharSequence.padStart(length: Int, padChar: Char /* = default */): CharSequence

// JVM method = padStart(Ljava/lang/String;IC)Ljava/lang/String;
fun String.padStart(length: Int, padChar: Char /* = default */): String

// JVM method = rangesDelimitedBy$StringsKt__StringsKt(Ljava/lang/CharSequence;[Ljava/lang/String;IZI)Lkotlin/sequences/Sequence;
private fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int /* = default */, ignoreCase: Boolean /* = default */, limit: Int /* = default */): Sequence<IntRange>

// JVM method = rangesDelimitedBy$StringsKt__StringsKt(Ljava/lang/CharSequence;[CIZI)Lkotlin/sequences/Sequence;
private fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int /* = default */, ignoreCase: Boolean /* = default */, limit: Int /* = default */): Sequence<IntRange>

// JVM method = regionMatchesImpl(Ljava/lang/CharSequence;ILjava/lang/CharSequence;IIZ)Z
internal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean

// JVM method = removePrefix(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/lang/CharSequence;
fun CharSequence.removePrefix(prefix: CharSequence): CharSequence

// JVM method = removePrefix(Ljava/lang/String;Ljava/lang/CharSequence;)Ljava/lang/String;
fun String.removePrefix(prefix: CharSequence): String

// JVM method = removeRange(Ljava/lang/CharSequence;II)Ljava/lang/CharSequence;
fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence

// JVM method = removeRange(Ljava/lang/CharSequence;Lkotlin/ranges/IntRange;)Ljava/lang/CharSequence;
fun CharSequence.removeRange(range: IntRange): CharSequence

// JVM method = removeRange(Ljava/lang/String;II)Ljava/lang/String;
inline fun String.removeRange(startIndex: Int, endIndex: Int): String

// JVM method = removeRange(Ljava/lang/String;Lkotlin/ranges/IntRange;)Ljava/lang/String;
inline fun String.removeRange(range: IntRange): String

// JVM method = removeSuffix(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/lang/CharSequence;
fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence

// JVM method = removeSuffix(Ljava/lang/String;Ljava/lang/CharSequence;)Ljava/lang/String;
fun String.removeSuffix(suffix: CharSequence): String

// JVM method = removeSurrounding(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/lang/CharSequence;
fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence

// JVM method = removeSurrounding(Ljava/lang/CharSequence;Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/lang/CharSequence;
fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence

// JVM method = removeSurrounding(Ljava/lang/String;Ljava/lang/CharSequence;)Ljava/lang/String;
fun String.removeSurrounding(delimiter: CharSequence): String

// JVM method = removeSurrounding(Ljava/lang/String;Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/lang/String;
fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = replace(Ljava/lang/CharSequence;Lkotlin/text/Regex;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String

// JVM method = replace(Ljava/lang/CharSequence;Lkotlin/text/Regex;Ljava/lang/String;)Ljava/lang/String;
inline fun CharSequence.replace(regex: Regex, replacement: String): String

// JVM method = replaceAfter(Ljava/lang/String;CLjava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String /* = default */): String

// JVM method = replaceAfter(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String /* = default */): String

// JVM method = replaceAfterLast(Ljava/lang/String;CLjava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String /* = default */): String

// JVM method = replaceAfterLast(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String /* = default */): String

// JVM method = replaceBefore(Ljava/lang/String;CLjava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String /* = default */): String

// JVM method = replaceBefore(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String /* = default */): String

// JVM method = replaceBeforeLast(Ljava/lang/String;CLjava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String /* = default */): String

// JVM method = replaceBeforeLast(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String /* = default */): String

// JVM method = replaceFirst(Ljava/lang/CharSequence;Lkotlin/text/Regex;Ljava/lang/String;)Ljava/lang/String;
inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = replaceFirstCharWithChar(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun String.replaceFirstChar(transform: (Char) -> Char): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = replaceFirstCharWithCharSequence(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String

// JVM method = replaceRange(Ljava/lang/CharSequence;IILjava/lang/CharSequence;)Ljava/lang/CharSequence;
fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence

// JVM method = replaceRange(Ljava/lang/CharSequence;Lkotlin/ranges/IntRange;Ljava/lang/CharSequence;)Ljava/lang/CharSequence;
fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence

// JVM method = replaceRange(Ljava/lang/String;IILjava/lang/CharSequence;)Ljava/lang/String;
inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String

// JVM method = replaceRange(Ljava/lang/String;Lkotlin/ranges/IntRange;Ljava/lang/CharSequence;)Ljava/lang/String;
inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String

// JVM method = split(Ljava/lang/CharSequence;[Ljava/lang/String;ZI)Ljava/util/List;
fun CharSequence.split(vararg delimiters: String /* Array<out String> */, ignoreCase: Boolean /* = default */, limit: Int /* = default */): List<String>

// JVM method = split(Ljava/lang/CharSequence;[CZI)Ljava/util/List;
fun CharSequence.split(vararg delimiters: Char /* CharArray */, ignoreCase: Boolean /* = default */, limit: Int /* = default */): List<String>

// JVM method = split$StringsKt__StringsKt(Ljava/lang/CharSequence;Ljava/lang/String;ZI)Ljava/util/List;
private fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String>

// JVM method = split(Ljava/lang/CharSequence;Lkotlin/text/Regex;I)Ljava/util/List;
inline fun CharSequence.split(regex: Regex, limit: Int /* = default */): List<String>

// JVM method = splitToSequence(Ljava/lang/CharSequence;[Ljava/lang/String;ZI)Lkotlin/sequences/Sequence;
fun CharSequence.splitToSequence(vararg delimiters: String /* Array<out String> */, ignoreCase: Boolean /* = default */, limit: Int /* = default */): Sequence<String>

// JVM method = splitToSequence(Ljava/lang/CharSequence;[CZI)Lkotlin/sequences/Sequence;
fun CharSequence.splitToSequence(vararg delimiters: Char /* CharArray */, ignoreCase: Boolean /* = default */, limit: Int /* = default */): Sequence<String>

// JVM method = splitToSequence(Ljava/lang/CharSequence;Lkotlin/text/Regex;I)Lkotlin/sequences/Sequence;
inline fun CharSequence.splitToSequence(regex: Regex, limit: Int /* = default */): Sequence<String>

// JVM method = startsWith(Ljava/lang/CharSequence;CZ)Z
fun CharSequence.startsWith(char: Char, ignoreCase: Boolean /* = default */): Boolean

// JVM method = startsWith(Ljava/lang/CharSequence;Ljava/lang/CharSequence;Z)Z
fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean /* = default */): Boolean

// JVM method = startsWith(Ljava/lang/CharSequence;Ljava/lang/CharSequence;IZ)Z
fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean /* = default */): Boolean

// JVM method = subSequence(Ljava/lang/CharSequence;Lkotlin/ranges/IntRange;)Ljava/lang/CharSequence;
fun CharSequence.subSequence(range: IntRange): CharSequence

// JVM method = subSequence(Ljava/lang/String;II)Ljava/lang/CharSequence;
inline fun String.subSequence(start: Int, end: Int): CharSequence

// JVM method = substring(Ljava/lang/CharSequence;II)Ljava/lang/String;
inline fun CharSequence.substring(startIndex: Int, endIndex: Int /* = default */): String

// JVM method = substring(Ljava/lang/CharSequence;Lkotlin/ranges/IntRange;)Ljava/lang/String;
fun CharSequence.substring(range: IntRange): String

// JVM method = substring(Ljava/lang/String;Lkotlin/ranges/IntRange;)Ljava/lang/String;
fun String.substring(range: IntRange): String

// JVM method = substringAfter(Ljava/lang/String;CLjava/lang/String;)Ljava/lang/String;
fun String.substringAfter(delimiter: Char, missingDelimiterValue: String /* = default */): String

// JVM method = substringAfter(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.substringAfter(delimiter: String, missingDelimiterValue: String /* = default */): String

// JVM method = substringAfterLast(Ljava/lang/String;CLjava/lang/String;)Ljava/lang/String;
fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String /* = default */): String

// JVM method = substringAfterLast(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String /* = default */): String

// JVM method = substringBefore(Ljava/lang/String;CLjava/lang/String;)Ljava/lang/String;
fun String.substringBefore(delimiter: Char, missingDelimiterValue: String /* = default */): String

// JVM method = substringBefore(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.substringBefore(delimiter: String, missingDelimiterValue: String /* = default */): String

// JVM method = substringBeforeLast(Ljava/lang/String;CLjava/lang/String;)Ljava/lang/String;
fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String /* = default */): String

// JVM method = substringBeforeLast(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String /* = default */): String

// JVM method = toBooleanStrict(Ljava/lang/String;)Z
fun String.toBooleanStrict(): Boolean

// JVM method = toBooleanStrictOrNull(Ljava/lang/String;)Ljava/lang/Boolean;
fun String.toBooleanStrictOrNull(): Boolean?

// JVM method = trim(Ljava/lang/CharSequence;)Ljava/lang/CharSequence;
fun CharSequence.trim(): CharSequence

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = trim(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/CharSequence;
inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence

// JVM method = trim(Ljava/lang/CharSequence;[C)Ljava/lang/CharSequence;
fun CharSequence.trim(vararg chars: Char /* CharArray */): CharSequence

// JVM method = trim(Ljava/lang/String;)Ljava/lang/String;
inline fun String.trim(): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = trim(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun String.trim(predicate: (Char) -> Boolean): String

// JVM method = trim(Ljava/lang/String;[C)Ljava/lang/String;
fun String.trim(vararg chars: Char /* CharArray */): String

// JVM method = trimEnd(Ljava/lang/CharSequence;)Ljava/lang/CharSequence;
fun CharSequence.trimEnd(): CharSequence

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = trimEnd(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/CharSequence;
inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence

// JVM method = trimEnd(Ljava/lang/CharSequence;[C)Ljava/lang/CharSequence;
fun CharSequence.trimEnd(vararg chars: Char /* CharArray */): CharSequence

// JVM method = trimEnd(Ljava/lang/String;)Ljava/lang/String;
inline fun String.trimEnd(): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = trimEnd(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun String.trimEnd(predicate: (Char) -> Boolean): String

// JVM method = trimEnd(Ljava/lang/String;[C)Ljava/lang/String;
fun String.trimEnd(vararg chars: Char /* CharArray */): String

// JVM method = trimStart(Ljava/lang/CharSequence;)Ljava/lang/CharSequence;
fun CharSequence.trimStart(): CharSequence

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = trimStart(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/CharSequence;
inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence

// JVM method = trimStart(Ljava/lang/CharSequence;[C)Ljava/lang/CharSequence;
fun CharSequence.trimStart(vararg chars: Char /* CharArray */): CharSequence

// JVM method = trimStart(Ljava/lang/String;)Ljava/lang/String;
inline fun String.trimStart(): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = trimStart(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun String.trimStart(predicate: (Char) -> Boolean): String

// JVM method = trimStart(Ljava/lang/String;[C)Ljava/lang/String;
fun String.trimStart(vararg chars: Char /* CharArray */): String

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.StringsKt


// *** FUNCTIONS ***

// JVM method = elementAt(Ljava/lang/CharSequence;I)C
inline fun CharSequence.elementAt(index: Int): Char

// JVM method = max(Ljava/lang/CharSequence;)Ljava/lang/Character;
fun CharSequence.max(): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxBy(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R : Comparable<R>): Char?

// JVM method = maxWith(Ljava/lang/CharSequence;Ljava/util/Comparator;)Ljava/lang/Character;
fun CharSequence.maxWith(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): Char?

// JVM method = min(Ljava/lang/CharSequence;)Ljava/lang/Character;
fun CharSequence.min(): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minBy(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R : Comparable<R>): Char?

// JVM method = minWith(Ljava/lang/CharSequence;Ljava/util/Comparator;)Ljava/lang/Character;
fun CharSequence.minWith(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigDecimal(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/math/BigDecimal;
inline fun CharSequence.sumOf(selector: (Char) -> java.math.BigDecimal): java.math.BigDecimal

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfBigInteger(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/math/BigInteger;
inline fun CharSequence.sumOf(selector: (Char) -> java.math.BigInteger): java.math.BigInteger

// JVM method = toSortedSet(Ljava/lang/CharSequence;)Ljava/util/SortedSet;
fun CharSequence.toSortedSet(): java.util.SortedSet<Char>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.text.StringsKt


// *** FUNCTIONS ***

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = all(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Z
inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean

// JVM method = any(Ljava/lang/CharSequence;)Z
fun CharSequence.any(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = any(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Z
inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean

// JVM method = asIterable(Ljava/lang/CharSequence;)Ljava/lang/Iterable;
fun CharSequence.asIterable(): Iterable<Char>

// JVM method = asSequence(Ljava/lang/CharSequence;)Lkotlin/sequences/Sequence;
fun CharSequence.asSequence(): Sequence<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associate(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateBy(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo(Ljava/lang/CharSequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M : MutableMap<in K, in Char>, keySelector: (Char) -> K): M : MutableMap<in K, in Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateByTo(Ljava/lang/CharSequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M : MutableMap<in K, in V>, keySelector: (Char) -> K, valueTransform: (Char) -> V): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateTo(Ljava/lang/CharSequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M : MutableMap<in K, in V>, transform: (Char) -> Pair<K, V>): M : MutableMap<in K, in V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWith(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = associateWithTo(Ljava/lang/CharSequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M : MutableMap<in Char, in V>, valueSelector: (Char) -> V): M : MutableMap<in Char, in V>

// JVM method = chunked(Ljava/lang/CharSequence;I)Ljava/util/List;
fun CharSequence.chunked(size: Int): List<String>

// JVM method = chunked(Ljava/lang/CharSequence;ILkotlin/jvm/functions/Function1;)Ljava/util/List;
fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R>

// JVM method = chunkedSequence(Ljava/lang/CharSequence;I)Lkotlin/sequences/Sequence;
fun CharSequence.chunkedSequence(size: Int): Sequence<String>

// JVM method = chunkedSequence(Ljava/lang/CharSequence;ILkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R>

// JVM method = count(Ljava/lang/CharSequence;)I
inline fun CharSequence.count(): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = count(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)I
inline fun CharSequence.count(predicate: (Char) -> Boolean): Int

// JVM method = drop(Ljava/lang/CharSequence;I)Ljava/lang/CharSequence;
fun CharSequence.drop(n: Int): CharSequence

// JVM method = drop(Ljava/lang/String;I)Ljava/lang/String;
fun String.drop(n: Int): String

// JVM method = dropLast(Ljava/lang/CharSequence;I)Ljava/lang/CharSequence;
fun CharSequence.dropLast(n: Int): CharSequence

// JVM method = dropLast(Ljava/lang/String;I)Ljava/lang/String;
fun String.dropLast(n: Int): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropLastWhile(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/CharSequence;
inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropLastWhile(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropWhile(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/CharSequence;
inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = dropWhile(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun String.dropWhile(predicate: (Char) -> Boolean): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = elementAtOrElse(Ljava/lang/CharSequence;ILkotlin/jvm/functions/Function1;)C
inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char

// JVM method = elementAtOrNull(Ljava/lang/CharSequence;I)Ljava/lang/Character;
inline fun CharSequence.elementAtOrNull(index: Int): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/CharSequence;
inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filter(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun String.filter(predicate: (Char) -> Boolean): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexed(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)Ljava/lang/CharSequence;
inline fun CharSequence.filterIndexed(predicate: (@ParameterName(name = "index") Int, Char) -> Boolean): CharSequence

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexed(Ljava/lang/String;Lkotlin/jvm/functions/Function2;)Ljava/lang/String;
inline fun String.filterIndexed(predicate: (@ParameterName(name = "index") Int, Char) -> Boolean): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterIndexedTo(Ljava/lang/CharSequence;Ljava/lang/Appendable;Lkotlin/jvm/functions/Function2;)Ljava/lang/Appendable;
inline fun <C : Appendable /* = java.lang.Appendable */> CharSequence.filterIndexedTo(destination: C : Appendable /* = java.lang.Appendable */, predicate: (@ParameterName(name = "index") Int, Char) -> Boolean): C : Appendable /* = java.lang.Appendable */

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/CharSequence;
inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNot(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun String.filterNot(predicate: (Char) -> Boolean): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterNotTo(Ljava/lang/CharSequence;Ljava/lang/Appendable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
inline fun <C : Appendable /* = java.lang.Appendable */> CharSequence.filterNotTo(destination: C : Appendable /* = java.lang.Appendable */, predicate: (Char) -> Boolean): C : Appendable /* = java.lang.Appendable */

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = filterTo(Ljava/lang/CharSequence;Ljava/lang/Appendable;Lkotlin/jvm/functions/Function1;)Ljava/lang/Appendable;
inline fun <C : Appendable /* = java.lang.Appendable */> CharSequence.filterTo(destination: C : Appendable /* = java.lang.Appendable */, predicate: (Char) -> Boolean): C : Appendable /* = java.lang.Appendable */

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = find(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun CharSequence.find(predicate: (Char) -> Boolean): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = findLast(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char?

// JVM method = first(Ljava/lang/CharSequence;)C
fun CharSequence.first(): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = first(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)C
inline fun CharSequence.first(predicate: (Char) -> Boolean): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstNotNullOf(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R : Any> CharSequence.firstNotNullOf(transform: (Char) -> R : Any?): R : Any

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstNotNullOfOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R : Any> CharSequence.firstNotNullOfOrNull(transform: (Char) -> R : Any?): R : Any?

// JVM method = firstOrNull(Ljava/lang/CharSequence;)Ljava/lang/Character;
fun CharSequence.firstOrNull(): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = firstOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMap(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterable(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> CharSequence.flatMapIndexed(transform: (@ParameterName(name = "index") Int, Char) -> Iterable<R>): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapIndexedIterableTo(Ljava/lang/CharSequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Char) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = flatMapTo(Ljava/lang/CharSequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C : MutableCollection<in R>, transform: (Char) -> Iterable<R>): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = fold(Ljava/lang/CharSequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> CharSequence.fold(initial: R, operation: (@ParameterName(name = "acc") R, Char) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldIndexed(Ljava/lang/CharSequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> CharSequence.foldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Char) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRight(Ljava/lang/CharSequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/lang/Object;
inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = foldRightIndexed(Ljava/lang/CharSequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/lang/Object;
inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (@ParameterName(name = "index") Int, Char, @ParameterName(name = "acc") R) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEach(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)V
inline fun CharSequence.forEach(action: (Char) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachIndexed(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)V
inline fun CharSequence.forEachIndexed(action: (@ParameterName(name = "index") Int, Char) -> Unit)

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = getOrElse(Ljava/lang/CharSequence;ILkotlin/jvm/functions/Function1;)C
inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char

// JVM method = getOrNull(Ljava/lang/CharSequence;I)Ljava/lang/Character;
fun CharSequence.getOrNull(index: Int): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupBy(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo(Ljava/lang/CharSequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M : MutableMap<in K, MutableList<Char>>, keySelector: (Char) -> K): M : MutableMap<in K, MutableList<Char>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupByTo(Ljava/lang/CharSequence;Ljava/util/Map;Lkotlin/jvm/functions/Function1;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M : MutableMap<in K, MutableList<V>>, keySelector: (Char) -> K, valueTransform: (Char) -> V): M : MutableMap<in K, MutableList<V>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = groupingBy(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Lkotlin/collections/Grouping;
inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfFirst(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)I
inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = indexOfLast(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)I
inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int

// JVM method = last(Ljava/lang/CharSequence;)C
fun CharSequence.last(): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = last(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)C
inline fun CharSequence.last(predicate: (Char) -> Boolean): Char

// JVM method = lastOrNull(Ljava/lang/CharSequence;)Ljava/lang/Character;
fun CharSequence.lastOrNull(): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = lastOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = map(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R> CharSequence.map(transform: (Char) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexed(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> CharSequence.mapIndexed(transform: (@ParameterName(name = "index") Int, Char) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedNotNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (@ParameterName(name = "index") Int, Char) -> R : Any?): List<R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedNotNullTo(Ljava/lang/CharSequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R : Any, C : MutableCollection<in R : Any>> CharSequence.mapIndexedNotNullTo(destination: C : MutableCollection<in R : Any>, transform: (@ParameterName(name = "index") Int, Char) -> R : Any?): C : MutableCollection<in R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapIndexedTo(Ljava/lang/CharSequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function2;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C : MutableCollection<in R>, transform: (@ParameterName(name = "index") Int, Char) -> R): C : MutableCollection<in R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapNotNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/util/List;
inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R : Any?): List<R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapNotNullTo(Ljava/lang/CharSequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R : Any, C : MutableCollection<in R : Any>> CharSequence.mapNotNullTo(destination: C : MutableCollection<in R : Any>, transform: (Char) -> R : Any?): C : MutableCollection<in R : Any>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = mapTo(Ljava/lang/CharSequence;Ljava/util/Collection;Lkotlin/jvm/functions/Function1;)Ljava/util/Collection;
inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C : MutableCollection<in R>, transform: (Char) -> R): C : MutableCollection<in R>

// JVM method = maxOrThrow(Ljava/lang/CharSequence;)C
fun CharSequence.max(): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrThrow(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)C
inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R : Comparable<R>): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxByOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun <R : Comparable<R>> CharSequence.maxByOrNull(selector: (Char) -> R : Comparable<R>): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> CharSequence.maxOf(selector: (Char) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)D
inline fun CharSequence.maxOf(selector: (Char) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOf(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)F
inline fun CharSequence.maxOf(selector: (Char) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> CharSequence.maxOfOrNull(selector: (Char) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun CharSequence.maxOfOrNull(selector: (Char) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun CharSequence.maxOfOrNull(selector: (Char) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWith(Ljava/lang/CharSequence;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> CharSequence.maxOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Char) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = maxOfWithOrNull(Ljava/lang/CharSequence;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> CharSequence.maxOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Char) -> R): R?

// JVM method = maxOrNull(Ljava/lang/CharSequence;)Ljava/lang/Character;
fun CharSequence.maxOrNull(): Char?

// JVM method = maxWithOrThrow(Ljava/lang/CharSequence;Ljava/util/Comparator;)C
fun CharSequence.maxWith(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): Char

// JVM method = maxWithOrNull(Ljava/lang/CharSequence;Ljava/util/Comparator;)Ljava/lang/Character;
fun CharSequence.maxWithOrNull(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): Char?

// JVM method = minOrThrow(Ljava/lang/CharSequence;)C
fun CharSequence.min(): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrThrow(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)C
inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R : Comparable<R>): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minByOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun <R : Comparable<R>> CharSequence.minByOrNull(selector: (Char) -> R : Comparable<R>): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> CharSequence.minOf(selector: (Char) -> R : Comparable<R>): R : Comparable<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)D
inline fun CharSequence.minOf(selector: (Char) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOf(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)F
inline fun CharSequence.minOf(selector: (Char) -> Float): Float

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Comparable;
inline fun <R : Comparable<R>> CharSequence.minOfOrNull(selector: (Char) -> R : Comparable<R>): R : Comparable<R>?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Double;
inline fun CharSequence.minOfOrNull(selector: (Char) -> Double): Double?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Float;
inline fun CharSequence.minOfOrNull(selector: (Char) -> Float): Float?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWith(Ljava/lang/CharSequence;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> CharSequence.minOfWith(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Char) -> R): R

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = minOfWithOrNull(Ljava/lang/CharSequence;Ljava/util/Comparator;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <R> CharSequence.minOfWithOrNull(comparator: Comparator<in R> /* = java.util.Comparator<in R> */, selector: (Char) -> R): R?

// JVM method = minOrNull(Ljava/lang/CharSequence;)Ljava/lang/Character;
fun CharSequence.minOrNull(): Char?

// JVM method = minWithOrThrow(Ljava/lang/CharSequence;Ljava/util/Comparator;)C
fun CharSequence.minWith(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): Char

// JVM method = minWithOrNull(Ljava/lang/CharSequence;Ljava/util/Comparator;)Ljava/lang/Character;
fun CharSequence.minWithOrNull(comparator: Comparator<in Char> /* = java.util.Comparator<in Char> */): Char?

// JVM method = none(Ljava/lang/CharSequence;)Z
fun CharSequence.none(): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = none(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Z
inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEach(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/CharSequence;
inline fun <S : CharSequence> S : CharSequence.onEach(action: (Char) -> Unit): S : CharSequence

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = onEachIndexed(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)Ljava/lang/CharSequence;
inline fun <S : CharSequence> S : CharSequence.onEachIndexed(action: (@ParameterName(name = "index") Int, Char) -> Unit): S : CharSequence

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = partition(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Lkotlin/Pair;
inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String>

// JVM method = random(Ljava/lang/CharSequence;)C
inline fun CharSequence.random(): Char

// JVM method = random(Ljava/lang/CharSequence;Lkotlin/random/Random;)C
fun CharSequence.random(random: kotlin.random.Random): Char

// JVM method = randomOrNull(Ljava/lang/CharSequence;)Ljava/lang/Character;
inline fun CharSequence.randomOrNull(): Char?

// JVM method = randomOrNull(Ljava/lang/CharSequence;Lkotlin/random/Random;)Ljava/lang/Character;
fun CharSequence.randomOrNull(random: kotlin.random.Random): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduce(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)C
inline fun CharSequence.reduce(operation: (@ParameterName(name = "acc") Char, Char) -> Char): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexed(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function3;)C
inline fun CharSequence.reduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Char, Char) -> Char): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceIndexedOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function3;)Ljava/lang/Character;
inline fun CharSequence.reduceIndexedOrNull(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Char, Char) -> Char): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)Ljava/lang/Character;
inline fun CharSequence.reduceOrNull(operation: (@ParameterName(name = "acc") Char, Char) -> Char): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRight(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)C
inline fun CharSequence.reduceRight(operation: (Char, @ParameterName(name = "acc") Char) -> Char): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexed(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function3;)C
inline fun CharSequence.reduceRightIndexed(operation: (@ParameterName(name = "index") Int, Char, @ParameterName(name = "acc") Char) -> Char): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightIndexedOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function3;)Ljava/lang/Character;
inline fun CharSequence.reduceRightIndexedOrNull(operation: (@ParameterName(name = "index") Int, Char, @ParameterName(name = "acc") Char) -> Char): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = reduceRightOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)Ljava/lang/Character;
inline fun CharSequence.reduceRightOrNull(operation: (Char, @ParameterName(name = "acc") Char) -> Char): Char?

// JVM method = reversed(Ljava/lang/CharSequence;)Ljava/lang/CharSequence;
fun CharSequence.reversed(): CharSequence

// JVM method = reversed(Ljava/lang/String;)Ljava/lang/String;
inline fun String.reversed(): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFold(Ljava/lang/CharSequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> CharSequence.runningFold(initial: R, operation: (@ParameterName(name = "acc") R, Char) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningFoldIndexed(Ljava/lang/CharSequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> CharSequence.runningFoldIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Char) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduce(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun CharSequence.runningReduce(operation: (@ParameterName(name = "acc") Char, Char) -> Char): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = runningReduceIndexed(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun CharSequence.runningReduceIndexed(operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") Char, Char) -> Char): List<Char>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scan(Ljava/lang/CharSequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> CharSequence.scan(initial: R, operation: (@ParameterName(name = "acc") R, Char) -> R): List<R>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = scanIndexed(Ljava/lang/CharSequence;Ljava/lang/Object;Lkotlin/jvm/functions/Function3;)Ljava/util/List;
inline fun <R> CharSequence.scanIndexed(initial: R, operation: (@ParameterName(name = "index") Int, @ParameterName(name = "acc") R, Char) -> R): List<R>

// JVM method = single(Ljava/lang/CharSequence;)C
fun CharSequence.single(): Char

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = single(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)C
inline fun CharSequence.single(predicate: (Char) -> Boolean): Char

// JVM method = singleOrNull(Ljava/lang/CharSequence;)Ljava/lang/Character;
fun CharSequence.singleOrNull(): Char?

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = singleOrNull(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/Character;
inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char?

// JVM method = slice(Ljava/lang/CharSequence;Ljava/lang/Iterable;)Ljava/lang/CharSequence;
fun CharSequence.slice(indices: Iterable<Int>): CharSequence

// JVM method = slice(Ljava/lang/CharSequence;Lkotlin/ranges/IntRange;)Ljava/lang/CharSequence;
fun CharSequence.slice(indices: IntRange): CharSequence

// JVM method = slice(Ljava/lang/String;Ljava/lang/Iterable;)Ljava/lang/String;
inline fun String.slice(indices: Iterable<Int>): String

// JVM method = slice(Ljava/lang/String;Lkotlin/ranges/IntRange;)Ljava/lang/String;
fun String.slice(indices: IntRange): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumBy(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)I
inline fun CharSequence.sumBy(selector: (Char) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumByDouble(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)D
inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfDouble(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)D
inline fun CharSequence.sumOf(selector: (Char) -> Double): Double

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfInt(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)I
inline fun CharSequence.sumOf(selector: (Char) -> Int): Int

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = sumOfLong(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)J
inline fun CharSequence.sumOf(selector: (Char) -> Long): Long

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfUInt(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)I
inline fun CharSequence.sumOf(selector: (Char) -> UInt): UInt

// requires compiler version >= 1.3.50, otherwise diagnostic error
// requires language version >= 1.3, otherwise diagnostic error
// JVM method = sumOfULong(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)J
inline fun CharSequence.sumOf(selector: (Char) -> ULong): ULong

// JVM method = take(Ljava/lang/CharSequence;I)Ljava/lang/CharSequence;
fun CharSequence.take(n: Int): CharSequence

// JVM method = take(Ljava/lang/String;I)Ljava/lang/String;
fun String.take(n: Int): String

// JVM method = takeLast(Ljava/lang/CharSequence;I)Ljava/lang/CharSequence;
fun CharSequence.takeLast(n: Int): CharSequence

// JVM method = takeLast(Ljava/lang/String;I)Ljava/lang/String;
fun String.takeLast(n: Int): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeLastWhile(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/CharSequence;
inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeLastWhile(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeWhile(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function1;)Ljava/lang/CharSequence;
inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = takeWhile(Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/String;
inline fun String.takeWhile(predicate: (Char) -> Boolean): String

// JVM method = toCollection(Ljava/lang/CharSequence;Ljava/util/Collection;)Ljava/util/Collection;
fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C : MutableCollection<in Char>): C : MutableCollection<in Char>

// JVM method = toHashSet(Ljava/lang/CharSequence;)Ljava/util/HashSet;
fun CharSequence.toHashSet(): HashSet<Char> /* = java.util.HashSet<Char> */

// JVM method = toList(Ljava/lang/CharSequence;)Ljava/util/List;
fun CharSequence.toList(): List<Char>

// JVM method = toMutableList(Ljava/lang/CharSequence;)Ljava/util/List;
fun CharSequence.toMutableList(): MutableList<Char>

// JVM method = toSet(Ljava/lang/CharSequence;)Ljava/util/Set;
fun CharSequence.toSet(): Set<Char>

// JVM method = windowed(Ljava/lang/CharSequence;IIZ)Ljava/util/List;
fun CharSequence.windowed(size: Int, step: Int /* = default */, partialWindows: Boolean /* = default */): List<String>

// JVM method = windowed(Ljava/lang/CharSequence;IIZLkotlin/jvm/functions/Function1;)Ljava/util/List;
fun <R> CharSequence.windowed(size: Int, step: Int /* = default */, partialWindows: Boolean /* = default */, transform: (CharSequence) -> R): List<R>

// JVM method = windowedSequence(Ljava/lang/CharSequence;IIZ)Lkotlin/sequences/Sequence;
fun CharSequence.windowedSequence(size: Int, step: Int /* = default */, partialWindows: Boolean /* = default */): Sequence<String>

// JVM method = windowedSequence(Ljava/lang/CharSequence;IIZLkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;
fun <R> CharSequence.windowedSequence(size: Int, step: Int /* = default */, partialWindows: Boolean /* = default */, transform: (CharSequence) -> R): Sequence<R>

// JVM method = withIndex(Ljava/lang/CharSequence;)Ljava/lang/Iterable;
fun CharSequence.withIndex(): Iterable<IndexedValue<Char>>

// JVM method = zip(Ljava/lang/CharSequence;Ljava/lang/CharSequence;)Ljava/util/List;
infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zip(Ljava/lang/CharSequence;Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <V> CharSequence.zip(other: CharSequence, transform: (@ParameterName(name = "a") Char, @ParameterName(name = "b") Char) -> V): List<V>

// JVM method = zipWithNext(Ljava/lang/CharSequence;)Ljava/util/List;
fun CharSequence.zipWithNext(): List<Pair<Char, Char>>

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = zipWithNext(Ljava/lang/CharSequence;Lkotlin/jvm/functions/Function2;)Ljava/util/List;
inline fun <R> CharSequence.zipWithNext(transform: (@ParameterName(name = "a") Char, @ParameterName(name = "b") Char) -> R): List<R>

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.time.DurationUnitKt


// *** FUNCTIONS ***

// JVM method = convertDurationUnit(DLkotlin/time/DurationUnit;Lkotlin/time/DurationUnit;)D
internal fun convertDurationUnit(value: Double, sourceUnit: kotlin.time.DurationUnit, targetUnit: kotlin.time.DurationUnit): Double

// JVM method = convertDurationUnit(JLkotlin/time/DurationUnit;Lkotlin/time/DurationUnit;)J
internal fun convertDurationUnit(value: Long, sourceUnit: kotlin.time.DurationUnit, targetUnit: kotlin.time.DurationUnit): Long

// JVM method = convertDurationUnitOverflow(JLkotlin/time/DurationUnit;Lkotlin/time/DurationUnit;)J
internal fun convertDurationUnitOverflow(value: Long, sourceUnit: kotlin.time.DurationUnit, targetUnit: kotlin.time.DurationUnit): Long

// JVM method = toDurationUnit(Ljava/util/concurrent/TimeUnit;)Lkotlin/time/DurationUnit;
fun java.util.concurrent.TimeUnit.toDurationUnit(): kotlin.time.DurationUnit

// JVM method = toTimeUnit(Lkotlin/time/DurationUnit;)Ljava/util/concurrent/TimeUnit;
fun kotlin.time.DurationUnit.toTimeUnit(): java.util.concurrent.TimeUnit

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.time.DurationUnitKt


// *** FUNCTIONS ***

// JVM method = durationUnitByIsoChar(CZ)Lkotlin/time/DurationUnit;
internal fun durationUnitByIsoChar(isoChar: Char, isTimeComponent: Boolean): kotlin.time.DurationUnit

// JVM method = durationUnitByShortName(Ljava/lang/String;)Lkotlin/time/DurationUnit;
internal fun durationUnitByShortName(shortName: String): kotlin.time.DurationUnit

// JVM method = shortName(Lkotlin/time/DurationUnit;)Ljava/lang/String;
internal fun kotlin.time.DurationUnit.shortName(): String

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.io.path.PathsKt


// *** FUNCTIONS ***

// JVM method = appendBytes(Ljava/nio/file/Path;[B)V
inline fun java.nio.file.Path.appendBytes(array: ByteArray)

// JVM method = appendLines(Ljava/nio/file/Path;Ljava/lang/Iterable;Ljava/nio/charset/Charset;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.appendLines(lines: Iterable<CharSequence>, charset: java.nio.charset.Charset /* = default */): java.nio.file.Path

// JVM method = appendLines(Ljava/nio/file/Path;Lkotlin/sequences/Sequence;Ljava/nio/charset/Charset;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.appendLines(lines: Sequence<CharSequence>, charset: java.nio.charset.Charset /* = default */): java.nio.file.Path

// JVM method = appendText(Ljava/nio/file/Path;Ljava/lang/CharSequence;Ljava/nio/charset/Charset;)V
fun java.nio.file.Path.appendText(text: CharSequence, charset: java.nio.charset.Charset /* = default */)

// JVM method = bufferedReader(Ljava/nio/file/Path;Ljava/nio/charset/Charset;I[Ljava/nio/file/OpenOption;)Ljava/io/BufferedReader;
inline fun java.nio.file.Path.bufferedReader(charset: java.nio.charset.Charset /* = default */, bufferSize: Int /* = default */, vararg options: java.nio.file.OpenOption /* Array<out java.nio.file.OpenOption> */): java.io.BufferedReader

// JVM method = bufferedWriter(Ljava/nio/file/Path;Ljava/nio/charset/Charset;I[Ljava/nio/file/OpenOption;)Ljava/io/BufferedWriter;
inline fun java.nio.file.Path.bufferedWriter(charset: java.nio.charset.Charset /* = default */, bufferSize: Int /* = default */, vararg options: java.nio.file.OpenOption /* Array<out java.nio.file.OpenOption> */): java.io.BufferedWriter

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachLine(Ljava/nio/file/Path;Ljava/nio/charset/Charset;Lkotlin/jvm/functions/Function1;)V
inline fun java.nio.file.Path.forEachLine(charset: java.nio.charset.Charset /* = default */, action: (@ParameterName(name = "line") String) -> Unit)

// JVM method = inputStream(Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/InputStream;
inline fun java.nio.file.Path.inputStream(vararg options: java.nio.file.OpenOption /* Array<out java.nio.file.OpenOption> */): java.io.InputStream

// JVM method = outputStream(Ljava/nio/file/Path;[Ljava/nio/file/OpenOption;)Ljava/io/OutputStream;
inline fun java.nio.file.Path.outputStream(vararg options: java.nio.file.OpenOption /* Array<out java.nio.file.OpenOption> */): java.io.OutputStream

// JVM method = readBytes(Ljava/nio/file/Path;)[B
inline fun java.nio.file.Path.readBytes(): ByteArray

// JVM method = readLines(Ljava/nio/file/Path;Ljava/nio/charset/Charset;)Ljava/util/List;
inline fun java.nio.file.Path.readLines(charset: java.nio.charset.Charset /* = default */): List<String>

// JVM method = readText(Ljava/nio/file/Path;Ljava/nio/charset/Charset;)Ljava/lang/String;
fun java.nio.file.Path.readText(charset: java.nio.charset.Charset /* = default */): String

// JVM method = reader(Ljava/nio/file/Path;Ljava/nio/charset/Charset;[Ljava/nio/file/OpenOption;)Ljava/io/InputStreamReader;
inline fun java.nio.file.Path.reader(charset: java.nio.charset.Charset /* = default */, vararg options: java.nio.file.OpenOption /* Array<out java.nio.file.OpenOption> */): java.io.InputStreamReader

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = useLines(Ljava/nio/file/Path;Ljava/nio/charset/Charset;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> java.nio.file.Path.useLines(charset: java.nio.charset.Charset /* = default */, block: (Sequence<String>) -> T): T

// JVM method = writeBytes(Ljava/nio/file/Path;[B[Ljava/nio/file/OpenOption;)V
inline fun java.nio.file.Path.writeBytes(array: ByteArray, vararg options: java.nio.file.OpenOption /* Array<out java.nio.file.OpenOption> */)

// JVM method = writeLines(Ljava/nio/file/Path;Ljava/lang/Iterable;Ljava/nio/charset/Charset;[Ljava/nio/file/OpenOption;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.writeLines(lines: Iterable<CharSequence>, charset: java.nio.charset.Charset /* = default */, vararg options: java.nio.file.OpenOption /* Array<out java.nio.file.OpenOption> */): java.nio.file.Path

// JVM method = writeLines(Ljava/nio/file/Path;Lkotlin/sequences/Sequence;Ljava/nio/charset/Charset;[Ljava/nio/file/OpenOption;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.writeLines(lines: Sequence<CharSequence>, charset: java.nio.charset.Charset /* = default */, vararg options: java.nio.file.OpenOption /* Array<out java.nio.file.OpenOption> */): java.nio.file.Path

// JVM method = writeText(Ljava/nio/file/Path;Ljava/lang/CharSequence;Ljava/nio/charset/Charset;[Ljava/nio/file/OpenOption;)V
fun java.nio.file.Path.writeText(text: CharSequence, charset: java.nio.charset.Charset /* = default */, vararg options: java.nio.file.OpenOption /* Array<out java.nio.file.OpenOption> */)

// JVM method = writer(Ljava/nio/file/Path;Ljava/nio/charset/Charset;[Ljava/nio/file/OpenOption;)Ljava/io/OutputStreamWriter;
inline fun java.nio.file.Path.writer(charset: java.nio.charset.Charset /* = default */, vararg options: java.nio.file.OpenOption /* Array<out java.nio.file.OpenOption> */): java.io.OutputStreamWriter

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.io.path.PathsKt


// *** FUNCTIONS ***

// JVM method = collectIfThrows$PathsKt__PathRecursiveFunctionsKt(Lkotlin/io/path/ExceptionsCollector;Lkotlin/jvm/functions/Function0;)V
private inline fun collectIfThrows(collector: kotlin.io.path.ExceptionsCollector, function: () -> Unit)

// JVM method = insecureEnterDirectory$PathsKt__PathRecursiveFunctionsKt(Ljava/nio/file/Path;Lkotlin/io/path/ExceptionsCollector;)V
private fun insecureEnterDirectory(path: java.nio.file.Path, collector: kotlin.io.path.ExceptionsCollector)

// JVM method = insecureHandleEntry$PathsKt__PathRecursiveFunctionsKt(Ljava/nio/file/Path;Lkotlin/io/path/ExceptionsCollector;)V
private fun insecureHandleEntry(entry: java.nio.file.Path, collector: kotlin.io.path.ExceptionsCollector)

// JVM method = tryIgnoreNoSuchFileException$PathsKt__PathRecursiveFunctionsKt(Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
private inline fun <R> tryIgnoreNoSuchFileException(function: () -> R): R?

// JVM method = copyToRecursively(Ljava/nio/file/Path;Ljava/nio/file/Path;Lkotlin/jvm/functions/Function3;ZZ)Ljava/nio/file/Path;
fun java.nio.file.Path.copyToRecursively(target: java.nio.file.Path, onError: (@ParameterName(name = "source") java.nio.file.Path, @ParameterName(name = "target") java.nio.file.Path, @ParameterName(name = "exception") Exception /* = java.lang.Exception */) -> kotlin.io.path.OnErrorResult /* = default */, followLinks: Boolean, overwrite: Boolean): java.nio.file.Path

// JVM method = copyToRecursively(Ljava/nio/file/Path;Ljava/nio/file/Path;Lkotlin/jvm/functions/Function3;ZLkotlin/jvm/functions/Function3;)Ljava/nio/file/Path;
fun java.nio.file.Path.copyToRecursively(target: java.nio.file.Path, onError: (@ParameterName(name = "source") java.nio.file.Path, @ParameterName(name = "target") java.nio.file.Path, @ParameterName(name = "exception") Exception /* = java.lang.Exception */) -> kotlin.io.path.OnErrorResult /* = default */, followLinks: Boolean, copyAction: kotlin.io.path.CopyActionContext.(@ParameterName(name = "source") java.nio.file.Path, @ParameterName(name = "target") java.nio.file.Path) -> kotlin.io.path.CopyActionResult /* = default */): java.nio.file.Path

// JVM method = deleteRecursively(Ljava/nio/file/Path;)V
fun java.nio.file.Path.deleteRecursively()

// JVM method = deleteRecursivelyImpl$PathsKt__PathRecursiveFunctionsKt(Ljava/nio/file/Path;)Ljava/util/List;
private fun java.nio.file.Path.deleteRecursivelyImpl(): List<Exception /* = java.lang.Exception */>

// JVM method = enterDirectory$PathsKt__PathRecursiveFunctionsKt(Ljava/nio/file/SecureDirectoryStream;Ljava/nio/file/Path;Lkotlin/io/path/ExceptionsCollector;)V
private fun java.nio.file.SecureDirectoryStream<java.nio.file.Path>.enterDirectory(name: java.nio.file.Path, collector: kotlin.io.path.ExceptionsCollector)

// JVM method = handleEntry$PathsKt__PathRecursiveFunctionsKt(Ljava/nio/file/SecureDirectoryStream;Ljava/nio/file/Path;Lkotlin/io/path/ExceptionsCollector;)V
private fun java.nio.file.SecureDirectoryStream<java.nio.file.Path>.handleEntry(name: java.nio.file.Path, collector: kotlin.io.path.ExceptionsCollector)

// JVM method = isDirectory$PathsKt__PathRecursiveFunctionsKt(Ljava/nio/file/SecureDirectoryStream;Ljava/nio/file/Path;[Ljava/nio/file/LinkOption;)Z
private fun java.nio.file.SecureDirectoryStream<java.nio.file.Path>.isDirectory(entryName: java.nio.file.Path, vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): Boolean

// JVM method = toFileVisitResult$PathsKt__PathRecursiveFunctionsKt(Lkotlin/io/path/CopyActionResult;)Ljava/nio/file/FileVisitResult;
private fun kotlin.io.path.CopyActionResult.toFileVisitResult(): java.nio.file.FileVisitResult

// JVM method = toFileVisitResult$PathsKt__PathRecursiveFunctionsKt(Lkotlin/io/path/OnErrorResult;)Ljava/nio/file/FileVisitResult;
private fun kotlin.io.path.OnErrorResult.toFileVisitResult(): java.nio.file.FileVisitResult

// ------------------------------------------------------------------------------------------------------

/* multi-file part */
/* file-level declarations */

/* facade */ class kotlin.io.path.PathsKt


// *** PROPERTIES ***

// JVM annotation-holding method = getExtension$annotations(Ljava/nio/file/Path;)V
val java.nio.file.Path.extension: String
	// JVM method = getExtension(Ljava/nio/file/Path;)Ljava/lang/String;
	get() = /* non-default */

// JVM annotation-holding method = getInvariantSeparatorsPath$annotations(Ljava/nio/file/Path;)V
inline val java.nio.file.Path.invariantSeparatorsPath: String
	// JVM method = getInvariantSeparatorsPath(Ljava/nio/file/Path;)Ljava/lang/String;
	get() = /* non-default */

// JVM annotation-holding method = getInvariantSeparatorsPathString$annotations(Ljava/nio/file/Path;)V
val java.nio.file.Path.invariantSeparatorsPathString: String
	// JVM method = getInvariantSeparatorsPathString(Ljava/nio/file/Path;)Ljava/lang/String;
	get() = /* non-default */

// JVM annotation-holding method = getName$annotations(Ljava/nio/file/Path;)V
val java.nio.file.Path.name: String
	// JVM method = getName(Ljava/nio/file/Path;)Ljava/lang/String;
	get() = /* non-default */

// JVM annotation-holding method = getNameWithoutExtension$annotations(Ljava/nio/file/Path;)V
val java.nio.file.Path.nameWithoutExtension: String
	// JVM method = getNameWithoutExtension(Ljava/nio/file/Path;)Ljava/lang/String;
	get() = /* non-default */

// JVM annotation-holding method = getPathString$annotations(Ljava/nio/file/Path;)V
inline val java.nio.file.Path.pathString: String
	// JVM method = getPathString(Ljava/nio/file/Path;)Ljava/lang/String;
	get() = /* non-default */


// *** FUNCTIONS ***

// JVM method = Path(Ljava/lang/String;)Ljava/nio/file/Path;
inline fun Path(path: String): java.nio.file.Path

// JVM method = Path(Ljava/lang/String;[Ljava/lang/String;)Ljava/nio/file/Path;
inline fun Path(base: String, vararg subpaths: String /* Array<out String> */): java.nio.file.Path

// JVM method = createTempDirectory(Ljava/nio/file/Path;Ljava/lang/String;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;
fun createTempDirectory(directory: java.nio.file.Path?, prefix: String? /* = default */, vararg attributes: java.nio.file.attribute.FileAttribute<*> /* Array<out java.nio.file.attribute.FileAttribute<*>> */): java.nio.file.Path

// JVM method = createTempDirectory(Ljava/lang/String;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;
inline fun createTempDirectory(prefix: String? /* = default */, vararg attributes: java.nio.file.attribute.FileAttribute<*> /* Array<out java.nio.file.attribute.FileAttribute<*>> */): java.nio.file.Path

// JVM method = createTempFile(Ljava/nio/file/Path;Ljava/lang/String;Ljava/lang/String;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;
fun createTempFile(directory: java.nio.file.Path?, prefix: String? /* = default */, suffix: String? /* = default */, vararg attributes: java.nio.file.attribute.FileAttribute<*> /* Array<out java.nio.file.attribute.FileAttribute<*>> */): java.nio.file.Path

// JVM method = createTempFile(Ljava/lang/String;Ljava/lang/String;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;
inline fun createTempFile(prefix: String? /* = default */, suffix: String? /* = default */, vararg attributes: java.nio.file.attribute.FileAttribute<*> /* Array<out java.nio.file.attribute.FileAttribute<*>> */): java.nio.file.Path

// JVM method = fileAttributeViewNotAvailable(Ljava/nio/file/Path;Ljava/lang/Class;)Ljava/lang/Void;
internal fun fileAttributeViewNotAvailable(path: java.nio.file.Path, attributeViewClass: java.lang.Class<*>): Nothing

// JVM method = fileVisitor(Lkotlin/jvm/functions/Function1;)Ljava/nio/file/FileVisitor;
fun fileVisitor(builderAction: kotlin.io.path.FileVisitorBuilder.() -> Unit): java.nio.file.FileVisitor<java.nio.file.Path> {
	contract {
		callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE)
	}
}

// JVM method = absolute(Ljava/nio/file/Path;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.absolute(): java.nio.file.Path

// JVM method = absolutePathString(Ljava/nio/file/Path;)Ljava/lang/String;
inline fun java.nio.file.Path.absolutePathString(): String

// JVM method = copyTo(Ljava/nio/file/Path;Ljava/nio/file/Path;[Ljava/nio/file/CopyOption;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.copyTo(target: java.nio.file.Path, vararg options: java.nio.file.CopyOption /* Array<out java.nio.file.CopyOption> */): java.nio.file.Path

// JVM method = copyTo(Ljava/nio/file/Path;Ljava/nio/file/Path;Z)Ljava/nio/file/Path;
inline fun java.nio.file.Path.copyTo(target: java.nio.file.Path, overwrite: Boolean /* = default */): java.nio.file.Path

// JVM method = createDirectories(Ljava/nio/file/Path;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.createDirectories(vararg attributes: java.nio.file.attribute.FileAttribute<*> /* Array<out java.nio.file.attribute.FileAttribute<*>> */): java.nio.file.Path

// JVM method = createDirectory(Ljava/nio/file/Path;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.createDirectory(vararg attributes: java.nio.file.attribute.FileAttribute<*> /* Array<out java.nio.file.attribute.FileAttribute<*>> */): java.nio.file.Path

// JVM method = createFile(Ljava/nio/file/Path;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.createFile(vararg attributes: java.nio.file.attribute.FileAttribute<*> /* Array<out java.nio.file.attribute.FileAttribute<*>> */): java.nio.file.Path

// JVM method = createLinkPointingTo(Ljava/nio/file/Path;Ljava/nio/file/Path;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.createLinkPointingTo(target: java.nio.file.Path): java.nio.file.Path

// JVM method = createSymbolicLinkPointingTo(Ljava/nio/file/Path;Ljava/nio/file/Path;[Ljava/nio/file/attribute/FileAttribute;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.createSymbolicLinkPointingTo(target: java.nio.file.Path, vararg attributes: java.nio.file.attribute.FileAttribute<*> /* Array<out java.nio.file.attribute.FileAttribute<*>> */): java.nio.file.Path

// JVM method = deleteExisting(Ljava/nio/file/Path;)V
inline fun java.nio.file.Path.deleteExisting()

// JVM method = deleteIfExists(Ljava/nio/file/Path;)Z
inline fun java.nio.file.Path.deleteIfExists(): Boolean

// JVM method = div(Ljava/nio/file/Path;Ljava/nio/file/Path;)Ljava/nio/file/Path;
inline operator fun java.nio.file.Path.div(other: java.nio.file.Path): java.nio.file.Path

// JVM method = div(Ljava/nio/file/Path;Ljava/lang/String;)Ljava/nio/file/Path;
inline operator fun java.nio.file.Path.div(other: String): java.nio.file.Path

// JVM method = exists(Ljava/nio/file/Path;[Ljava/nio/file/LinkOption;)Z
inline fun java.nio.file.Path.exists(vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): Boolean

// JVM method = fileAttributesView(Ljava/nio/file/Path;[Ljava/nio/file/LinkOption;)Ljava/nio/file/attribute/FileAttributeView;
inline fun <reified V : java.nio.file.attribute.FileAttributeView> java.nio.file.Path.fileAttributesView(vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): reified V : java.nio.file.attribute.FileAttributeView

// JVM method = fileAttributesViewOrNull(Ljava/nio/file/Path;[Ljava/nio/file/LinkOption;)Ljava/nio/file/attribute/FileAttributeView;
inline fun <reified V : java.nio.file.attribute.FileAttributeView> java.nio.file.Path.fileAttributesViewOrNull(vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): reified V : java.nio.file.attribute.FileAttributeView?

// JVM method = fileSize(Ljava/nio/file/Path;)J
inline fun java.nio.file.Path.fileSize(): Long

// JVM method = fileStore(Ljava/nio/file/Path;)Ljava/nio/file/FileStore;
inline fun java.nio.file.Path.fileStore(): java.nio.file.FileStore

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = forEachDirectoryEntry(Ljava/nio/file/Path;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
inline fun java.nio.file.Path.forEachDirectoryEntry(glob: String /* = default */, action: (java.nio.file.Path) -> Unit)

// JVM method = getAttribute(Ljava/nio/file/Path;Ljava/lang/String;[Ljava/nio/file/LinkOption;)Ljava/lang/Object;
inline fun java.nio.file.Path.getAttribute(attribute: String, vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): Any?

// JVM method = getLastModifiedTime(Ljava/nio/file/Path;[Ljava/nio/file/LinkOption;)Ljava/nio/file/attribute/FileTime;
inline fun java.nio.file.Path.getLastModifiedTime(vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): java.nio.file.attribute.FileTime

// JVM method = getOwner(Ljava/nio/file/Path;[Ljava/nio/file/LinkOption;)Ljava/nio/file/attribute/UserPrincipal;
inline fun java.nio.file.Path.getOwner(vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): java.nio.file.attribute.UserPrincipal?

// JVM method = getPosixFilePermissions(Ljava/nio/file/Path;[Ljava/nio/file/LinkOption;)Ljava/util/Set;
inline fun java.nio.file.Path.getPosixFilePermissions(vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): Set<java.nio.file.attribute.PosixFilePermission>

// JVM method = isDirectory(Ljava/nio/file/Path;[Ljava/nio/file/LinkOption;)Z
inline fun java.nio.file.Path.isDirectory(vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): Boolean

// JVM method = isExecutable(Ljava/nio/file/Path;)Z
inline fun java.nio.file.Path.isExecutable(): Boolean

// JVM method = isHidden(Ljava/nio/file/Path;)Z
inline fun java.nio.file.Path.isHidden(): Boolean

// JVM method = isReadable(Ljava/nio/file/Path;)Z
inline fun java.nio.file.Path.isReadable(): Boolean

// JVM method = isRegularFile(Ljava/nio/file/Path;[Ljava/nio/file/LinkOption;)Z
inline fun java.nio.file.Path.isRegularFile(vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): Boolean

// JVM method = isSameFileAs(Ljava/nio/file/Path;Ljava/nio/file/Path;)Z
inline fun java.nio.file.Path.isSameFileAs(other: java.nio.file.Path): Boolean

// JVM method = isSymbolicLink(Ljava/nio/file/Path;)Z
inline fun java.nio.file.Path.isSymbolicLink(): Boolean

// JVM method = isWritable(Ljava/nio/file/Path;)Z
inline fun java.nio.file.Path.isWritable(): Boolean

// JVM method = listDirectoryEntries(Ljava/nio/file/Path;Ljava/lang/String;)Ljava/util/List;
fun java.nio.file.Path.listDirectoryEntries(glob: String /* = default */): List<java.nio.file.Path>

// JVM method = moveTo(Ljava/nio/file/Path;Ljava/nio/file/Path;[Ljava/nio/file/CopyOption;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.moveTo(target: java.nio.file.Path, vararg options: java.nio.file.CopyOption /* Array<out java.nio.file.CopyOption> */): java.nio.file.Path

// JVM method = moveTo(Ljava/nio/file/Path;Ljava/nio/file/Path;Z)Ljava/nio/file/Path;
inline fun java.nio.file.Path.moveTo(target: java.nio.file.Path, overwrite: Boolean /* = default */): java.nio.file.Path

// JVM method = notExists(Ljava/nio/file/Path;[Ljava/nio/file/LinkOption;)Z
inline fun java.nio.file.Path.notExists(vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): Boolean

// JVM method = readAttributes(Ljava/nio/file/Path;[Ljava/nio/file/LinkOption;)Ljava/nio/file/attribute/BasicFileAttributes;
inline fun <reified A : java.nio.file.attribute.BasicFileAttributes> java.nio.file.Path.readAttributes(vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): reified A : java.nio.file.attribute.BasicFileAttributes

// JVM method = readAttributes(Ljava/nio/file/Path;Ljava/lang/String;[Ljava/nio/file/LinkOption;)Ljava/util/Map;
inline fun java.nio.file.Path.readAttributes(attributes: String, vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): Map<String, Any?>

// JVM method = readSymbolicLink(Ljava/nio/file/Path;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.readSymbolicLink(): java.nio.file.Path

// JVM method = relativeTo(Ljava/nio/file/Path;Ljava/nio/file/Path;)Ljava/nio/file/Path;
fun java.nio.file.Path.relativeTo(base: java.nio.file.Path): java.nio.file.Path

// JVM method = relativeToOrNull(Ljava/nio/file/Path;Ljava/nio/file/Path;)Ljava/nio/file/Path;
fun java.nio.file.Path.relativeToOrNull(base: java.nio.file.Path): java.nio.file.Path?

// JVM method = relativeToOrSelf(Ljava/nio/file/Path;Ljava/nio/file/Path;)Ljava/nio/file/Path;
fun java.nio.file.Path.relativeToOrSelf(base: java.nio.file.Path): java.nio.file.Path

// JVM method = setAttribute(Ljava/nio/file/Path;Ljava/lang/String;Ljava/lang/Object;[Ljava/nio/file/LinkOption;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.setAttribute(attribute: String, value: Any?, vararg options: java.nio.file.LinkOption /* Array<out java.nio.file.LinkOption> */): java.nio.file.Path

// JVM method = setLastModifiedTime(Ljava/nio/file/Path;Ljava/nio/file/attribute/FileTime;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.setLastModifiedTime(value: java.nio.file.attribute.FileTime): java.nio.file.Path

// JVM method = setOwner(Ljava/nio/file/Path;Ljava/nio/file/attribute/UserPrincipal;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.setOwner(value: java.nio.file.attribute.UserPrincipal): java.nio.file.Path

// JVM method = setPosixFilePermissions(Ljava/nio/file/Path;Ljava/util/Set;)Ljava/nio/file/Path;
inline fun java.nio.file.Path.setPosixFilePermissions(value: Set<java.nio.file.attribute.PosixFilePermission>): java.nio.file.Path

// JVM method = toPath(Ljava/net/URI;)Ljava/nio/file/Path;
inline fun java.net.URI.toPath(): java.nio.file.Path

// requires compiler version >= 1.3.50, otherwise diagnostic error
// JVM method = useDirectoryEntries(Ljava/nio/file/Path;Ljava/lang/String;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
inline fun <T> java.nio.file.Path.useDirectoryEntries(glob: String /* = default */, block: (Sequence<java.nio.file.Path>) -> T): T

// JVM method = visitFileTree(Ljava/nio/file/Path;Ljava/nio/file/FileVisitor;IZ)V
fun java.nio.file.Path.visitFileTree(visitor: java.nio.file.FileVisitor<java.nio.file.Path>, maxDepth: Int /* = default */, followLinks: Boolean /* = default */)

// JVM method = visitFileTree(Ljava/nio/file/Path;IZLkotlin/jvm/functions/Function1;)V
fun java.nio.file.Path.visitFileTree(maxDepth: Int /* = default */, followLinks: Boolean /* = default */, builderAction: kotlin.io.path.FileVisitorBuilder.() -> Unit) {
	contract {
		callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE)
	}
}

// JVM method = walk(Ljava/nio/file/Path;[Lkotlin/io/path/PathWalkOption;)Lkotlin/sequences/Sequence;
fun java.nio.file.Path.walk(vararg options: kotlin.io.path.PathWalkOption /* Array<out kotlin.io.path.PathWalkOption> */): Sequence<java.nio.file.Path>

// ------------------------------------------------------------------------------------------------------

